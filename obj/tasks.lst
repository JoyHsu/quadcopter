   1              		.syntax unified
   2              		.cpu cortex-m4
   3              		.eabi_attribute 27, 3
   4              		.fpu fpv4-sp-d16
   5              		.eabi_attribute 20, 1
   6              		.eabi_attribute 21, 1
   7              		.eabi_attribute 23, 3
   8              		.eabi_attribute 24, 1
   9              		.eabi_attribute 25, 1
  10              		.eabi_attribute 26, 1
  11              		.eabi_attribute 30, 6
  12              		.eabi_attribute 34, 1
  13              		.eabi_attribute 18, 4
  14              		.thumb
  15              		.file	"tasks.c"
  16              		.text
  17              	.Ltext0:
  18              		.cfi_sections	.debug_frame
  19              		.global	pxCurrentTCB
  20              		.section	.bss.pxCurrentTCB,"aw",%nobits
  21              		.align	2
  24              	pxCurrentTCB:
  25 0000 00000000 		.space	4
  26              		.section	.bss.pxReadyTasksLists,"aw",%nobits
  27              		.align	2
  30              	pxReadyTasksLists:
  31 0000 00000000 		.space	100
  31      00000000 
  31      00000000 
  31      00000000 
  31      00000000 
  32              		.section	.bss.xDelayedTaskList1,"aw",%nobits
  33              		.align	2
  36              	xDelayedTaskList1:
  37 0000 00000000 		.space	20
  37      00000000 
  37      00000000 
  37      00000000 
  37      00000000 
  38              		.section	.bss.xDelayedTaskList2,"aw",%nobits
  39              		.align	2
  42              	xDelayedTaskList2:
  43 0000 00000000 		.space	20
  43      00000000 
  43      00000000 
  43      00000000 
  43      00000000 
  44              		.section	.bss.pxDelayedTaskList,"aw",%nobits
  45              		.align	2
  48              	pxDelayedTaskList:
  49 0000 00000000 		.space	4
  50              		.section	.bss.pxOverflowDelayedTaskList,"aw",%nobits
  51              		.align	2
  54              	pxOverflowDelayedTaskList:
  55 0000 00000000 		.space	4
  56              		.section	.bss.xPendingReadyList,"aw",%nobits
  57              		.align	2
  60              	xPendingReadyList:
  61 0000 00000000 		.space	20
  61      00000000 
  61      00000000 
  61      00000000 
  61      00000000 
  62              		.section	.bss.xTasksWaitingTermination,"aw",%nobits
  63              		.align	2
  66              	xTasksWaitingTermination:
  67 0000 00000000 		.space	20
  67      00000000 
  67      00000000 
  67      00000000 
  67      00000000 
  68              		.section	.bss.uxTasksDeleted,"aw",%nobits
  69              		.align	2
  72              	uxTasksDeleted:
  73 0000 00000000 		.space	4
  74              		.section	.bss.xSuspendedTaskList,"aw",%nobits
  75              		.align	2
  78              	xSuspendedTaskList:
  79 0000 00000000 		.space	20
  79      00000000 
  79      00000000 
  79      00000000 
  79      00000000 
  80              		.section	.bss.xIdleTaskHandle,"aw",%nobits
  81              		.align	2
  84              	xIdleTaskHandle:
  85 0000 00000000 		.space	4
  86              		.section	.bss.uxCurrentNumberOfTasks,"aw",%nobits
  87              		.align	2
  90              	uxCurrentNumberOfTasks:
  91 0000 00000000 		.space	4
  92              		.section	.bss.xTickCount,"aw",%nobits
  93              		.align	2
  96              	xTickCount:
  97 0000 00000000 		.space	4
  98              		.section	.bss.uxTopUsedPriority,"aw",%nobits
  99              		.align	2
 102              	uxTopUsedPriority:
 103 0000 00000000 		.space	4
 104              		.section	.bss.uxTopReadyPriority,"aw",%nobits
 105              		.align	2
 108              	uxTopReadyPriority:
 109 0000 00000000 		.space	4
 110              		.section	.bss.xSchedulerRunning,"aw",%nobits
 111              		.align	2
 114              	xSchedulerRunning:
 115 0000 00000000 		.space	4
 116              		.section	.bss.uxSchedulerSuspended,"aw",%nobits
 117              		.align	2
 120              	uxSchedulerSuspended:
 121 0000 00000000 		.space	4
 122              		.section	.bss.uxMissedTicks,"aw",%nobits
 123              		.align	2
 126              	uxMissedTicks:
 127 0000 00000000 		.space	4
 128              		.section	.bss.xMissedYield,"aw",%nobits
 129              		.align	2
 132              	xMissedYield:
 133 0000 00000000 		.space	4
 134              		.section	.bss.xNumOfOverflows,"aw",%nobits
 135              		.align	2
 138              	xNumOfOverflows:
 139 0000 00000000 		.space	4
 140              		.section	.bss.uxTaskNumber,"aw",%nobits
 141              		.align	2
 144              	uxTaskNumber:
 145 0000 00000000 		.space	4
 146              		.section	.data.xNextTaskUnblockTime,"aw",%progbits
 147              		.align	2
 150              	xNextTaskUnblockTime:
 151 0000 FFFFFFFF 		.word	-1
 152              		.section	.bss.pcStatsString,"aw",%nobits
 153              		.align	2
 156              	pcStatsString:
 157 0000 00000000 		.space	50
 157      00000000 
 157      00000000 
 157      00000000 
 157      00000000 
 158 0032 0000     		.section	.bss.ulTaskSwitchedInTime,"aw",%nobits
 159              		.align	2
 162              	ulTaskSwitchedInTime:
 163 0000 00000000 		.space	4
 164              		.section	.text.xTaskGenericCreate,"ax",%progbits
 165              		.align	2
 166              		.global	xTaskGenericCreate
 167              		.thumb
 168              		.thumb_func
 170              	xTaskGenericCreate:
 171              	.LFB110:
 172              		.file 1 "FreeRTOS/Source/tasks.c"
   1:FreeRTOS/Source/tasks.c **** /*
   2:FreeRTOS/Source/tasks.c ****     FreeRTOS V7.0.2 - Copyright (C) 2011 Real Time Engineers Ltd.
   3:FreeRTOS/Source/tasks.c **** 	
   4:FreeRTOS/Source/tasks.c **** 
   5:FreeRTOS/Source/tasks.c ****     ***************************************************************************
   6:FreeRTOS/Source/tasks.c ****      *                                                                       *
   7:FreeRTOS/Source/tasks.c ****      *    FreeRTOS tutorial books are available in pdf and paperback.        *
   8:FreeRTOS/Source/tasks.c ****      *    Complete, revised, and edited pdf reference manuals are also       *
   9:FreeRTOS/Source/tasks.c ****      *    available.                                                         *
  10:FreeRTOS/Source/tasks.c ****      *                                                                       *
  11:FreeRTOS/Source/tasks.c ****      *    Purchasing FreeRTOS documentation will not only help you, by       *
  12:FreeRTOS/Source/tasks.c ****      *    ensuring you get running as quickly as possible and with an        *
  13:FreeRTOS/Source/tasks.c ****      *    in-depth knowledge of how to use FreeRTOS, it will also help       *
  14:FreeRTOS/Source/tasks.c ****      *    the FreeRTOS project to continue with its mission of providing     *
  15:FreeRTOS/Source/tasks.c ****      *    professional grade, cross platform, de facto standard solutions    *
  16:FreeRTOS/Source/tasks.c ****      *    for microcontrollers - completely free of charge!                  *
  17:FreeRTOS/Source/tasks.c ****      *                                                                       *
  18:FreeRTOS/Source/tasks.c ****      *    >>> See http://www.FreeRTOS.org/Documentation for details. <<<     *
  19:FreeRTOS/Source/tasks.c ****      *                                                                       *
  20:FreeRTOS/Source/tasks.c ****      *    Thank you for using FreeRTOS, and thank you for your support!      *
  21:FreeRTOS/Source/tasks.c ****      *                                                                       *
  22:FreeRTOS/Source/tasks.c ****     ***************************************************************************
  23:FreeRTOS/Source/tasks.c **** 
  24:FreeRTOS/Source/tasks.c **** 
  25:FreeRTOS/Source/tasks.c ****     This file is part of the FreeRTOS distribution.
  26:FreeRTOS/Source/tasks.c **** 
  27:FreeRTOS/Source/tasks.c ****     FreeRTOS is free software; you can redistribute it and/or modify it under
  28:FreeRTOS/Source/tasks.c ****     the terms of the GNU General Public License (version 2) as published by the
  29:FreeRTOS/Source/tasks.c ****     Free Software Foundation AND MODIFIED BY the FreeRTOS exception.
  30:FreeRTOS/Source/tasks.c ****     >>>NOTE<<< The modification to the GPL is included to allow you to
  31:FreeRTOS/Source/tasks.c ****     distribute a combined work that includes FreeRTOS without being obliged to
  32:FreeRTOS/Source/tasks.c ****     provide the source code for proprietary components outside of the FreeRTOS
  33:FreeRTOS/Source/tasks.c ****     kernel.  FreeRTOS is distributed in the hope that it will be useful, but
  34:FreeRTOS/Source/tasks.c ****     WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  35:FreeRTOS/Source/tasks.c ****     or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
  36:FreeRTOS/Source/tasks.c ****     more details. You should have received a copy of the GNU General Public
  37:FreeRTOS/Source/tasks.c ****     License and the FreeRTOS license exception along with FreeRTOS; if not it
  38:FreeRTOS/Source/tasks.c ****     can be viewed here: http://www.freertos.org/a00114.html and also obtained
  39:FreeRTOS/Source/tasks.c ****     by writing to Richard Barry, contact details for whom are available on the
  40:FreeRTOS/Source/tasks.c ****     FreeRTOS WEB site.
  41:FreeRTOS/Source/tasks.c **** 
  42:FreeRTOS/Source/tasks.c ****     1 tab == 4 spaces!
  43:FreeRTOS/Source/tasks.c **** 
  44:FreeRTOS/Source/tasks.c ****     http://www.FreeRTOS.org - Documentation, latest information, license and
  45:FreeRTOS/Source/tasks.c ****     contact details.
  46:FreeRTOS/Source/tasks.c **** 
  47:FreeRTOS/Source/tasks.c ****     http://www.SafeRTOS.com - A version that is certified for use in safety
  48:FreeRTOS/Source/tasks.c ****     critical systems.
  49:FreeRTOS/Source/tasks.c **** 
  50:FreeRTOS/Source/tasks.c ****     http://www.OpenRTOS.com - Commercial support, development, porting,
  51:FreeRTOS/Source/tasks.c ****     licensing and training services.
  52:FreeRTOS/Source/tasks.c **** */
  53:FreeRTOS/Source/tasks.c **** 
  54:FreeRTOS/Source/tasks.c **** 
  55:FreeRTOS/Source/tasks.c **** #include <stdio.h>
  56:FreeRTOS/Source/tasks.c **** #include <stdlib.h>
  57:FreeRTOS/Source/tasks.c **** #include <string.h>
  58:FreeRTOS/Source/tasks.c **** 
  59:FreeRTOS/Source/tasks.c **** /* Defining MPU_WRAPPERS_INCLUDED_FROM_API_FILE prevents task.h from redefining
  60:FreeRTOS/Source/tasks.c **** all the API functions to use the MPU wrappers.  That should only be done when
  61:FreeRTOS/Source/tasks.c **** task.h is included from an application file. */
  62:FreeRTOS/Source/tasks.c **** #define MPU_WRAPPERS_INCLUDED_FROM_API_FILE
  63:FreeRTOS/Source/tasks.c **** 
  64:FreeRTOS/Source/tasks.c **** #include "FreeRTOS.h"
  65:FreeRTOS/Source/tasks.c **** #include "task.h"
  66:FreeRTOS/Source/tasks.c **** #include "timers.h"
  67:FreeRTOS/Source/tasks.c **** #include "StackMacros.h"
  68:FreeRTOS/Source/tasks.c **** 
  69:FreeRTOS/Source/tasks.c **** #undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE
  70:FreeRTOS/Source/tasks.c **** 
  71:FreeRTOS/Source/tasks.c **** /*
  72:FreeRTOS/Source/tasks.c ****  * Macro to define the amount of stack available to the idle task.
  73:FreeRTOS/Source/tasks.c ****  */
  74:FreeRTOS/Source/tasks.c **** #define tskIDLE_STACK_SIZE	configMINIMAL_STACK_SIZE
  75:FreeRTOS/Source/tasks.c **** 
  76:FreeRTOS/Source/tasks.c **** /*
  77:FreeRTOS/Source/tasks.c ****  * Task control block.  A task control block (TCB) is allocated to each task,
  78:FreeRTOS/Source/tasks.c ****  * and stores the context of the task.
  79:FreeRTOS/Source/tasks.c ****  */
  80:FreeRTOS/Source/tasks.c **** typedef struct tskTaskControlBlock
  81:FreeRTOS/Source/tasks.c **** {
  82:FreeRTOS/Source/tasks.c **** 	volatile portSTACK_TYPE	*pxTopOfStack;		/*< Points to the location of the last item placed on the 
  83:FreeRTOS/Source/tasks.c **** 
  84:FreeRTOS/Source/tasks.c **** 	#if ( portUSING_MPU_WRAPPERS == 1 )
  85:FreeRTOS/Source/tasks.c **** 		xMPU_SETTINGS xMPUSettings;				/*< The MPU settings are defined as part of the port layer.  THIS 
  86:FreeRTOS/Source/tasks.c **** 	#endif	
  87:FreeRTOS/Source/tasks.c **** 	
  88:FreeRTOS/Source/tasks.c **** 	xListItem				xGenericListItem;	/*< List item used to place the TCB in ready and blocked queues. */
  89:FreeRTOS/Source/tasks.c **** 	xListItem				xEventListItem;		/*< List item used to place the TCB in event lists. */
  90:FreeRTOS/Source/tasks.c **** 	unsigned portBASE_TYPE	uxPriority;			/*< The priority of the task where 0 is the lowest priority. 
  91:FreeRTOS/Source/tasks.c **** 	portSTACK_TYPE			*pxStack;			/*< Points to the start of the stack. */
  92:FreeRTOS/Source/tasks.c **** 	signed char				pcTaskName[ configMAX_TASK_NAME_LEN ];/*< Descriptive name given to the task when c
  93:FreeRTOS/Source/tasks.c **** 
  94:FreeRTOS/Source/tasks.c **** 	#if ( portSTACK_GROWTH > 0 )
  95:FreeRTOS/Source/tasks.c **** 		portSTACK_TYPE *pxEndOfStack;			/*< Used for stack overflow checking on architectures where the s
  96:FreeRTOS/Source/tasks.c **** 	#endif
  97:FreeRTOS/Source/tasks.c **** 
  98:FreeRTOS/Source/tasks.c **** 	#if ( portCRITICAL_NESTING_IN_TCB == 1 )
  99:FreeRTOS/Source/tasks.c **** 		unsigned portBASE_TYPE uxCriticalNesting;
 100:FreeRTOS/Source/tasks.c **** 	#endif
 101:FreeRTOS/Source/tasks.c **** 
 102:FreeRTOS/Source/tasks.c **** 	#if ( configUSE_TRACE_FACILITY == 1 )
 103:FreeRTOS/Source/tasks.c **** 		unsigned portBASE_TYPE	uxTCBNumber;	/*< This is used for tracing the scheduler and making debuggi
 104:FreeRTOS/Source/tasks.c **** 	#endif
 105:FreeRTOS/Source/tasks.c **** 
 106:FreeRTOS/Source/tasks.c **** 	#if ( configUSE_MUTEXES == 1 )
 107:FreeRTOS/Source/tasks.c **** 		unsigned portBASE_TYPE uxBasePriority;	/*< The priority last assigned to the task - used by the p
 108:FreeRTOS/Source/tasks.c **** 	#endif
 109:FreeRTOS/Source/tasks.c **** 
 110:FreeRTOS/Source/tasks.c **** 	#if ( configUSE_APPLICATION_TASK_TAG == 1 )
 111:FreeRTOS/Source/tasks.c **** 		pdTASK_HOOK_CODE pxTaskTag;
 112:FreeRTOS/Source/tasks.c **** 	#endif
 113:FreeRTOS/Source/tasks.c **** 
 114:FreeRTOS/Source/tasks.c **** 	#if ( configGENERATE_RUN_TIME_STATS == 1 )
 115:FreeRTOS/Source/tasks.c **** 		unsigned long ulRunTimeCounter;		/*< Used for calculating how much CPU time each task is utilisin
 116:FreeRTOS/Source/tasks.c **** 	#endif
 117:FreeRTOS/Source/tasks.c **** 
 118:FreeRTOS/Source/tasks.c **** } tskTCB;
 119:FreeRTOS/Source/tasks.c **** 
 120:FreeRTOS/Source/tasks.c **** 
 121:FreeRTOS/Source/tasks.c **** /*
 122:FreeRTOS/Source/tasks.c ****  * Some kernel aware debuggers require data to be viewed to be global, rather
 123:FreeRTOS/Source/tasks.c ****  * than file scope.
 124:FreeRTOS/Source/tasks.c ****  */
 125:FreeRTOS/Source/tasks.c **** #ifdef portREMOVE_STATIC_QUALIFIER
 126:FreeRTOS/Source/tasks.c **** 	#define static
 127:FreeRTOS/Source/tasks.c **** #endif
 128:FreeRTOS/Source/tasks.c **** 
 129:FreeRTOS/Source/tasks.c **** /*lint -e956 */
 130:FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA tskTCB * volatile pxCurrentTCB = NULL;
 131:FreeRTOS/Source/tasks.c **** 
 132:FreeRTOS/Source/tasks.c **** /* Lists for ready and blocked tasks. --------------------*/
 133:FreeRTOS/Source/tasks.c **** 
 134:FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static xList pxReadyTasksLists[ configMAX_PRIORITIES ];	/*< Prioritised ready tasks
 135:FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static xList xDelayedTaskList1;							/*< Delayed tasks. */
 136:FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static xList xDelayedTaskList2;							/*< Delayed tasks (two lists are used - one f
 137:FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static xList * volatile pxDelayedTaskList ;				/*< Points to the delayed task list 
 138:FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static xList * volatile pxOverflowDelayedTaskList;		/*< Points to the delayed task 
 139:FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static xList xPendingReadyList;							/*< Tasks that have been readied while the sc
 140:FreeRTOS/Source/tasks.c **** 
 141:FreeRTOS/Source/tasks.c **** #if ( INCLUDE_vTaskDelete == 1 )
 142:FreeRTOS/Source/tasks.c **** 
 143:FreeRTOS/Source/tasks.c **** 	PRIVILEGED_DATA static xList xTasksWaitingTermination;				/*< Tasks that have been deleted - but t
 144:FreeRTOS/Source/tasks.c **** 	PRIVILEGED_DATA static volatile unsigned portBASE_TYPE uxTasksDeleted = ( unsigned portBASE_TYPE )
 145:FreeRTOS/Source/tasks.c **** 
 146:FreeRTOS/Source/tasks.c **** #endif
 147:FreeRTOS/Source/tasks.c **** 
 148:FreeRTOS/Source/tasks.c **** #if ( INCLUDE_vTaskSuspend == 1 )
 149:FreeRTOS/Source/tasks.c **** 
 150:FreeRTOS/Source/tasks.c **** 	PRIVILEGED_DATA static xList xSuspendedTaskList;					/*< Tasks that are currently suspended. */
 151:FreeRTOS/Source/tasks.c **** 
 152:FreeRTOS/Source/tasks.c **** #endif
 153:FreeRTOS/Source/tasks.c **** 
 154:FreeRTOS/Source/tasks.c **** #if ( INCLUDE_xTaskGetIdleTaskHandle == 1 )
 155:FreeRTOS/Source/tasks.c **** 	
 156:FreeRTOS/Source/tasks.c **** 	PRIVILEGED_DATA static xTaskHandle xIdleTaskHandle = NULL;
 157:FreeRTOS/Source/tasks.c **** 	
 158:FreeRTOS/Source/tasks.c **** #endif
 159:FreeRTOS/Source/tasks.c **** 
 160:FreeRTOS/Source/tasks.c **** /* File private variables. --------------------------------*/
 161:FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static volatile unsigned portBASE_TYPE uxCurrentNumberOfTasks 	= ( unsigned portBAS
 162:FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static volatile portTickType xTickCount 						= ( portTickType ) 0U;
 163:FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static unsigned portBASE_TYPE uxTopUsedPriority	 				= tskIDLE_PRIORITY;
 164:FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static volatile unsigned portBASE_TYPE uxTopReadyPriority 		= tskIDLE_PRIORITY;
 165:FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static volatile signed portBASE_TYPE xSchedulerRunning 			= pdFALSE;
 166:FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static volatile unsigned portBASE_TYPE uxSchedulerSuspended	 	= ( unsigned portBASE
 167:FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static volatile unsigned portBASE_TYPE uxMissedTicks 			= ( unsigned portBASE_TYPE 
 168:FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static volatile portBASE_TYPE xMissedYield 						= ( portBASE_TYPE ) pdFALSE;
 169:FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static volatile portBASE_TYPE xNumOfOverflows 					= ( portBASE_TYPE ) 0;
 170:FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static unsigned portBASE_TYPE uxTaskNumber 						= ( unsigned portBASE_TYPE ) 0U;
 171:FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static portTickType xNextTaskUnblockTime						= ( portTickType ) portMAX_DELAY;
 172:FreeRTOS/Source/tasks.c **** 
 173:FreeRTOS/Source/tasks.c **** #if ( configGENERATE_RUN_TIME_STATS == 1 )
 174:FreeRTOS/Source/tasks.c **** 
 175:FreeRTOS/Source/tasks.c **** 	PRIVILEGED_DATA static char pcStatsString[ 50 ] ;
 176:FreeRTOS/Source/tasks.c **** 	PRIVILEGED_DATA static unsigned long ulTaskSwitchedInTime = 0UL;	/*< Holds the value of a timer/co
 177:FreeRTOS/Source/tasks.c **** 	static void prvGenerateRunTimeStatsForTasksInList( const signed char *pcWriteBuffer, xList *pxList
 178:FreeRTOS/Source/tasks.c **** 
 179:FreeRTOS/Source/tasks.c **** #endif
 180:FreeRTOS/Source/tasks.c **** 
 181:FreeRTOS/Source/tasks.c **** /* Debugging and trace facilities private variables and macros. ------------*/
 182:FreeRTOS/Source/tasks.c **** 
 183:FreeRTOS/Source/tasks.c **** /*
 184:FreeRTOS/Source/tasks.c ****  * The value used to fill the stack of a task when the task is created.  This
 185:FreeRTOS/Source/tasks.c ****  * is used purely for checking the high water mark for tasks.
 186:FreeRTOS/Source/tasks.c ****  */
 187:FreeRTOS/Source/tasks.c **** #define tskSTACK_FILL_BYTE	( 0xa5U )
 188:FreeRTOS/Source/tasks.c **** 
 189:FreeRTOS/Source/tasks.c **** /*
 190:FreeRTOS/Source/tasks.c ****  * Macros used by vListTask to indicate which state a task is in.
 191:FreeRTOS/Source/tasks.c ****  */
 192:FreeRTOS/Source/tasks.c **** #define tskBLOCKED_CHAR		( ( signed char ) 'B' )
 193:FreeRTOS/Source/tasks.c **** #define tskREADY_CHAR		( ( signed char ) 'R' )
 194:FreeRTOS/Source/tasks.c **** #define tskDELETED_CHAR		( ( signed char ) 'D' )
 195:FreeRTOS/Source/tasks.c **** #define tskSUSPENDED_CHAR	( ( signed char ) 'S' )
 196:FreeRTOS/Source/tasks.c **** 
 197:FreeRTOS/Source/tasks.c **** /*
 198:FreeRTOS/Source/tasks.c ****  * Macros and private variables used by the trace facility.
 199:FreeRTOS/Source/tasks.c ****  */
 200:FreeRTOS/Source/tasks.c **** #if ( configUSE_TRACE_FACILITY == 1 )
 201:FreeRTOS/Source/tasks.c **** 
 202:FreeRTOS/Source/tasks.c **** 	#define tskSIZE_OF_EACH_TRACE_LINE			( ( unsigned long ) ( sizeof( unsigned long ) + sizeof( unsig
 203:FreeRTOS/Source/tasks.c **** 	PRIVILEGED_DATA static volatile signed char * volatile pcTraceBuffer;
 204:FreeRTOS/Source/tasks.c **** 	PRIVILEGED_DATA static signed char *pcTraceBufferStart;
 205:FreeRTOS/Source/tasks.c **** 	PRIVILEGED_DATA static signed char *pcTraceBufferEnd;
 206:FreeRTOS/Source/tasks.c **** 	PRIVILEGED_DATA static signed portBASE_TYPE xTracing = pdFALSE;
 207:FreeRTOS/Source/tasks.c **** 	static unsigned portBASE_TYPE uxPreviousTask = 255U;
 208:FreeRTOS/Source/tasks.c **** 	PRIVILEGED_DATA static char pcStatusString[ 50 ];
 209:FreeRTOS/Source/tasks.c **** 
 210:FreeRTOS/Source/tasks.c **** #endif
 211:FreeRTOS/Source/tasks.c **** 
 212:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 213:FreeRTOS/Source/tasks.c **** 
 214:FreeRTOS/Source/tasks.c **** /*
 215:FreeRTOS/Source/tasks.c ****  * Macro that writes a trace of scheduler activity to a buffer.  This trace
 216:FreeRTOS/Source/tasks.c ****  * shows which task is running when and is very useful as a debugging tool.
 217:FreeRTOS/Source/tasks.c ****  * As this macro is called each context switch it is a good idea to undefine
 218:FreeRTOS/Source/tasks.c ****  * it if not using the facility.
 219:FreeRTOS/Source/tasks.c ****  */
 220:FreeRTOS/Source/tasks.c **** #if ( configUSE_TRACE_FACILITY == 1 )
 221:FreeRTOS/Source/tasks.c **** 
 222:FreeRTOS/Source/tasks.c **** 	#define vWriteTraceToBuffer()																	\
 223:FreeRTOS/Source/tasks.c **** 	{																								\
 224:FreeRTOS/Source/tasks.c **** 		if( xTracing != pdFALSE )																	\
 225:FreeRTOS/Source/tasks.c **** 		{																							\
 226:FreeRTOS/Source/tasks.c **** 			if( uxPreviousTask != pxCurrentTCB->uxTCBNumber )										\
 227:FreeRTOS/Source/tasks.c **** 			{																						\
 228:FreeRTOS/Source/tasks.c **** 				if( ( pcTraceBuffer + tskSIZE_OF_EACH_TRACE_LINE ) < pcTraceBufferEnd )				\
 229:FreeRTOS/Source/tasks.c **** 				{																					\
 230:FreeRTOS/Source/tasks.c **** 					uxPreviousTask = pxCurrentTCB->uxTCBNumber;										\
 231:FreeRTOS/Source/tasks.c **** 					*( unsigned long * ) pcTraceBuffer = ( unsigned long ) xTickCount;				\
 232:FreeRTOS/Source/tasks.c **** 					pcTraceBuffer += sizeof( unsigned long );										\
 233:FreeRTOS/Source/tasks.c **** 					*( unsigned long * ) pcTraceBuffer = ( unsigned long ) uxPreviousTask;			\
 234:FreeRTOS/Source/tasks.c **** 					pcTraceBuffer += sizeof( unsigned long );										\
 235:FreeRTOS/Source/tasks.c **** 				}																					\
 236:FreeRTOS/Source/tasks.c **** 				else																				\
 237:FreeRTOS/Source/tasks.c **** 				{																					\
 238:FreeRTOS/Source/tasks.c **** 					xTracing = pdFALSE;																\
 239:FreeRTOS/Source/tasks.c **** 				}																					\
 240:FreeRTOS/Source/tasks.c **** 			}																						\
 241:FreeRTOS/Source/tasks.c **** 		}																							\
 242:FreeRTOS/Source/tasks.c **** 	}
 243:FreeRTOS/Source/tasks.c **** 
 244:FreeRTOS/Source/tasks.c **** #else
 245:FreeRTOS/Source/tasks.c **** 
 246:FreeRTOS/Source/tasks.c **** 	#define vWriteTraceToBuffer()
 247:FreeRTOS/Source/tasks.c **** 
 248:FreeRTOS/Source/tasks.c **** #endif
 249:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 250:FreeRTOS/Source/tasks.c **** 
 251:FreeRTOS/Source/tasks.c **** /*
 252:FreeRTOS/Source/tasks.c ****  * Place the task represented by pxTCB into the appropriate ready queue for
 253:FreeRTOS/Source/tasks.c ****  * the task.  It is inserted at the end of the list.  One quirk of this is
 254:FreeRTOS/Source/tasks.c ****  * that if the task being inserted is at the same priority as the currently
 255:FreeRTOS/Source/tasks.c ****  * executing task, then it will only be rescheduled after the currently
 256:FreeRTOS/Source/tasks.c ****  * executing task has been rescheduled.
 257:FreeRTOS/Source/tasks.c ****  */
 258:FreeRTOS/Source/tasks.c **** #define prvAddTaskToReadyQueue( pxTCB )																					\
 259:FreeRTOS/Source/tasks.c **** 	if( ( pxTCB )->uxPriority > uxTopReadyPriority )																	\
 260:FreeRTOS/Source/tasks.c **** 	{																													\
 261:FreeRTOS/Source/tasks.c **** 		uxTopReadyPriority = ( pxTCB )->uxPriority;																		\
 262:FreeRTOS/Source/tasks.c **** 	}																													\
 263:FreeRTOS/Source/tasks.c **** 	vListInsertEnd( ( xList * ) &( pxReadyTasksLists[ ( pxTCB )->uxPriority ] ), &( ( pxTCB )->xGeneri
 264:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 265:FreeRTOS/Source/tasks.c **** 
 266:FreeRTOS/Source/tasks.c **** /*
 267:FreeRTOS/Source/tasks.c ****  * Macro that looks at the list of tasks that are currently delayed to see if
 268:FreeRTOS/Source/tasks.c ****  * any require waking.
 269:FreeRTOS/Source/tasks.c ****  *
 270:FreeRTOS/Source/tasks.c ****  * Tasks are stored in the queue in the order of their wake time - meaning
 271:FreeRTOS/Source/tasks.c ****  * once one tasks has been found whose timer has not expired we need not look
 272:FreeRTOS/Source/tasks.c ****  * any further down the list.
 273:FreeRTOS/Source/tasks.c ****  */
 274:FreeRTOS/Source/tasks.c **** #define prvCheckDelayedTasks()															\
 275:FreeRTOS/Source/tasks.c **** {																						\
 276:FreeRTOS/Source/tasks.c **** portTickType xItemValue;																\
 277:FreeRTOS/Source/tasks.c **** 																						\
 278:FreeRTOS/Source/tasks.c **** 	/* Is the tick count greater than or equal to the wake time of the first			\
 279:FreeRTOS/Source/tasks.c **** 	task referenced from the delayed tasks list? */										\
 280:FreeRTOS/Source/tasks.c **** 	if( xTickCount >= xNextTaskUnblockTime )											\
 281:FreeRTOS/Source/tasks.c **** 	{																					\
 282:FreeRTOS/Source/tasks.c **** 		for( ;; )																		\
 283:FreeRTOS/Source/tasks.c **** 		{																				\
 284:FreeRTOS/Source/tasks.c **** 			if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )						\
 285:FreeRTOS/Source/tasks.c **** 			{																			\
 286:FreeRTOS/Source/tasks.c **** 				/* The delayed list is empty.  Set xNextTaskUnblockTime to the			\
 287:FreeRTOS/Source/tasks.c **** 				maximum possible value so it is extremely unlikely that the				\
 288:FreeRTOS/Source/tasks.c **** 				if( xTickCount >= xNextTaskUnblockTime ) test will pass next			\
 289:FreeRTOS/Source/tasks.c **** 				time through. */														\
 290:FreeRTOS/Source/tasks.c **** 				xNextTaskUnblockTime = portMAX_DELAY;									\
 291:FreeRTOS/Source/tasks.c **** 				break;																	\
 292:FreeRTOS/Source/tasks.c **** 			}																			\
 293:FreeRTOS/Source/tasks.c **** 			else																		\
 294:FreeRTOS/Source/tasks.c **** 			{																			\
 295:FreeRTOS/Source/tasks.c **** 				/* The delayed list is not empty, get the value of the item at			\
 296:FreeRTOS/Source/tasks.c **** 				the head of the delayed list.  This is the time at which the			\
 297:FreeRTOS/Source/tasks.c **** 				task at the head of the delayed list should be removed from				\
 298:FreeRTOS/Source/tasks.c **** 				the Blocked state. */													\
 299:FreeRTOS/Source/tasks.c **** 				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );	\
 300:FreeRTOS/Source/tasks.c **** 				xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );	\
 301:FreeRTOS/Source/tasks.c **** 																						\
 302:FreeRTOS/Source/tasks.c **** 				if( xTickCount < xItemValue )											\
 303:FreeRTOS/Source/tasks.c **** 				{																		\
 304:FreeRTOS/Source/tasks.c **** 					/* It is not time to unblock this item yet, but the item			\
 305:FreeRTOS/Source/tasks.c **** 					value is the time at which the task at the head of the				\
 306:FreeRTOS/Source/tasks.c **** 					blocked list should be removed from the Blocked state -				\
 307:FreeRTOS/Source/tasks.c **** 					so record the item value in xNextTaskUnblockTime. */				\
 308:FreeRTOS/Source/tasks.c **** 					xNextTaskUnblockTime = xItemValue;									\
 309:FreeRTOS/Source/tasks.c **** 					break;																\
 310:FreeRTOS/Source/tasks.c **** 				}																		\
 311:FreeRTOS/Source/tasks.c **** 																						\
 312:FreeRTOS/Source/tasks.c **** 				/* It is time to remove the item from the Blocked state. */				\
 313:FreeRTOS/Source/tasks.c **** 				vListRemove( &( pxTCB->xGenericListItem ) );							\
 314:FreeRTOS/Source/tasks.c **** 																						\
 315:FreeRTOS/Source/tasks.c **** 				/* Is the task waiting on an event also? */								\
 316:FreeRTOS/Source/tasks.c **** 				if( pxTCB->xEventListItem.pvContainer != NULL )							\
 317:FreeRTOS/Source/tasks.c **** 				{																		\
 318:FreeRTOS/Source/tasks.c **** 					vListRemove( &( pxTCB->xEventListItem ) );							\
 319:FreeRTOS/Source/tasks.c **** 				}																		\
 320:FreeRTOS/Source/tasks.c **** 				prvAddTaskToReadyQueue( pxTCB );										\
 321:FreeRTOS/Source/tasks.c **** 			}																			\
 322:FreeRTOS/Source/tasks.c **** 		}																				\
 323:FreeRTOS/Source/tasks.c **** 	}																					\
 324:FreeRTOS/Source/tasks.c **** }
 325:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 326:FreeRTOS/Source/tasks.c **** 
 327:FreeRTOS/Source/tasks.c **** /*
 328:FreeRTOS/Source/tasks.c ****  * Several functions take an xTaskHandle parameter that can optionally be NULL,
 329:FreeRTOS/Source/tasks.c ****  * where NULL is used to indicate that the handle of the currently executing
 330:FreeRTOS/Source/tasks.c ****  * task should be used in place of the parameter.  This macro simply checks to
 331:FreeRTOS/Source/tasks.c ****  * see if the parameter is NULL and returns a pointer to the appropriate TCB.
 332:FreeRTOS/Source/tasks.c ****  */
 333:FreeRTOS/Source/tasks.c **** #define prvGetTCBFromHandle( pxHandle ) ( ( ( pxHandle ) == NULL ) ? ( tskTCB * ) pxCurrentTCB : ( 
 334:FreeRTOS/Source/tasks.c **** 
 335:FreeRTOS/Source/tasks.c **** /* Callback function prototypes. --------------------------*/
 336:FreeRTOS/Source/tasks.c **** extern void vApplicationStackOverflowHook( xTaskHandle *pxTask, signed char *pcTaskName );
 337:FreeRTOS/Source/tasks.c **** extern void vApplicationTickHook( void );
 338:FreeRTOS/Source/tasks.c **** 		
 339:FreeRTOS/Source/tasks.c **** /* File private functions. --------------------------------*/
 340:FreeRTOS/Source/tasks.c **** 
 341:FreeRTOS/Source/tasks.c **** /*
 342:FreeRTOS/Source/tasks.c ****  * Utility to ready a TCB for a given task.  Mainly just copies the parameters
 343:FreeRTOS/Source/tasks.c ****  * into the TCB structure.
 344:FreeRTOS/Source/tasks.c ****  */
 345:FreeRTOS/Source/tasks.c **** static void prvInitialiseTCBVariables( tskTCB *pxTCB, const signed char * const pcName, unsigned po
 346:FreeRTOS/Source/tasks.c **** 
 347:FreeRTOS/Source/tasks.c **** /*
 348:FreeRTOS/Source/tasks.c ****  * Utility to ready all the lists used by the scheduler.  This is called
 349:FreeRTOS/Source/tasks.c ****  * automatically upon the creation of the first task.
 350:FreeRTOS/Source/tasks.c ****  */
 351:FreeRTOS/Source/tasks.c **** static void prvInitialiseTaskLists( void ) PRIVILEGED_FUNCTION;
 352:FreeRTOS/Source/tasks.c **** 
 353:FreeRTOS/Source/tasks.c **** /*
 354:FreeRTOS/Source/tasks.c ****  * The idle task, which as all tasks is implemented as a never ending loop.
 355:FreeRTOS/Source/tasks.c ****  * The idle task is automatically created and added to the ready lists upon
 356:FreeRTOS/Source/tasks.c ****  * creation of the first user task.
 357:FreeRTOS/Source/tasks.c ****  *
 358:FreeRTOS/Source/tasks.c ****  * The portTASK_FUNCTION_PROTO() macro is used to allow port/compiler specific
 359:FreeRTOS/Source/tasks.c ****  * language extensions.  The equivalent prototype for this function is:
 360:FreeRTOS/Source/tasks.c ****  *
 361:FreeRTOS/Source/tasks.c ****  * void prvIdleTask( void *pvParameters );
 362:FreeRTOS/Source/tasks.c ****  *
 363:FreeRTOS/Source/tasks.c ****  */
 364:FreeRTOS/Source/tasks.c **** static portTASK_FUNCTION_PROTO( prvIdleTask, pvParameters );
 365:FreeRTOS/Source/tasks.c **** 
 366:FreeRTOS/Source/tasks.c **** /*
 367:FreeRTOS/Source/tasks.c ****  * Utility to free all memory allocated by the scheduler to hold a TCB,
 368:FreeRTOS/Source/tasks.c ****  * including the stack pointed to by the TCB.
 369:FreeRTOS/Source/tasks.c ****  *
 370:FreeRTOS/Source/tasks.c ****  * This does not free memory allocated by the task itself (i.e. memory
 371:FreeRTOS/Source/tasks.c ****  * allocated by calls to pvPortMalloc from within the tasks application code).
 372:FreeRTOS/Source/tasks.c ****  */
 373:FreeRTOS/Source/tasks.c **** #if ( INCLUDE_vTaskDelete == 1 )
 374:FreeRTOS/Source/tasks.c **** 
 375:FreeRTOS/Source/tasks.c **** 	static void prvDeleteTCB( tskTCB *pxTCB ) PRIVILEGED_FUNCTION;
 376:FreeRTOS/Source/tasks.c **** 
 377:FreeRTOS/Source/tasks.c **** #endif
 378:FreeRTOS/Source/tasks.c **** 
 379:FreeRTOS/Source/tasks.c **** /*
 380:FreeRTOS/Source/tasks.c ****  * Used only by the idle task.  This checks to see if anything has been placed
 381:FreeRTOS/Source/tasks.c ****  * in the list of tasks waiting to be deleted.  If so the task is cleaned up
 382:FreeRTOS/Source/tasks.c ****  * and its TCB deleted.
 383:FreeRTOS/Source/tasks.c ****  */
 384:FreeRTOS/Source/tasks.c **** static void prvCheckTasksWaitingTermination( void ) PRIVILEGED_FUNCTION;
 385:FreeRTOS/Source/tasks.c **** 
 386:FreeRTOS/Source/tasks.c **** /*
 387:FreeRTOS/Source/tasks.c ****  * The currently executing task is entering the Blocked state.  Add the task to
 388:FreeRTOS/Source/tasks.c ****  * either the current or the overflow delayed task list.
 389:FreeRTOS/Source/tasks.c ****  */
 390:FreeRTOS/Source/tasks.c **** static void prvAddCurrentTaskToDelayedList( portTickType xTimeToWake ) PRIVILEGED_FUNCTION;
 391:FreeRTOS/Source/tasks.c **** 
 392:FreeRTOS/Source/tasks.c **** /*
 393:FreeRTOS/Source/tasks.c ****  * Allocates memory from the heap for a TCB and associated stack.  Checks the
 394:FreeRTOS/Source/tasks.c ****  * allocation was successful.
 395:FreeRTOS/Source/tasks.c ****  */
 396:FreeRTOS/Source/tasks.c **** static tskTCB *prvAllocateTCBAndStack( unsigned short usStackDepth, portSTACK_TYPE *puxStackBuffer 
 397:FreeRTOS/Source/tasks.c **** 
 398:FreeRTOS/Source/tasks.c **** /*
 399:FreeRTOS/Source/tasks.c ****  * Called from vTaskList.  vListTasks details all the tasks currently under
 400:FreeRTOS/Source/tasks.c ****  * control of the scheduler.  The tasks may be in one of a number of lists.
 401:FreeRTOS/Source/tasks.c ****  * prvListTaskWithinSingleList accepts a list and details the tasks from
 402:FreeRTOS/Source/tasks.c ****  * within just that list.
 403:FreeRTOS/Source/tasks.c ****  *
 404:FreeRTOS/Source/tasks.c ****  * THIS FUNCTION IS INTENDED FOR DEBUGGING ONLY, AND SHOULD NOT BE CALLED FROM
 405:FreeRTOS/Source/tasks.c ****  * NORMAL APPLICATION CODE.
 406:FreeRTOS/Source/tasks.c ****  */
 407:FreeRTOS/Source/tasks.c **** #if ( configUSE_TRACE_FACILITY == 1 )
 408:FreeRTOS/Source/tasks.c **** 
 409:FreeRTOS/Source/tasks.c **** 	static void prvListTaskWithinSingleList( const signed char *pcWriteBuffer, xList *pxList, signed c
 410:FreeRTOS/Source/tasks.c **** 
 411:FreeRTOS/Source/tasks.c **** #endif
 412:FreeRTOS/Source/tasks.c **** 
 413:FreeRTOS/Source/tasks.c **** /*
 414:FreeRTOS/Source/tasks.c ****  * When a task is created, the stack of the task is filled with a known value.
 415:FreeRTOS/Source/tasks.c ****  * This function determines the 'high water mark' of the task stack by
 416:FreeRTOS/Source/tasks.c ****  * determining how much of the stack remains at the original preset value.
 417:FreeRTOS/Source/tasks.c ****  */
 418:FreeRTOS/Source/tasks.c **** #if ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) )
 419:FreeRTOS/Source/tasks.c **** 
 420:FreeRTOS/Source/tasks.c **** 	static unsigned short usTaskCheckFreeStackSpace( const unsigned char * pucStackByte ) PRIVILEGED_F
 421:FreeRTOS/Source/tasks.c **** 
 422:FreeRTOS/Source/tasks.c **** #endif
 423:FreeRTOS/Source/tasks.c **** 
 424:FreeRTOS/Source/tasks.c **** 
 425:FreeRTOS/Source/tasks.c **** /*lint +e956 */
 426:FreeRTOS/Source/tasks.c **** 
 427:FreeRTOS/Source/tasks.c **** 
 428:FreeRTOS/Source/tasks.c **** 
 429:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------
 430:FreeRTOS/Source/tasks.c ****  * TASK CREATION API documented in task.h
 431:FreeRTOS/Source/tasks.c ****  *----------------------------------------------------------*/
 432:FreeRTOS/Source/tasks.c **** 
 433:FreeRTOS/Source/tasks.c **** signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, 
 434:FreeRTOS/Source/tasks.c **** {
 173              		.loc 1 434 0
 174              		.cfi_startproc
 175              		@ args = 16, pretend = 0, frame = 32
 176              		@ frame_needed = 1, uses_anonymous_args = 0
 177 0000 80B5     		push	{r7, lr}
 178              	.LCFI0:
 179              		.cfi_def_cfa_offset 8
 180              		.cfi_offset 14, -4
 181              		.cfi_offset 7, -8
 182 0002 8AB0     		sub	sp, sp, #40
 183              	.LCFI1:
 184              		.cfi_def_cfa_offset 48
 185 0004 02AF     		add	r7, sp, #8
 186              	.LCFI2:
 187              		.cfi_def_cfa 7, 40
 188 0006 F860     		str	r0, [r7, #12]
 189 0008 B960     		str	r1, [r7, #8]
 190 000a 3B60     		str	r3, [r7, #0]
 191 000c 1346     		mov	r3, r2	@ movhi
 192 000e FB80     		strh	r3, [r7, #6]	@ movhi
 435:FreeRTOS/Source/tasks.c **** signed portBASE_TYPE xReturn;
 436:FreeRTOS/Source/tasks.c **** tskTCB * pxNewTCB;
 437:FreeRTOS/Source/tasks.c **** 
 438:FreeRTOS/Source/tasks.c **** 	configASSERT( pxTaskCode );
 439:FreeRTOS/Source/tasks.c **** 	configASSERT( ( uxPriority < configMAX_PRIORITIES ) );
 440:FreeRTOS/Source/tasks.c **** 
 441:FreeRTOS/Source/tasks.c **** 	/* Allocate the memory required by the TCB and stack for the new task,
 442:FreeRTOS/Source/tasks.c **** 	checking that the allocation was successful. */
 443:FreeRTOS/Source/tasks.c **** 	pxNewTCB = prvAllocateTCBAndStack( usStackDepth, puxStackBuffer );
 193              		.loc 1 443 0
 194 0010 FB88     		ldrh	r3, [r7, #6]
 195 0012 1846     		mov	r0, r3
 196 0014 396B     		ldr	r1, [r7, #48]
 197 0016 FFF7FEFF 		bl	prvAllocateTCBAndStack
 198 001a B861     		str	r0, [r7, #24]
 444:FreeRTOS/Source/tasks.c **** 
 445:FreeRTOS/Source/tasks.c **** 	if( pxNewTCB != NULL )
 199              		.loc 1 445 0
 200 001c BB69     		ldr	r3, [r7, #24]
 201 001e 002B     		cmp	r3, #0
 202 0020 00F0A580 		beq	.L2
 203              	.LBB2:
 446:FreeRTOS/Source/tasks.c **** 	{
 447:FreeRTOS/Source/tasks.c **** 		portSTACK_TYPE *pxTopOfStack;
 448:FreeRTOS/Source/tasks.c **** 
 449:FreeRTOS/Source/tasks.c **** 		#if( portUSING_MPU_WRAPPERS == 1 )
 450:FreeRTOS/Source/tasks.c **** 			/* Should the task be created in privileged mode? */
 451:FreeRTOS/Source/tasks.c **** 			portBASE_TYPE xRunPrivileged;
 452:FreeRTOS/Source/tasks.c **** 			if( ( uxPriority & portPRIVILEGE_BIT ) != 0U )
 453:FreeRTOS/Source/tasks.c **** 			{
 454:FreeRTOS/Source/tasks.c **** 				xRunPrivileged = pdTRUE;
 455:FreeRTOS/Source/tasks.c **** 			}
 456:FreeRTOS/Source/tasks.c **** 			else
 457:FreeRTOS/Source/tasks.c **** 			{
 458:FreeRTOS/Source/tasks.c **** 				xRunPrivileged = pdFALSE;
 459:FreeRTOS/Source/tasks.c **** 			}
 460:FreeRTOS/Source/tasks.c **** 			uxPriority &= ~portPRIVILEGE_BIT;
 461:FreeRTOS/Source/tasks.c **** 		#endif /* portUSING_MPU_WRAPPERS == 1 */
 462:FreeRTOS/Source/tasks.c **** 
 463:FreeRTOS/Source/tasks.c **** 		/* Calculate the top of stack address.  This depends on whether the
 464:FreeRTOS/Source/tasks.c **** 		stack grows from high memory to low (as per the 80x86) or visa versa.
 465:FreeRTOS/Source/tasks.c **** 		portSTACK_GROWTH is used to make the result positive or negative as
 466:FreeRTOS/Source/tasks.c **** 		required by the port. */
 467:FreeRTOS/Source/tasks.c **** 		#if( portSTACK_GROWTH < 0 )
 468:FreeRTOS/Source/tasks.c **** 		{
 469:FreeRTOS/Source/tasks.c **** 			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( unsigned short ) 1 );
 204              		.loc 1 469 0
 205 0024 BB69     		ldr	r3, [r7, #24]
 206 0026 1A6B     		ldr	r2, [r3, #48]
 207 0028 FB88     		ldrh	r3, [r7, #6]
 208 002a 03F1FF33 		add	r3, r3, #-1
 209 002e 4FEA8303 		lsl	r3, r3, #2
 210 0032 D318     		adds	r3, r2, r3
 211 0034 7B61     		str	r3, [r7, #20]
 470:FreeRTOS/Source/tasks.c **** 			pxTopOfStack = ( portSTACK_TYPE * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) & ( ( portPOINT
 212              		.loc 1 470 0
 213 0036 7B69     		ldr	r3, [r7, #20]
 214 0038 23F00703 		bic	r3, r3, #7
 215 003c 7B61     		str	r3, [r7, #20]
 471:FreeRTOS/Source/tasks.c **** 
 472:FreeRTOS/Source/tasks.c **** 			/* Check the alignment of the calculated top of stack is correct. */
 473:FreeRTOS/Source/tasks.c **** 			configASSERT( ( ( ( unsigned long ) pxTopOfStack & ( unsigned long ) portBYTE_ALIGNMENT_MASK ) =
 474:FreeRTOS/Source/tasks.c **** 		}
 475:FreeRTOS/Source/tasks.c **** 		#else
 476:FreeRTOS/Source/tasks.c **** 		{
 477:FreeRTOS/Source/tasks.c **** 			pxTopOfStack = pxNewTCB->pxStack;
 478:FreeRTOS/Source/tasks.c **** 			
 479:FreeRTOS/Source/tasks.c **** 			/* Check the alignment of the stack buffer is correct. */
 480:FreeRTOS/Source/tasks.c **** 			configASSERT( ( ( ( unsigned long ) pxNewTCB->pxStack & ( unsigned long ) portBYTE_ALIGNMENT_MAS
 481:FreeRTOS/Source/tasks.c **** 
 482:FreeRTOS/Source/tasks.c **** 			/* If we want to use stack checking on architectures that use
 483:FreeRTOS/Source/tasks.c **** 			a positive stack growth direction then we also need to store the
 484:FreeRTOS/Source/tasks.c **** 			other extreme of the stack space. */
 485:FreeRTOS/Source/tasks.c **** 			pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( usStackDepth - 1 );
 486:FreeRTOS/Source/tasks.c **** 		}
 487:FreeRTOS/Source/tasks.c **** 		#endif
 488:FreeRTOS/Source/tasks.c **** 
 489:FreeRTOS/Source/tasks.c **** 		/* Setup the newly allocated TCB with the initial state of the task. */
 490:FreeRTOS/Source/tasks.c **** 		prvInitialiseTCBVariables( pxNewTCB, pcName, uxPriority, xRegions, usStackDepth );
 216              		.loc 1 490 0
 217 003e FB88     		ldrh	r3, [r7, #6]
 218 0040 0093     		str	r3, [sp, #0]
 219 0042 B869     		ldr	r0, [r7, #24]
 220 0044 B968     		ldr	r1, [r7, #8]
 221 0046 BA6A     		ldr	r2, [r7, #40]
 222 0048 7B6B     		ldr	r3, [r7, #52]
 223 004a FFF7FEFF 		bl	prvInitialiseTCBVariables
 491:FreeRTOS/Source/tasks.c **** 
 492:FreeRTOS/Source/tasks.c **** 		/* Initialize the TCB stack to look as if the task was already running,
 493:FreeRTOS/Source/tasks.c **** 		but had been interrupted by the scheduler.  The return address is set
 494:FreeRTOS/Source/tasks.c **** 		to the start of the task function. Once the stack has been initialised
 495:FreeRTOS/Source/tasks.c **** 		the	top of stack variable is updated. */
 496:FreeRTOS/Source/tasks.c **** 		#if( portUSING_MPU_WRAPPERS == 1 )
 497:FreeRTOS/Source/tasks.c **** 		{
 498:FreeRTOS/Source/tasks.c **** 			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPriv
 499:FreeRTOS/Source/tasks.c **** 		}
 500:FreeRTOS/Source/tasks.c **** 		#else
 501:FreeRTOS/Source/tasks.c **** 		{
 502:FreeRTOS/Source/tasks.c **** 			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
 224              		.loc 1 502 0
 225 004e 7869     		ldr	r0, [r7, #20]
 226 0050 F968     		ldr	r1, [r7, #12]
 227 0052 3A68     		ldr	r2, [r7, #0]
 228 0054 FFF7FEFF 		bl	pxPortInitialiseStack
 229 0058 0246     		mov	r2, r0
 230 005a BB69     		ldr	r3, [r7, #24]
 231 005c 1A60     		str	r2, [r3, #0]
 503:FreeRTOS/Source/tasks.c **** 		}
 504:FreeRTOS/Source/tasks.c **** 		#endif
 505:FreeRTOS/Source/tasks.c **** 
 506:FreeRTOS/Source/tasks.c **** 		/* Check the alignment of the initialised stack. */
 507:FreeRTOS/Source/tasks.c **** 		configASSERT( ( ( ( unsigned long ) pxNewTCB->pxTopOfStack & ( unsigned long ) portBYTE_ALIGNMENT
 508:FreeRTOS/Source/tasks.c **** 
 509:FreeRTOS/Source/tasks.c **** 		if( ( void * ) pxCreatedTask != NULL )
 232              		.loc 1 509 0
 233 005e FB6A     		ldr	r3, [r7, #44]
 234 0060 002B     		cmp	r3, #0
 235 0062 02D0     		beq	.L3
 510:FreeRTOS/Source/tasks.c **** 		{
 511:FreeRTOS/Source/tasks.c **** 			/* Pass the TCB out - in an anonymous way.  The calling function/
 512:FreeRTOS/Source/tasks.c **** 			task can use this as a handle to delete the task later if
 513:FreeRTOS/Source/tasks.c **** 			required.*/
 514:FreeRTOS/Source/tasks.c **** 			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
 236              		.loc 1 514 0
 237 0064 FB6A     		ldr	r3, [r7, #44]
 238 0066 BA69     		ldr	r2, [r7, #24]
 239 0068 1A60     		str	r2, [r3, #0]
 240              	.L3:
 515:FreeRTOS/Source/tasks.c **** 		}
 516:FreeRTOS/Source/tasks.c **** 		
 517:FreeRTOS/Source/tasks.c **** 		/* We are going to manipulate the task queues to add this task to a
 518:FreeRTOS/Source/tasks.c **** 		ready list, so must make sure no interrupts occur. */
 519:FreeRTOS/Source/tasks.c **** 		taskENTER_CRITICAL();
 241              		.loc 1 519 0
 242 006a FFF7FEFF 		bl	vPortEnterCritical
 520:FreeRTOS/Source/tasks.c **** 		{
 521:FreeRTOS/Source/tasks.c **** 			uxCurrentNumberOfTasks++;
 243              		.loc 1 521 0
 244 006e 40F20003 		movw	r3, #:lower16:uxCurrentNumberOfTasks
 245 0072 C0F20003 		movt	r3, #:upper16:uxCurrentNumberOfTasks
 246 0076 1B68     		ldr	r3, [r3, #0]
 247 0078 03F10102 		add	r2, r3, #1
 248 007c 40F20003 		movw	r3, #:lower16:uxCurrentNumberOfTasks
 249 0080 C0F20003 		movt	r3, #:upper16:uxCurrentNumberOfTasks
 250 0084 1A60     		str	r2, [r3, #0]
 522:FreeRTOS/Source/tasks.c **** 			if( pxCurrentTCB == NULL )
 251              		.loc 1 522 0
 252 0086 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 253 008a C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 254 008e 1B68     		ldr	r3, [r3, #0]
 255 0090 002B     		cmp	r3, #0
 256 0092 0FD1     		bne	.L4
 523:FreeRTOS/Source/tasks.c **** 			{
 524:FreeRTOS/Source/tasks.c **** 				/* There are no other tasks, or all the other tasks are in
 525:FreeRTOS/Source/tasks.c **** 				the suspended state - make this the current task. */
 526:FreeRTOS/Source/tasks.c **** 				pxCurrentTCB =  pxNewTCB;
 257              		.loc 1 526 0
 258 0094 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 259 0098 C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 260 009c BA69     		ldr	r2, [r7, #24]
 261 009e 1A60     		str	r2, [r3, #0]
 527:FreeRTOS/Source/tasks.c **** 
 528:FreeRTOS/Source/tasks.c **** 				if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
 262              		.loc 1 528 0
 263 00a0 40F20003 		movw	r3, #:lower16:uxCurrentNumberOfTasks
 264 00a4 C0F20003 		movt	r3, #:upper16:uxCurrentNumberOfTasks
 265 00a8 1B68     		ldr	r3, [r3, #0]
 266 00aa 012B     		cmp	r3, #1
 267 00ac 18D1     		bne	.L5
 529:FreeRTOS/Source/tasks.c **** 				{
 530:FreeRTOS/Source/tasks.c **** 					/* This is the first task to be created so do the preliminary
 531:FreeRTOS/Source/tasks.c **** 					initialisation required.  We will not recover if this call
 532:FreeRTOS/Source/tasks.c **** 					fails, but we will report the failure. */
 533:FreeRTOS/Source/tasks.c **** 					prvInitialiseTaskLists();
 268              		.loc 1 533 0
 269 00ae FFF7FEFF 		bl	prvInitialiseTaskLists
 270 00b2 15E0     		b	.L5
 271              	.L4:
 534:FreeRTOS/Source/tasks.c **** 				}
 535:FreeRTOS/Source/tasks.c **** 			}
 536:FreeRTOS/Source/tasks.c **** 			else
 537:FreeRTOS/Source/tasks.c **** 			{
 538:FreeRTOS/Source/tasks.c **** 				/* If the scheduler is not already running, make this task the
 539:FreeRTOS/Source/tasks.c **** 				current task if it is the highest priority task to be created
 540:FreeRTOS/Source/tasks.c **** 				so far. */
 541:FreeRTOS/Source/tasks.c **** 				if( xSchedulerRunning == pdFALSE )
 272              		.loc 1 541 0
 273 00b4 40F20003 		movw	r3, #:lower16:xSchedulerRunning
 274 00b8 C0F20003 		movt	r3, #:upper16:xSchedulerRunning
 275 00bc 1B68     		ldr	r3, [r3, #0]
 276 00be 002B     		cmp	r3, #0
 277 00c0 0ED1     		bne	.L5
 542:FreeRTOS/Source/tasks.c **** 				{
 543:FreeRTOS/Source/tasks.c **** 					if( pxCurrentTCB->uxPriority <= uxPriority )
 278              		.loc 1 543 0
 279 00c2 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 280 00c6 C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 281 00ca 1B68     		ldr	r3, [r3, #0]
 282 00cc DA6A     		ldr	r2, [r3, #44]
 283 00ce BB6A     		ldr	r3, [r7, #40]
 284 00d0 9A42     		cmp	r2, r3
 285 00d2 05D8     		bhi	.L5
 544:FreeRTOS/Source/tasks.c **** 					{
 545:FreeRTOS/Source/tasks.c **** 						pxCurrentTCB = pxNewTCB;
 286              		.loc 1 545 0
 287 00d4 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 288 00d8 C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 289 00dc BA69     		ldr	r2, [r7, #24]
 290 00de 1A60     		str	r2, [r3, #0]
 291              	.L5:
 546:FreeRTOS/Source/tasks.c **** 					}
 547:FreeRTOS/Source/tasks.c **** 				}
 548:FreeRTOS/Source/tasks.c **** 			}
 549:FreeRTOS/Source/tasks.c **** 
 550:FreeRTOS/Source/tasks.c **** 			/* Remember the top priority to make context switching faster.  Use
 551:FreeRTOS/Source/tasks.c **** 			the priority in pxNewTCB as this has been capped to a valid value. */
 552:FreeRTOS/Source/tasks.c **** 			if( pxNewTCB->uxPriority > uxTopUsedPriority )
 292              		.loc 1 552 0
 293 00e0 BB69     		ldr	r3, [r7, #24]
 294 00e2 DA6A     		ldr	r2, [r3, #44]
 295 00e4 40F20003 		movw	r3, #:lower16:uxTopUsedPriority
 296 00e8 C0F20003 		movt	r3, #:upper16:uxTopUsedPriority
 297 00ec 1B68     		ldr	r3, [r3, #0]
 298 00ee 9A42     		cmp	r2, r3
 299 00f0 06D9     		bls	.L6
 553:FreeRTOS/Source/tasks.c **** 			{
 554:FreeRTOS/Source/tasks.c **** 				uxTopUsedPriority = pxNewTCB->uxPriority;
 300              		.loc 1 554 0
 301 00f2 BB69     		ldr	r3, [r7, #24]
 302 00f4 DA6A     		ldr	r2, [r3, #44]
 303 00f6 40F20003 		movw	r3, #:lower16:uxTopUsedPriority
 304 00fa C0F20003 		movt	r3, #:upper16:uxTopUsedPriority
 305 00fe 1A60     		str	r2, [r3, #0]
 306              	.L6:
 555:FreeRTOS/Source/tasks.c **** 			}
 556:FreeRTOS/Source/tasks.c **** 
 557:FreeRTOS/Source/tasks.c **** 			#if ( configUSE_TRACE_FACILITY == 1 )
 558:FreeRTOS/Source/tasks.c **** 			{
 559:FreeRTOS/Source/tasks.c **** 				/* Add a counter into the TCB for tracing only. */
 560:FreeRTOS/Source/tasks.c **** 				pxNewTCB->uxTCBNumber = uxTaskNumber;
 561:FreeRTOS/Source/tasks.c **** 			}
 562:FreeRTOS/Source/tasks.c **** 			#endif
 563:FreeRTOS/Source/tasks.c **** 			uxTaskNumber++;
 307              		.loc 1 563 0
 308 0100 40F20003 		movw	r3, #:lower16:uxTaskNumber
 309 0104 C0F20003 		movt	r3, #:upper16:uxTaskNumber
 310 0108 1B68     		ldr	r3, [r3, #0]
 311 010a 03F10102 		add	r2, r3, #1
 312 010e 40F20003 		movw	r3, #:lower16:uxTaskNumber
 313 0112 C0F20003 		movt	r3, #:upper16:uxTaskNumber
 314 0116 1A60     		str	r2, [r3, #0]
 564:FreeRTOS/Source/tasks.c **** 
 565:FreeRTOS/Source/tasks.c **** 			prvAddTaskToReadyQueue( pxNewTCB );
 315              		.loc 1 565 0
 316 0118 BB69     		ldr	r3, [r7, #24]
 317 011a DA6A     		ldr	r2, [r3, #44]
 318 011c 40F20003 		movw	r3, #:lower16:uxTopReadyPriority
 319 0120 C0F20003 		movt	r3, #:upper16:uxTopReadyPriority
 320 0124 1B68     		ldr	r3, [r3, #0]
 321 0126 9A42     		cmp	r2, r3
 322 0128 06D9     		bls	.L7
 323              		.loc 1 565 0 is_stmt 0 discriminator 1
 324 012a BB69     		ldr	r3, [r7, #24]
 325 012c DA6A     		ldr	r2, [r3, #44]
 326 012e 40F20003 		movw	r3, #:lower16:uxTopReadyPriority
 327 0132 C0F20003 		movt	r3, #:upper16:uxTopReadyPriority
 328 0136 1A60     		str	r2, [r3, #0]
 329              	.L7:
 330              		.loc 1 565 0 discriminator 2
 331 0138 BB69     		ldr	r3, [r7, #24]
 332 013a DA6A     		ldr	r2, [r3, #44]
 333 013c 1346     		mov	r3, r2
 334 013e 4FEA8303 		lsl	r3, r3, #2
 335 0142 9B18     		adds	r3, r3, r2
 336 0144 4FEA8303 		lsl	r3, r3, #2
 337 0148 1A46     		mov	r2, r3
 338 014a 40F20003 		movw	r3, #:lower16:pxReadyTasksLists
 339 014e C0F20003 		movt	r3, #:upper16:pxReadyTasksLists
 340 0152 D218     		adds	r2, r2, r3
 341 0154 BB69     		ldr	r3, [r7, #24]
 342 0156 03F10403 		add	r3, r3, #4
 343 015a 1046     		mov	r0, r2
 344 015c 1946     		mov	r1, r3
 345 015e FFF7FEFF 		bl	vListInsertEnd
 566:FreeRTOS/Source/tasks.c **** 
 567:FreeRTOS/Source/tasks.c **** 			xReturn = pdPASS;
 346              		.loc 1 567 0 is_stmt 1 discriminator 2
 347 0162 4FF00103 		mov	r3, #1
 348 0166 FB61     		str	r3, [r7, #28]
 568:FreeRTOS/Source/tasks.c **** 			traceTASK_CREATE( pxNewTCB );
 569:FreeRTOS/Source/tasks.c **** 		}
 570:FreeRTOS/Source/tasks.c **** 		taskEXIT_CRITICAL();
 349              		.loc 1 570 0 discriminator 2
 350 0168 FFF7FEFF 		bl	vPortExitCritical
 351 016c 02E0     		b	.L8
 352              	.L2:
 353              	.LBE2:
 571:FreeRTOS/Source/tasks.c **** 	}
 572:FreeRTOS/Source/tasks.c **** 	else
 573:FreeRTOS/Source/tasks.c **** 	{
 574:FreeRTOS/Source/tasks.c **** 		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
 354              		.loc 1 574 0
 355 016e 4FF0FF33 		mov	r3, #-1
 356 0172 FB61     		str	r3, [r7, #28]
 357              	.L8:
 575:FreeRTOS/Source/tasks.c **** 		traceTASK_CREATE_FAILED();
 576:FreeRTOS/Source/tasks.c **** 	}
 577:FreeRTOS/Source/tasks.c **** 
 578:FreeRTOS/Source/tasks.c **** 	if( xReturn == pdPASS )
 358              		.loc 1 578 0
 359 0174 FB69     		ldr	r3, [r7, #28]
 360 0176 012B     		cmp	r3, #1
 361 0178 11D1     		bne	.L9
 579:FreeRTOS/Source/tasks.c **** 	{
 580:FreeRTOS/Source/tasks.c **** 		if( xSchedulerRunning != pdFALSE )
 362              		.loc 1 580 0
 363 017a 40F20003 		movw	r3, #:lower16:xSchedulerRunning
 364 017e C0F20003 		movt	r3, #:upper16:xSchedulerRunning
 365 0182 1B68     		ldr	r3, [r3, #0]
 366 0184 002B     		cmp	r3, #0
 367 0186 0AD0     		beq	.L9
 581:FreeRTOS/Source/tasks.c **** 		{
 582:FreeRTOS/Source/tasks.c **** 			/* If the created task is of a higher priority than the current task
 583:FreeRTOS/Source/tasks.c **** 			then it should run now. */
 584:FreeRTOS/Source/tasks.c **** 			if( pxCurrentTCB->uxPriority < uxPriority )
 368              		.loc 1 584 0
 369 0188 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 370 018c C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 371 0190 1B68     		ldr	r3, [r3, #0]
 372 0192 DA6A     		ldr	r2, [r3, #44]
 373 0194 BB6A     		ldr	r3, [r7, #40]
 374 0196 9A42     		cmp	r2, r3
 375 0198 01D2     		bcs	.L9
 585:FreeRTOS/Source/tasks.c **** 			{
 586:FreeRTOS/Source/tasks.c **** 				portYIELD_WITHIN_API();
 376              		.loc 1 586 0
 377 019a FFF7FEFF 		bl	vPortYieldFromISR
 378              	.L9:
 587:FreeRTOS/Source/tasks.c **** 			}
 588:FreeRTOS/Source/tasks.c **** 		}
 589:FreeRTOS/Source/tasks.c **** 	}
 590:FreeRTOS/Source/tasks.c **** 
 591:FreeRTOS/Source/tasks.c **** 	return xReturn;
 379              		.loc 1 591 0
 380 019e FB69     		ldr	r3, [r7, #28]
 592:FreeRTOS/Source/tasks.c **** }
 381              		.loc 1 592 0
 382 01a0 1846     		mov	r0, r3
 383 01a2 07F12007 		add	r7, r7, #32
 384 01a6 BD46     		mov	sp, r7
 385 01a8 80BD     		pop	{r7, pc}
 386              		.cfi_endproc
 387              	.LFE110:
 389 01aa 00BF     		.section	.text.vTaskDelete,"ax",%progbits
 390              		.align	2
 391              		.global	vTaskDelete
 392              		.thumb
 393              		.thumb_func
 395              	vTaskDelete:
 396              	.LFB111:
 593:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 594:FreeRTOS/Source/tasks.c **** 
 595:FreeRTOS/Source/tasks.c **** #if ( INCLUDE_vTaskDelete == 1 )
 596:FreeRTOS/Source/tasks.c **** 
 597:FreeRTOS/Source/tasks.c **** 	void vTaskDelete( xTaskHandle pxTaskToDelete )
 598:FreeRTOS/Source/tasks.c **** 	{
 397              		.loc 1 598 0
 398              		.cfi_startproc
 399              		@ args = 0, pretend = 0, frame = 16
 400              		@ frame_needed = 1, uses_anonymous_args = 0
 401 0000 80B5     		push	{r7, lr}
 402              	.LCFI3:
 403              		.cfi_def_cfa_offset 8
 404              		.cfi_offset 14, -4
 405              		.cfi_offset 7, -8
 406 0002 84B0     		sub	sp, sp, #16
 407              	.LCFI4:
 408              		.cfi_def_cfa_offset 24
 409 0004 00AF     		add	r7, sp, #0
 410              	.LCFI5:
 411              		.cfi_def_cfa_register 7
 412 0006 7860     		str	r0, [r7, #4]
 599:FreeRTOS/Source/tasks.c **** 	tskTCB *pxTCB;
 600:FreeRTOS/Source/tasks.c **** 
 601:FreeRTOS/Source/tasks.c **** 		taskENTER_CRITICAL();
 413              		.loc 1 601 0
 414 0008 FFF7FEFF 		bl	vPortEnterCritical
 602:FreeRTOS/Source/tasks.c **** 		{
 603:FreeRTOS/Source/tasks.c **** 			/* Ensure a yield is performed if the current task is being
 604:FreeRTOS/Source/tasks.c **** 			deleted. */
 605:FreeRTOS/Source/tasks.c **** 			if( pxTaskToDelete == pxCurrentTCB )
 415              		.loc 1 605 0
 416 000c 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 417 0010 C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 418 0014 1B68     		ldr	r3, [r3, #0]
 419 0016 7A68     		ldr	r2, [r7, #4]
 420 0018 9A42     		cmp	r2, r3
 421 001a 02D1     		bne	.L11
 606:FreeRTOS/Source/tasks.c **** 			{
 607:FreeRTOS/Source/tasks.c **** 				pxTaskToDelete = NULL;
 422              		.loc 1 607 0
 423 001c 4FF00003 		mov	r3, #0
 424 0020 7B60     		str	r3, [r7, #4]
 425              	.L11:
 608:FreeRTOS/Source/tasks.c **** 			}
 609:FreeRTOS/Source/tasks.c **** 
 610:FreeRTOS/Source/tasks.c **** 			/* If null is passed in here then we are deleting ourselves. */
 611:FreeRTOS/Source/tasks.c **** 			pxTCB = prvGetTCBFromHandle( pxTaskToDelete );
 426              		.loc 1 611 0
 427 0022 7B68     		ldr	r3, [r7, #4]
 428 0024 002B     		cmp	r3, #0
 429 0026 05D1     		bne	.L12
 430              		.loc 1 611 0 is_stmt 0 discriminator 1
 431 0028 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 432 002c C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 433 0030 1B68     		ldr	r3, [r3, #0]
 434 0032 00E0     		b	.L13
 435              	.L12:
 436              		.loc 1 611 0 discriminator 2
 437 0034 7B68     		ldr	r3, [r7, #4]
 438              	.L13:
 439              		.loc 1 611 0 discriminator 3
 440 0036 FB60     		str	r3, [r7, #12]
 612:FreeRTOS/Source/tasks.c **** 
 613:FreeRTOS/Source/tasks.c **** 			/* Remove task from the ready list and place in the	termination list.
 614:FreeRTOS/Source/tasks.c **** 			This will stop the task from be scheduled.  The idle task will check
 615:FreeRTOS/Source/tasks.c **** 			the termination list and free up any memory allocated by the
 616:FreeRTOS/Source/tasks.c **** 			scheduler for the TCB and stack. */
 617:FreeRTOS/Source/tasks.c **** 			vListRemove( &( pxTCB->xGenericListItem ) );
 441              		.loc 1 617 0 is_stmt 1 discriminator 3
 442 0038 FB68     		ldr	r3, [r7, #12]
 443 003a 03F10403 		add	r3, r3, #4
 444 003e 1846     		mov	r0, r3
 445 0040 FFF7FEFF 		bl	vListRemove
 618:FreeRTOS/Source/tasks.c **** 
 619:FreeRTOS/Source/tasks.c **** 			/* Is the task waiting on an event also? */
 620:FreeRTOS/Source/tasks.c **** 			if( pxTCB->xEventListItem.pvContainer != NULL )
 446              		.loc 1 620 0 discriminator 3
 447 0044 FB68     		ldr	r3, [r7, #12]
 448 0046 9B6A     		ldr	r3, [r3, #40]
 449 0048 002B     		cmp	r3, #0
 450 004a 05D0     		beq	.L14
 621:FreeRTOS/Source/tasks.c **** 			{
 622:FreeRTOS/Source/tasks.c **** 				vListRemove( &( pxTCB->xEventListItem ) );
 451              		.loc 1 622 0
 452 004c FB68     		ldr	r3, [r7, #12]
 453 004e 03F11803 		add	r3, r3, #24
 454 0052 1846     		mov	r0, r3
 455 0054 FFF7FEFF 		bl	vListRemove
 456              	.L14:
 623:FreeRTOS/Source/tasks.c **** 			}
 624:FreeRTOS/Source/tasks.c **** 
 625:FreeRTOS/Source/tasks.c **** 			vListInsertEnd( ( xList * ) &xTasksWaitingTermination, &( pxTCB->xGenericListItem ) );
 457              		.loc 1 625 0
 458 0058 FB68     		ldr	r3, [r7, #12]
 459 005a 03F10403 		add	r3, r3, #4
 460 005e 40F20000 		movw	r0, #:lower16:xTasksWaitingTermination
 461 0062 C0F20000 		movt	r0, #:upper16:xTasksWaitingTermination
 462 0066 1946     		mov	r1, r3
 463 0068 FFF7FEFF 		bl	vListInsertEnd
 626:FreeRTOS/Source/tasks.c **** 
 627:FreeRTOS/Source/tasks.c **** 			/* Increment the ucTasksDeleted variable so the idle task knows
 628:FreeRTOS/Source/tasks.c **** 			there is a task that has been deleted and that it should therefore
 629:FreeRTOS/Source/tasks.c **** 			check the xTasksWaitingTermination list. */
 630:FreeRTOS/Source/tasks.c **** 			++uxTasksDeleted;
 464              		.loc 1 630 0
 465 006c 40F20003 		movw	r3, #:lower16:uxTasksDeleted
 466 0070 C0F20003 		movt	r3, #:upper16:uxTasksDeleted
 467 0074 1B68     		ldr	r3, [r3, #0]
 468 0076 03F10102 		add	r2, r3, #1
 469 007a 40F20003 		movw	r3, #:lower16:uxTasksDeleted
 470 007e C0F20003 		movt	r3, #:upper16:uxTasksDeleted
 471 0082 1A60     		str	r2, [r3, #0]
 631:FreeRTOS/Source/tasks.c **** 
 632:FreeRTOS/Source/tasks.c **** 			/* Increment the uxTaskNumberVariable also so kernel aware debuggers
 633:FreeRTOS/Source/tasks.c **** 			can detect that the task lists need re-generating. */
 634:FreeRTOS/Source/tasks.c **** 			uxTaskNumber++;
 472              		.loc 1 634 0
 473 0084 40F20003 		movw	r3, #:lower16:uxTaskNumber
 474 0088 C0F20003 		movt	r3, #:upper16:uxTaskNumber
 475 008c 1B68     		ldr	r3, [r3, #0]
 476 008e 03F10102 		add	r2, r3, #1
 477 0092 40F20003 		movw	r3, #:lower16:uxTaskNumber
 478 0096 C0F20003 		movt	r3, #:upper16:uxTaskNumber
 479 009a 1A60     		str	r2, [r3, #0]
 635:FreeRTOS/Source/tasks.c **** 
 636:FreeRTOS/Source/tasks.c **** 			traceTASK_DELETE( pxTCB );
 637:FreeRTOS/Source/tasks.c **** 		}
 638:FreeRTOS/Source/tasks.c **** 		taskEXIT_CRITICAL();
 480              		.loc 1 638 0
 481 009c FFF7FEFF 		bl	vPortExitCritical
 639:FreeRTOS/Source/tasks.c **** 
 640:FreeRTOS/Source/tasks.c **** 		/* Force a reschedule if we have just deleted the current task. */
 641:FreeRTOS/Source/tasks.c **** 		if( xSchedulerRunning != pdFALSE )
 482              		.loc 1 641 0
 483 00a0 40F20003 		movw	r3, #:lower16:xSchedulerRunning
 484 00a4 C0F20003 		movt	r3, #:upper16:xSchedulerRunning
 485 00a8 1B68     		ldr	r3, [r3, #0]
 486 00aa 002B     		cmp	r3, #0
 487 00ac 04D0     		beq	.L10
 642:FreeRTOS/Source/tasks.c **** 		{
 643:FreeRTOS/Source/tasks.c **** 			if( ( void * ) pxTaskToDelete == NULL )
 488              		.loc 1 643 0
 489 00ae 7B68     		ldr	r3, [r7, #4]
 490 00b0 002B     		cmp	r3, #0
 491 00b2 01D1     		bne	.L10
 644:FreeRTOS/Source/tasks.c **** 			{
 645:FreeRTOS/Source/tasks.c **** 				portYIELD_WITHIN_API();
 492              		.loc 1 645 0
 493 00b4 FFF7FEFF 		bl	vPortYieldFromISR
 494              	.L10:
 646:FreeRTOS/Source/tasks.c **** 			}
 647:FreeRTOS/Source/tasks.c **** 		}
 648:FreeRTOS/Source/tasks.c **** 	}
 495              		.loc 1 648 0
 496 00b8 07F11007 		add	r7, r7, #16
 497 00bc BD46     		mov	sp, r7
 498 00be 80BD     		pop	{r7, pc}
 499              		.cfi_endproc
 500              	.LFE111:
 502              		.section	.text.vTaskDelayUntil,"ax",%progbits
 503              		.align	2
 504              		.global	vTaskDelayUntil
 505              		.thumb
 506              		.thumb_func
 508              	vTaskDelayUntil:
 509              	.LFB112:
 649:FreeRTOS/Source/tasks.c **** 
 650:FreeRTOS/Source/tasks.c **** #endif
 651:FreeRTOS/Source/tasks.c **** 
 652:FreeRTOS/Source/tasks.c **** 
 653:FreeRTOS/Source/tasks.c **** 
 654:FreeRTOS/Source/tasks.c **** 
 655:FreeRTOS/Source/tasks.c **** 
 656:FreeRTOS/Source/tasks.c **** 
 657:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------
 658:FreeRTOS/Source/tasks.c ****  * TASK CONTROL API documented in task.h
 659:FreeRTOS/Source/tasks.c ****  *----------------------------------------------------------*/
 660:FreeRTOS/Source/tasks.c **** 
 661:FreeRTOS/Source/tasks.c **** #if ( INCLUDE_vTaskDelayUntil == 1 )
 662:FreeRTOS/Source/tasks.c **** 
 663:FreeRTOS/Source/tasks.c **** 	void vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement )
 664:FreeRTOS/Source/tasks.c **** 	{
 510              		.loc 1 664 0
 511              		.cfi_startproc
 512              		@ args = 0, pretend = 0, frame = 24
 513              		@ frame_needed = 1, uses_anonymous_args = 0
 514 0000 80B5     		push	{r7, lr}
 515              	.LCFI6:
 516              		.cfi_def_cfa_offset 8
 517              		.cfi_offset 14, -4
 518              		.cfi_offset 7, -8
 519 0002 86B0     		sub	sp, sp, #24
 520              	.LCFI7:
 521              		.cfi_def_cfa_offset 32
 522 0004 00AF     		add	r7, sp, #0
 523              	.LCFI8:
 524              		.cfi_def_cfa_register 7
 525 0006 7860     		str	r0, [r7, #4]
 526 0008 3960     		str	r1, [r7, #0]
 665:FreeRTOS/Source/tasks.c **** 	portTickType xTimeToWake;
 666:FreeRTOS/Source/tasks.c **** 	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;
 527              		.loc 1 666 0
 528 000a 4FF00003 		mov	r3, #0
 529 000e 7B61     		str	r3, [r7, #20]
 667:FreeRTOS/Source/tasks.c **** 
 668:FreeRTOS/Source/tasks.c **** 		configASSERT( pxPreviousWakeTime );
 669:FreeRTOS/Source/tasks.c **** 		configASSERT( ( xTimeIncrement > 0U ) );
 670:FreeRTOS/Source/tasks.c **** 
 671:FreeRTOS/Source/tasks.c **** 		vTaskSuspendAll();
 530              		.loc 1 671 0
 531 0010 FFF7FEFF 		bl	vTaskSuspendAll
 672:FreeRTOS/Source/tasks.c **** 		{
 673:FreeRTOS/Source/tasks.c **** 			/* Generate the tick time at which the task wants to wake. */
 674:FreeRTOS/Source/tasks.c **** 			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
 532              		.loc 1 674 0
 533 0014 7B68     		ldr	r3, [r7, #4]
 534 0016 1A68     		ldr	r2, [r3, #0]
 535 0018 3B68     		ldr	r3, [r7, #0]
 536 001a D318     		adds	r3, r2, r3
 537 001c 3B61     		str	r3, [r7, #16]
 675:FreeRTOS/Source/tasks.c **** 
 676:FreeRTOS/Source/tasks.c **** 			if( xTickCount < *pxPreviousWakeTime )
 538              		.loc 1 676 0
 539 001e 7B68     		ldr	r3, [r7, #4]
 540 0020 1A68     		ldr	r2, [r3, #0]
 541 0022 40F20003 		movw	r3, #:lower16:xTickCount
 542 0026 C0F20003 		movt	r3, #:upper16:xTickCount
 543 002a 1B68     		ldr	r3, [r3, #0]
 544 002c 9A42     		cmp	r2, r3
 545 002e 10D9     		bls	.L17
 677:FreeRTOS/Source/tasks.c **** 			{
 678:FreeRTOS/Source/tasks.c **** 				/* The tick count has overflowed since this function was
 679:FreeRTOS/Source/tasks.c **** 				lasted called.  In this case the only time we should ever
 680:FreeRTOS/Source/tasks.c **** 				actually delay is if the wake time has also	overflowed,
 681:FreeRTOS/Source/tasks.c **** 				and the wake time is greater than the tick time.  When this
 682:FreeRTOS/Source/tasks.c **** 				is the case it is as if neither time had overflowed. */
 683:FreeRTOS/Source/tasks.c **** 				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xTickCount ) )
 546              		.loc 1 683 0
 547 0030 7B68     		ldr	r3, [r7, #4]
 548 0032 1A68     		ldr	r2, [r3, #0]
 549 0034 3B69     		ldr	r3, [r7, #16]
 550 0036 9A42     		cmp	r2, r3
 551 0038 1BD9     		bls	.L18
 552              		.loc 1 683 0 is_stmt 0 discriminator 1
 553 003a 40F20003 		movw	r3, #:lower16:xTickCount
 554 003e C0F20003 		movt	r3, #:upper16:xTickCount
 555 0042 1B68     		ldr	r3, [r3, #0]
 556 0044 3A69     		ldr	r2, [r7, #16]
 557 0046 9A42     		cmp	r2, r3
 558 0048 13D9     		bls	.L18
 684:FreeRTOS/Source/tasks.c **** 				{
 685:FreeRTOS/Source/tasks.c **** 					xShouldDelay = pdTRUE;
 559              		.loc 1 685 0 is_stmt 1
 560 004a 4FF00103 		mov	r3, #1
 561 004e 7B61     		str	r3, [r7, #20]
 562 0050 0FE0     		b	.L18
 563              	.L17:
 686:FreeRTOS/Source/tasks.c **** 				}
 687:FreeRTOS/Source/tasks.c **** 			}
 688:FreeRTOS/Source/tasks.c **** 			else
 689:FreeRTOS/Source/tasks.c **** 			{
 690:FreeRTOS/Source/tasks.c **** 				/* The tick time has not overflowed.  In this case we will
 691:FreeRTOS/Source/tasks.c **** 				delay if either the wake time has overflowed, and/or the
 692:FreeRTOS/Source/tasks.c **** 				tick time is less than the wake time. */
 693:FreeRTOS/Source/tasks.c **** 				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
 564              		.loc 1 693 0
 565 0052 7B68     		ldr	r3, [r7, #4]
 566 0054 1A68     		ldr	r2, [r3, #0]
 567 0056 3B69     		ldr	r3, [r7, #16]
 568 0058 9A42     		cmp	r2, r3
 569 005a 07D8     		bhi	.L19
 570              		.loc 1 693 0 is_stmt 0 discriminator 1
 571 005c 40F20003 		movw	r3, #:lower16:xTickCount
 572 0060 C0F20003 		movt	r3, #:upper16:xTickCount
 573 0064 1B68     		ldr	r3, [r3, #0]
 574 0066 3A69     		ldr	r2, [r7, #16]
 575 0068 9A42     		cmp	r2, r3
 576 006a 02D9     		bls	.L18
 577              	.L19:
 694:FreeRTOS/Source/tasks.c **** 				{
 695:FreeRTOS/Source/tasks.c **** 					xShouldDelay = pdTRUE;
 578              		.loc 1 695 0 is_stmt 1
 579 006c 4FF00103 		mov	r3, #1
 580 0070 7B61     		str	r3, [r7, #20]
 581              	.L18:
 696:FreeRTOS/Source/tasks.c **** 				}
 697:FreeRTOS/Source/tasks.c **** 			}
 698:FreeRTOS/Source/tasks.c **** 
 699:FreeRTOS/Source/tasks.c **** 			/* Update the wake time ready for the next call. */
 700:FreeRTOS/Source/tasks.c **** 			*pxPreviousWakeTime = xTimeToWake;
 582              		.loc 1 700 0
 583 0072 7B68     		ldr	r3, [r7, #4]
 584 0074 3A69     		ldr	r2, [r7, #16]
 585 0076 1A60     		str	r2, [r3, #0]
 701:FreeRTOS/Source/tasks.c **** 
 702:FreeRTOS/Source/tasks.c **** 			if( xShouldDelay != pdFALSE )
 586              		.loc 1 702 0
 587 0078 7B69     		ldr	r3, [r7, #20]
 588 007a 002B     		cmp	r3, #0
 589 007c 0CD0     		beq	.L20
 703:FreeRTOS/Source/tasks.c **** 			{
 704:FreeRTOS/Source/tasks.c **** 				traceTASK_DELAY_UNTIL();
 705:FreeRTOS/Source/tasks.c **** 
 706:FreeRTOS/Source/tasks.c **** 				/* We must remove ourselves from the ready list before adding
 707:FreeRTOS/Source/tasks.c **** 				ourselves to the blocked list as the same list item is used for
 708:FreeRTOS/Source/tasks.c **** 				both lists. */
 709:FreeRTOS/Source/tasks.c **** 				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
 590              		.loc 1 709 0
 591 007e 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 592 0082 C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 593 0086 1B68     		ldr	r3, [r3, #0]
 594 0088 03F10403 		add	r3, r3, #4
 595 008c 1846     		mov	r0, r3
 596 008e FFF7FEFF 		bl	vListRemove
 710:FreeRTOS/Source/tasks.c **** 				prvAddCurrentTaskToDelayedList( xTimeToWake );
 597              		.loc 1 710 0
 598 0092 3869     		ldr	r0, [r7, #16]
 599 0094 FFF7FEFF 		bl	prvAddCurrentTaskToDelayedList
 600              	.L20:
 711:FreeRTOS/Source/tasks.c **** 			}
 712:FreeRTOS/Source/tasks.c **** 		}
 713:FreeRTOS/Source/tasks.c **** 		xAlreadyYielded = xTaskResumeAll();
 601              		.loc 1 713 0
 602 0098 FFF7FEFF 		bl	xTaskResumeAll
 603 009c F860     		str	r0, [r7, #12]
 714:FreeRTOS/Source/tasks.c **** 
 715:FreeRTOS/Source/tasks.c **** 		/* Force a reschedule if xTaskResumeAll has not already done so, we may
 716:FreeRTOS/Source/tasks.c **** 		have put ourselves to sleep. */
 717:FreeRTOS/Source/tasks.c **** 		if( xAlreadyYielded == pdFALSE )
 604              		.loc 1 717 0
 605 009e FB68     		ldr	r3, [r7, #12]
 606 00a0 002B     		cmp	r3, #0
 607 00a2 01D1     		bne	.L16
 718:FreeRTOS/Source/tasks.c **** 		{
 719:FreeRTOS/Source/tasks.c **** 			portYIELD_WITHIN_API();
 608              		.loc 1 719 0
 609 00a4 FFF7FEFF 		bl	vPortYieldFromISR
 610              	.L16:
 720:FreeRTOS/Source/tasks.c **** 		}
 721:FreeRTOS/Source/tasks.c **** 	}
 611              		.loc 1 721 0
 612 00a8 07F11807 		add	r7, r7, #24
 613 00ac BD46     		mov	sp, r7
 614 00ae 80BD     		pop	{r7, pc}
 615              		.cfi_endproc
 616              	.LFE112:
 618              		.section	.text.vTaskDelay,"ax",%progbits
 619              		.align	2
 620              		.global	vTaskDelay
 621              		.thumb
 622              		.thumb_func
 624              	vTaskDelay:
 625              	.LFB113:
 722:FreeRTOS/Source/tasks.c **** 
 723:FreeRTOS/Source/tasks.c **** #endif
 724:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 725:FreeRTOS/Source/tasks.c **** 
 726:FreeRTOS/Source/tasks.c **** #if ( INCLUDE_vTaskDelay == 1 )
 727:FreeRTOS/Source/tasks.c **** 
 728:FreeRTOS/Source/tasks.c **** 	void vTaskDelay( portTickType xTicksToDelay )
 729:FreeRTOS/Source/tasks.c **** 	{
 626              		.loc 1 729 0
 627              		.cfi_startproc
 628              		@ args = 0, pretend = 0, frame = 16
 629              		@ frame_needed = 1, uses_anonymous_args = 0
 630 0000 80B5     		push	{r7, lr}
 631              	.LCFI9:
 632              		.cfi_def_cfa_offset 8
 633              		.cfi_offset 14, -4
 634              		.cfi_offset 7, -8
 635 0002 84B0     		sub	sp, sp, #16
 636              	.LCFI10:
 637              		.cfi_def_cfa_offset 24
 638 0004 00AF     		add	r7, sp, #0
 639              	.LCFI11:
 640              		.cfi_def_cfa_register 7
 641 0006 7860     		str	r0, [r7, #4]
 730:FreeRTOS/Source/tasks.c **** 	portTickType xTimeToWake;
 731:FreeRTOS/Source/tasks.c **** 	signed portBASE_TYPE xAlreadyYielded = pdFALSE;
 642              		.loc 1 731 0
 643 0008 4FF00003 		mov	r3, #0
 644 000c FB60     		str	r3, [r7, #12]
 732:FreeRTOS/Source/tasks.c **** 
 733:FreeRTOS/Source/tasks.c **** 		/* A delay time of zero just forces a reschedule. */
 734:FreeRTOS/Source/tasks.c **** 		if( xTicksToDelay > ( portTickType ) 0U )
 645              		.loc 1 734 0
 646 000e 7B68     		ldr	r3, [r7, #4]
 647 0010 002B     		cmp	r3, #0
 648 0012 19D0     		beq	.L23
 735:FreeRTOS/Source/tasks.c **** 		{
 736:FreeRTOS/Source/tasks.c **** 			vTaskSuspendAll();
 649              		.loc 1 736 0
 650 0014 FFF7FEFF 		bl	vTaskSuspendAll
 737:FreeRTOS/Source/tasks.c **** 			{
 738:FreeRTOS/Source/tasks.c **** 				traceTASK_DELAY();
 739:FreeRTOS/Source/tasks.c **** 
 740:FreeRTOS/Source/tasks.c **** 				/* A task that is removed from the event list while the
 741:FreeRTOS/Source/tasks.c **** 				scheduler is suspended will not get placed in the ready
 742:FreeRTOS/Source/tasks.c **** 				list or removed from the blocked list until the scheduler
 743:FreeRTOS/Source/tasks.c **** 				is resumed.
 744:FreeRTOS/Source/tasks.c **** 
 745:FreeRTOS/Source/tasks.c **** 				This task cannot be in an event list as it is the currently
 746:FreeRTOS/Source/tasks.c **** 				executing task. */
 747:FreeRTOS/Source/tasks.c **** 
 748:FreeRTOS/Source/tasks.c **** 				/* Calculate the time to wake - this may overflow but this is
 749:FreeRTOS/Source/tasks.c **** 				not a problem. */
 750:FreeRTOS/Source/tasks.c **** 				xTimeToWake = xTickCount + xTicksToDelay;
 651              		.loc 1 750 0
 652 0018 40F20003 		movw	r3, #:lower16:xTickCount
 653 001c C0F20003 		movt	r3, #:upper16:xTickCount
 654 0020 1A68     		ldr	r2, [r3, #0]
 655 0022 7B68     		ldr	r3, [r7, #4]
 656 0024 D318     		adds	r3, r2, r3
 657 0026 BB60     		str	r3, [r7, #8]
 751:FreeRTOS/Source/tasks.c **** 
 752:FreeRTOS/Source/tasks.c **** 				/* We must remove ourselves from the ready list before adding
 753:FreeRTOS/Source/tasks.c **** 				ourselves to the blocked list as the same list item is used for
 754:FreeRTOS/Source/tasks.c **** 				both lists. */
 755:FreeRTOS/Source/tasks.c **** 				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
 658              		.loc 1 755 0
 659 0028 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 660 002c C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 661 0030 1B68     		ldr	r3, [r3, #0]
 662 0032 03F10403 		add	r3, r3, #4
 663 0036 1846     		mov	r0, r3
 664 0038 FFF7FEFF 		bl	vListRemove
 756:FreeRTOS/Source/tasks.c **** 				prvAddCurrentTaskToDelayedList( xTimeToWake );
 665              		.loc 1 756 0
 666 003c B868     		ldr	r0, [r7, #8]
 667 003e FFF7FEFF 		bl	prvAddCurrentTaskToDelayedList
 757:FreeRTOS/Source/tasks.c **** 			}
 758:FreeRTOS/Source/tasks.c **** 			xAlreadyYielded = xTaskResumeAll();
 668              		.loc 1 758 0
 669 0042 FFF7FEFF 		bl	xTaskResumeAll
 670 0046 F860     		str	r0, [r7, #12]
 671              	.L23:
 759:FreeRTOS/Source/tasks.c **** 		}
 760:FreeRTOS/Source/tasks.c **** 
 761:FreeRTOS/Source/tasks.c **** 		/* Force a reschedule if xTaskResumeAll has not already done so, we may
 762:FreeRTOS/Source/tasks.c **** 		have put ourselves to sleep. */
 763:FreeRTOS/Source/tasks.c **** 		if( xAlreadyYielded == pdFALSE )
 672              		.loc 1 763 0
 673 0048 FB68     		ldr	r3, [r7, #12]
 674 004a 002B     		cmp	r3, #0
 675 004c 01D1     		bne	.L22
 764:FreeRTOS/Source/tasks.c **** 		{
 765:FreeRTOS/Source/tasks.c **** 			portYIELD_WITHIN_API();
 676              		.loc 1 765 0
 677 004e FFF7FEFF 		bl	vPortYieldFromISR
 678              	.L22:
 766:FreeRTOS/Source/tasks.c **** 		}
 767:FreeRTOS/Source/tasks.c **** 	}
 679              		.loc 1 767 0
 680 0052 07F11007 		add	r7, r7, #16
 681 0056 BD46     		mov	sp, r7
 682 0058 80BD     		pop	{r7, pc}
 683              		.cfi_endproc
 684              	.LFE113:
 686 005a 00BF     		.section	.text.uxTaskPriorityGet,"ax",%progbits
 687              		.align	2
 688              		.global	uxTaskPriorityGet
 689              		.thumb
 690              		.thumb_func
 692              	uxTaskPriorityGet:
 693              	.LFB114:
 768:FreeRTOS/Source/tasks.c **** 
 769:FreeRTOS/Source/tasks.c **** #endif
 770:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 771:FreeRTOS/Source/tasks.c **** 
 772:FreeRTOS/Source/tasks.c **** #if ( INCLUDE_uxTaskPriorityGet == 1 )
 773:FreeRTOS/Source/tasks.c **** 
 774:FreeRTOS/Source/tasks.c **** 	unsigned portBASE_TYPE uxTaskPriorityGet( xTaskHandle pxTask )
 775:FreeRTOS/Source/tasks.c **** 	{
 694              		.loc 1 775 0
 695              		.cfi_startproc
 696              		@ args = 0, pretend = 0, frame = 16
 697              		@ frame_needed = 1, uses_anonymous_args = 0
 698 0000 80B5     		push	{r7, lr}
 699              	.LCFI12:
 700              		.cfi_def_cfa_offset 8
 701              		.cfi_offset 14, -4
 702              		.cfi_offset 7, -8
 703 0002 84B0     		sub	sp, sp, #16
 704              	.LCFI13:
 705              		.cfi_def_cfa_offset 24
 706 0004 00AF     		add	r7, sp, #0
 707              	.LCFI14:
 708              		.cfi_def_cfa_register 7
 709 0006 7860     		str	r0, [r7, #4]
 776:FreeRTOS/Source/tasks.c **** 	tskTCB *pxTCB;
 777:FreeRTOS/Source/tasks.c **** 	unsigned portBASE_TYPE uxReturn;
 778:FreeRTOS/Source/tasks.c **** 
 779:FreeRTOS/Source/tasks.c **** 		taskENTER_CRITICAL();
 710              		.loc 1 779 0
 711 0008 FFF7FEFF 		bl	vPortEnterCritical
 780:FreeRTOS/Source/tasks.c **** 		{
 781:FreeRTOS/Source/tasks.c **** 			/* If null is passed in here then we are changing the
 782:FreeRTOS/Source/tasks.c **** 			priority of the calling function. */
 783:FreeRTOS/Source/tasks.c **** 			pxTCB = prvGetTCBFromHandle( pxTask );
 712              		.loc 1 783 0
 713 000c 7B68     		ldr	r3, [r7, #4]
 714 000e 002B     		cmp	r3, #0
 715 0010 05D1     		bne	.L26
 716              		.loc 1 783 0 is_stmt 0 discriminator 1
 717 0012 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 718 0016 C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 719 001a 1B68     		ldr	r3, [r3, #0]
 720 001c 00E0     		b	.L27
 721              	.L26:
 722              		.loc 1 783 0 discriminator 2
 723 001e 7B68     		ldr	r3, [r7, #4]
 724              	.L27:
 725              		.loc 1 783 0 discriminator 3
 726 0020 FB60     		str	r3, [r7, #12]
 784:FreeRTOS/Source/tasks.c **** 			uxReturn = pxTCB->uxPriority;
 727              		.loc 1 784 0 is_stmt 1 discriminator 3
 728 0022 FB68     		ldr	r3, [r7, #12]
 729 0024 DB6A     		ldr	r3, [r3, #44]
 730 0026 BB60     		str	r3, [r7, #8]
 785:FreeRTOS/Source/tasks.c **** 		}
 786:FreeRTOS/Source/tasks.c **** 		taskEXIT_CRITICAL();
 731              		.loc 1 786 0 discriminator 3
 732 0028 FFF7FEFF 		bl	vPortExitCritical
 787:FreeRTOS/Source/tasks.c **** 
 788:FreeRTOS/Source/tasks.c **** 		return uxReturn;
 733              		.loc 1 788 0 discriminator 3
 734 002c BB68     		ldr	r3, [r7, #8]
 789:FreeRTOS/Source/tasks.c **** 	}
 735              		.loc 1 789 0 discriminator 3
 736 002e 1846     		mov	r0, r3
 737 0030 07F11007 		add	r7, r7, #16
 738 0034 BD46     		mov	sp, r7
 739 0036 80BD     		pop	{r7, pc}
 740              		.cfi_endproc
 741              	.LFE114:
 743              		.section	.text.vTaskPrioritySet,"ax",%progbits
 744              		.align	2
 745              		.global	vTaskPrioritySet
 746              		.thumb
 747              		.thumb_func
 749              	vTaskPrioritySet:
 750              	.LFB115:
 790:FreeRTOS/Source/tasks.c **** 
 791:FreeRTOS/Source/tasks.c **** #endif
 792:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 793:FreeRTOS/Source/tasks.c **** 
 794:FreeRTOS/Source/tasks.c **** #if ( INCLUDE_vTaskPrioritySet == 1 )
 795:FreeRTOS/Source/tasks.c **** 
 796:FreeRTOS/Source/tasks.c **** 	void vTaskPrioritySet( xTaskHandle pxTask, unsigned portBASE_TYPE uxNewPriority )
 797:FreeRTOS/Source/tasks.c **** 	{
 751              		.loc 1 797 0
 752              		.cfi_startproc
 753              		@ args = 0, pretend = 0, frame = 24
 754              		@ frame_needed = 1, uses_anonymous_args = 0
 755 0000 80B5     		push	{r7, lr}
 756              	.LCFI15:
 757              		.cfi_def_cfa_offset 8
 758              		.cfi_offset 14, -4
 759              		.cfi_offset 7, -8
 760 0002 86B0     		sub	sp, sp, #24
 761              	.LCFI16:
 762              		.cfi_def_cfa_offset 32
 763 0004 00AF     		add	r7, sp, #0
 764              	.LCFI17:
 765              		.cfi_def_cfa_register 7
 766 0006 7860     		str	r0, [r7, #4]
 767 0008 3960     		str	r1, [r7, #0]
 798:FreeRTOS/Source/tasks.c **** 	tskTCB *pxTCB;
 799:FreeRTOS/Source/tasks.c **** 	unsigned portBASE_TYPE uxCurrentPriority;
 800:FreeRTOS/Source/tasks.c **** 	portBASE_TYPE xYieldRequired = pdFALSE;
 768              		.loc 1 800 0
 769 000a 4FF00003 		mov	r3, #0
 770 000e 7B61     		str	r3, [r7, #20]
 801:FreeRTOS/Source/tasks.c **** 
 802:FreeRTOS/Source/tasks.c **** 		configASSERT( ( uxNewPriority < configMAX_PRIORITIES ) );
 803:FreeRTOS/Source/tasks.c **** 
 804:FreeRTOS/Source/tasks.c **** 		/* Ensure the new priority is valid. */
 805:FreeRTOS/Source/tasks.c **** 		if( uxNewPriority >= configMAX_PRIORITIES )
 771              		.loc 1 805 0
 772 0010 3B68     		ldr	r3, [r7, #0]
 773 0012 042B     		cmp	r3, #4
 774 0014 02D9     		bls	.L29
 806:FreeRTOS/Source/tasks.c **** 		{
 807:FreeRTOS/Source/tasks.c **** 			uxNewPriority = configMAX_PRIORITIES - ( unsigned portBASE_TYPE ) 1U;
 775              		.loc 1 807 0
 776 0016 4FF00403 		mov	r3, #4
 777 001a 3B60     		str	r3, [r7, #0]
 778              	.L29:
 808:FreeRTOS/Source/tasks.c **** 		}
 809:FreeRTOS/Source/tasks.c **** 
 810:FreeRTOS/Source/tasks.c **** 		taskENTER_CRITICAL();
 779              		.loc 1 810 0
 780 001c FFF7FEFF 		bl	vPortEnterCritical
 811:FreeRTOS/Source/tasks.c **** 		{
 812:FreeRTOS/Source/tasks.c **** 			if( pxTask == pxCurrentTCB )
 781              		.loc 1 812 0
 782 0020 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 783 0024 C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 784 0028 1B68     		ldr	r3, [r3, #0]
 785 002a 7A68     		ldr	r2, [r7, #4]
 786 002c 9A42     		cmp	r2, r3
 787 002e 02D1     		bne	.L30
 813:FreeRTOS/Source/tasks.c **** 			{
 814:FreeRTOS/Source/tasks.c **** 				pxTask = NULL;
 788              		.loc 1 814 0
 789 0030 4FF00003 		mov	r3, #0
 790 0034 7B60     		str	r3, [r7, #4]
 791              	.L30:
 815:FreeRTOS/Source/tasks.c **** 			}
 816:FreeRTOS/Source/tasks.c **** 
 817:FreeRTOS/Source/tasks.c **** 			/* If null is passed in here then we are changing the
 818:FreeRTOS/Source/tasks.c **** 			priority of the calling function. */
 819:FreeRTOS/Source/tasks.c **** 			pxTCB = prvGetTCBFromHandle( pxTask );
 792              		.loc 1 819 0
 793 0036 7B68     		ldr	r3, [r7, #4]
 794 0038 002B     		cmp	r3, #0
 795 003a 05D1     		bne	.L31
 796              		.loc 1 819 0 is_stmt 0 discriminator 1
 797 003c 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 798 0040 C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 799 0044 1B68     		ldr	r3, [r3, #0]
 800 0046 00E0     		b	.L32
 801              	.L31:
 802              		.loc 1 819 0 discriminator 2
 803 0048 7B68     		ldr	r3, [r7, #4]
 804              	.L32:
 805              		.loc 1 819 0 discriminator 3
 806 004a 3B61     		str	r3, [r7, #16]
 820:FreeRTOS/Source/tasks.c **** 
 821:FreeRTOS/Source/tasks.c **** 			traceTASK_PRIORITY_SET( pxTask, uxNewPriority );
 822:FreeRTOS/Source/tasks.c **** 
 823:FreeRTOS/Source/tasks.c **** 			#if ( configUSE_MUTEXES == 1 )
 824:FreeRTOS/Source/tasks.c **** 			{
 825:FreeRTOS/Source/tasks.c **** 				uxCurrentPriority = pxTCB->uxBasePriority;
 807              		.loc 1 825 0 is_stmt 1 discriminator 3
 808 004c 3B69     		ldr	r3, [r7, #16]
 809 004e 5B6C     		ldr	r3, [r3, #68]
 810 0050 FB60     		str	r3, [r7, #12]
 826:FreeRTOS/Source/tasks.c **** 			}
 827:FreeRTOS/Source/tasks.c **** 			#else
 828:FreeRTOS/Source/tasks.c **** 			{
 829:FreeRTOS/Source/tasks.c **** 				uxCurrentPriority = pxTCB->uxPriority;
 830:FreeRTOS/Source/tasks.c **** 			}
 831:FreeRTOS/Source/tasks.c **** 			#endif
 832:FreeRTOS/Source/tasks.c **** 
 833:FreeRTOS/Source/tasks.c **** 			if( uxCurrentPriority != uxNewPriority )
 811              		.loc 1 833 0 discriminator 3
 812 0052 FA68     		ldr	r2, [r7, #12]
 813 0054 3B68     		ldr	r3, [r7, #0]
 814 0056 9A42     		cmp	r2, r3
 815 0058 62D0     		beq	.L33
 834:FreeRTOS/Source/tasks.c **** 			{
 835:FreeRTOS/Source/tasks.c **** 				/* The priority change may have readied a task of higher
 836:FreeRTOS/Source/tasks.c **** 				priority than the calling task. */
 837:FreeRTOS/Source/tasks.c **** 				if( uxNewPriority > uxCurrentPriority )
 816              		.loc 1 837 0
 817 005a 3A68     		ldr	r2, [r7, #0]
 818 005c FB68     		ldr	r3, [r7, #12]
 819 005e 9A42     		cmp	r2, r3
 820 0060 06D9     		bls	.L34
 838:FreeRTOS/Source/tasks.c **** 				{
 839:FreeRTOS/Source/tasks.c **** 					if( pxTask != NULL )
 821              		.loc 1 839 0
 822 0062 7B68     		ldr	r3, [r7, #4]
 823 0064 002B     		cmp	r3, #0
 824 0066 09D0     		beq	.L35
 840:FreeRTOS/Source/tasks.c **** 					{
 841:FreeRTOS/Source/tasks.c **** 						/* The priority of another task is being raised.  If we
 842:FreeRTOS/Source/tasks.c **** 						were raising the priority of the currently running task
 843:FreeRTOS/Source/tasks.c **** 						there would be no need to switch as it must have already
 844:FreeRTOS/Source/tasks.c **** 						been the highest priority task. */
 845:FreeRTOS/Source/tasks.c **** 						xYieldRequired = pdTRUE;
 825              		.loc 1 845 0
 826 0068 4FF00103 		mov	r3, #1
 827 006c 7B61     		str	r3, [r7, #20]
 828 006e 05E0     		b	.L35
 829              	.L34:
 846:FreeRTOS/Source/tasks.c **** 					}
 847:FreeRTOS/Source/tasks.c **** 				}
 848:FreeRTOS/Source/tasks.c **** 				else if( pxTask == NULL )
 830              		.loc 1 848 0
 831 0070 7B68     		ldr	r3, [r7, #4]
 832 0072 002B     		cmp	r3, #0
 833 0074 02D1     		bne	.L35
 849:FreeRTOS/Source/tasks.c **** 				{
 850:FreeRTOS/Source/tasks.c **** 					/* Setting our own priority down means there may now be another
 851:FreeRTOS/Source/tasks.c **** 					task of higher priority that is ready to execute. */
 852:FreeRTOS/Source/tasks.c **** 					xYieldRequired = pdTRUE;
 834              		.loc 1 852 0
 835 0076 4FF00103 		mov	r3, #1
 836 007a 7B61     		str	r3, [r7, #20]
 837              	.L35:
 853:FreeRTOS/Source/tasks.c **** 				}
 854:FreeRTOS/Source/tasks.c **** 
 855:FreeRTOS/Source/tasks.c **** 
 856:FreeRTOS/Source/tasks.c **** 
 857:FreeRTOS/Source/tasks.c **** 				#if ( configUSE_MUTEXES == 1 )
 858:FreeRTOS/Source/tasks.c **** 				{
 859:FreeRTOS/Source/tasks.c **** 					/* Only change the priority being used if the task is not
 860:FreeRTOS/Source/tasks.c **** 					currently using an inherited priority. */
 861:FreeRTOS/Source/tasks.c **** 					if( pxTCB->uxBasePriority == pxTCB->uxPriority )
 838              		.loc 1 861 0
 839 007c 3B69     		ldr	r3, [r7, #16]
 840 007e 5A6C     		ldr	r2, [r3, #68]
 841 0080 3B69     		ldr	r3, [r7, #16]
 842 0082 DB6A     		ldr	r3, [r3, #44]
 843 0084 9A42     		cmp	r2, r3
 844 0086 02D1     		bne	.L36
 862:FreeRTOS/Source/tasks.c **** 					{
 863:FreeRTOS/Source/tasks.c **** 						pxTCB->uxPriority = uxNewPriority;
 845              		.loc 1 863 0
 846 0088 3B69     		ldr	r3, [r7, #16]
 847 008a 3A68     		ldr	r2, [r7, #0]
 848 008c DA62     		str	r2, [r3, #44]
 849              	.L36:
 864:FreeRTOS/Source/tasks.c **** 					}
 865:FreeRTOS/Source/tasks.c **** 
 866:FreeRTOS/Source/tasks.c **** 					/* The base priority gets set whatever. */
 867:FreeRTOS/Source/tasks.c **** 					pxTCB->uxBasePriority = uxNewPriority;
 850              		.loc 1 867 0
 851 008e 3B69     		ldr	r3, [r7, #16]
 852 0090 3A68     		ldr	r2, [r7, #0]
 853 0092 5A64     		str	r2, [r3, #68]
 868:FreeRTOS/Source/tasks.c **** 				}
 869:FreeRTOS/Source/tasks.c **** 				#else
 870:FreeRTOS/Source/tasks.c **** 				{
 871:FreeRTOS/Source/tasks.c **** 					pxTCB->uxPriority = uxNewPriority;
 872:FreeRTOS/Source/tasks.c **** 				}
 873:FreeRTOS/Source/tasks.c **** 				#endif
 874:FreeRTOS/Source/tasks.c **** 
 875:FreeRTOS/Source/tasks.c **** 				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( configMAX_PRIORITIES - ( portTickType ) 
 854              		.loc 1 875 0
 855 0094 3B68     		ldr	r3, [r7, #0]
 856 0096 C3F10502 		rsb	r2, r3, #5
 857 009a 3B69     		ldr	r3, [r7, #16]
 858 009c 9A61     		str	r2, [r3, #24]
 876:FreeRTOS/Source/tasks.c **** 
 877:FreeRTOS/Source/tasks.c **** 				/* If the task is in the blocked or suspended list we need do
 878:FreeRTOS/Source/tasks.c **** 				nothing more than change it's priority variable. However, if
 879:FreeRTOS/Source/tasks.c **** 				the task is in a ready list it needs to be removed and placed
 880:FreeRTOS/Source/tasks.c **** 				in the queue appropriate to its new priority. */
 881:FreeRTOS/Source/tasks.c **** 				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxCurrentPriority ] ), &( pxTCB->xGenericLis
 859              		.loc 1 881 0
 860 009e 3B69     		ldr	r3, [r7, #16]
 861 00a0 5969     		ldr	r1, [r3, #20]
 862 00a2 FA68     		ldr	r2, [r7, #12]
 863 00a4 1346     		mov	r3, r2
 864 00a6 4FEA8303 		lsl	r3, r3, #2
 865 00aa 9B18     		adds	r3, r3, r2
 866 00ac 4FEA8303 		lsl	r3, r3, #2
 867 00b0 1A46     		mov	r2, r3
 868 00b2 40F20003 		movw	r3, #:lower16:pxReadyTasksLists
 869 00b6 C0F20003 		movt	r3, #:upper16:pxReadyTasksLists
 870 00ba D318     		adds	r3, r2, r3
 871 00bc 9942     		cmp	r1, r3
 872 00be 2AD1     		bne	.L37
 882:FreeRTOS/Source/tasks.c **** 				{
 883:FreeRTOS/Source/tasks.c **** 					/* The task is currently in its ready list - remove before adding
 884:FreeRTOS/Source/tasks.c **** 					it to it's new ready list.  As we are in a critical section we
 885:FreeRTOS/Source/tasks.c **** 					can do this even if the scheduler is suspended. */
 886:FreeRTOS/Source/tasks.c **** 					vListRemove( &( pxTCB->xGenericListItem ) );
 873              		.loc 1 886 0
 874 00c0 3B69     		ldr	r3, [r7, #16]
 875 00c2 03F10403 		add	r3, r3, #4
 876 00c6 1846     		mov	r0, r3
 877 00c8 FFF7FEFF 		bl	vListRemove
 887:FreeRTOS/Source/tasks.c **** 					prvAddTaskToReadyQueue( pxTCB );
 878              		.loc 1 887 0
 879 00cc 3B69     		ldr	r3, [r7, #16]
 880 00ce DA6A     		ldr	r2, [r3, #44]
 881 00d0 40F20003 		movw	r3, #:lower16:uxTopReadyPriority
 882 00d4 C0F20003 		movt	r3, #:upper16:uxTopReadyPriority
 883 00d8 1B68     		ldr	r3, [r3, #0]
 884 00da 9A42     		cmp	r2, r3
 885 00dc 06D9     		bls	.L38
 886              		.loc 1 887 0 is_stmt 0 discriminator 1
 887 00de 3B69     		ldr	r3, [r7, #16]
 888 00e0 DA6A     		ldr	r2, [r3, #44]
 889 00e2 40F20003 		movw	r3, #:lower16:uxTopReadyPriority
 890 00e6 C0F20003 		movt	r3, #:upper16:uxTopReadyPriority
 891 00ea 1A60     		str	r2, [r3, #0]
 892              	.L38:
 893              		.loc 1 887 0 discriminator 2
 894 00ec 3B69     		ldr	r3, [r7, #16]
 895 00ee DA6A     		ldr	r2, [r3, #44]
 896 00f0 1346     		mov	r3, r2
 897 00f2 4FEA8303 		lsl	r3, r3, #2
 898 00f6 9B18     		adds	r3, r3, r2
 899 00f8 4FEA8303 		lsl	r3, r3, #2
 900 00fc 1A46     		mov	r2, r3
 901 00fe 40F20003 		movw	r3, #:lower16:pxReadyTasksLists
 902 0102 C0F20003 		movt	r3, #:upper16:pxReadyTasksLists
 903 0106 D218     		adds	r2, r2, r3
 904 0108 3B69     		ldr	r3, [r7, #16]
 905 010a 03F10403 		add	r3, r3, #4
 906 010e 1046     		mov	r0, r2
 907 0110 1946     		mov	r1, r3
 908 0112 FFF7FEFF 		bl	vListInsertEnd
 909              	.L37:
 888:FreeRTOS/Source/tasks.c **** 				}
 889:FreeRTOS/Source/tasks.c **** 
 890:FreeRTOS/Source/tasks.c **** 				if( xYieldRequired == pdTRUE )
 910              		.loc 1 890 0 is_stmt 1
 911 0116 7B69     		ldr	r3, [r7, #20]
 912 0118 012B     		cmp	r3, #1
 913 011a 01D1     		bne	.L33
 891:FreeRTOS/Source/tasks.c **** 				{
 892:FreeRTOS/Source/tasks.c **** 					portYIELD_WITHIN_API();
 914              		.loc 1 892 0
 915 011c FFF7FEFF 		bl	vPortYieldFromISR
 916              	.L33:
 893:FreeRTOS/Source/tasks.c **** 				}
 894:FreeRTOS/Source/tasks.c **** 			}
 895:FreeRTOS/Source/tasks.c **** 		}
 896:FreeRTOS/Source/tasks.c **** 		taskEXIT_CRITICAL();
 917              		.loc 1 896 0
 918 0120 FFF7FEFF 		bl	vPortExitCritical
 897:FreeRTOS/Source/tasks.c **** 	}
 919              		.loc 1 897 0
 920 0124 07F11807 		add	r7, r7, #24
 921 0128 BD46     		mov	sp, r7
 922 012a 80BD     		pop	{r7, pc}
 923              		.cfi_endproc
 924              	.LFE115:
 926              		.section	.text.vTaskSuspend,"ax",%progbits
 927              		.align	2
 928              		.global	vTaskSuspend
 929              		.thumb
 930              		.thumb_func
 932              	vTaskSuspend:
 933              	.LFB116:
 898:FreeRTOS/Source/tasks.c **** 
 899:FreeRTOS/Source/tasks.c **** #endif
 900:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 901:FreeRTOS/Source/tasks.c **** 
 902:FreeRTOS/Source/tasks.c **** #if ( INCLUDE_vTaskSuspend == 1 )
 903:FreeRTOS/Source/tasks.c **** 
 904:FreeRTOS/Source/tasks.c **** 	void vTaskSuspend( xTaskHandle pxTaskToSuspend )
 905:FreeRTOS/Source/tasks.c **** 	{
 934              		.loc 1 905 0
 935              		.cfi_startproc
 936              		@ args = 0, pretend = 0, frame = 16
 937              		@ frame_needed = 1, uses_anonymous_args = 0
 938 0000 80B5     		push	{r7, lr}
 939              	.LCFI18:
 940              		.cfi_def_cfa_offset 8
 941              		.cfi_offset 14, -4
 942              		.cfi_offset 7, -8
 943 0002 84B0     		sub	sp, sp, #16
 944              	.LCFI19:
 945              		.cfi_def_cfa_offset 24
 946 0004 00AF     		add	r7, sp, #0
 947              	.LCFI20:
 948              		.cfi_def_cfa_register 7
 949 0006 7860     		str	r0, [r7, #4]
 906:FreeRTOS/Source/tasks.c **** 	tskTCB *pxTCB;
 907:FreeRTOS/Source/tasks.c **** 
 908:FreeRTOS/Source/tasks.c **** 		taskENTER_CRITICAL();
 950              		.loc 1 908 0
 951 0008 FFF7FEFF 		bl	vPortEnterCritical
 909:FreeRTOS/Source/tasks.c **** 		{
 910:FreeRTOS/Source/tasks.c **** 			/* Ensure a yield is performed if the current task is being
 911:FreeRTOS/Source/tasks.c **** 			suspended. */
 912:FreeRTOS/Source/tasks.c **** 			if( pxTaskToSuspend == pxCurrentTCB )
 952              		.loc 1 912 0
 953 000c 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 954 0010 C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 955 0014 1B68     		ldr	r3, [r3, #0]
 956 0016 7A68     		ldr	r2, [r7, #4]
 957 0018 9A42     		cmp	r2, r3
 958 001a 02D1     		bne	.L40
 913:FreeRTOS/Source/tasks.c **** 			{
 914:FreeRTOS/Source/tasks.c **** 				pxTaskToSuspend = NULL;
 959              		.loc 1 914 0
 960 001c 4FF00003 		mov	r3, #0
 961 0020 7B60     		str	r3, [r7, #4]
 962              	.L40:
 915:FreeRTOS/Source/tasks.c **** 			}
 916:FreeRTOS/Source/tasks.c **** 
 917:FreeRTOS/Source/tasks.c **** 			/* If null is passed in here then we are suspending ourselves. */
 918:FreeRTOS/Source/tasks.c **** 			pxTCB = prvGetTCBFromHandle( pxTaskToSuspend );
 963              		.loc 1 918 0
 964 0022 7B68     		ldr	r3, [r7, #4]
 965 0024 002B     		cmp	r3, #0
 966 0026 05D1     		bne	.L41
 967              		.loc 1 918 0 is_stmt 0 discriminator 1
 968 0028 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 969 002c C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 970 0030 1B68     		ldr	r3, [r3, #0]
 971 0032 00E0     		b	.L42
 972              	.L41:
 973              		.loc 1 918 0 discriminator 2
 974 0034 7B68     		ldr	r3, [r7, #4]
 975              	.L42:
 976              		.loc 1 918 0 discriminator 3
 977 0036 FB60     		str	r3, [r7, #12]
 919:FreeRTOS/Source/tasks.c **** 
 920:FreeRTOS/Source/tasks.c **** 			traceTASK_SUSPEND( pxTCB );
 921:FreeRTOS/Source/tasks.c **** 
 922:FreeRTOS/Source/tasks.c **** 			/* Remove task from the ready/delayed list and place in the	suspended list. */
 923:FreeRTOS/Source/tasks.c **** 			vListRemove( &( pxTCB->xGenericListItem ) );
 978              		.loc 1 923 0 is_stmt 1 discriminator 3
 979 0038 FB68     		ldr	r3, [r7, #12]
 980 003a 03F10403 		add	r3, r3, #4
 981 003e 1846     		mov	r0, r3
 982 0040 FFF7FEFF 		bl	vListRemove
 924:FreeRTOS/Source/tasks.c **** 
 925:FreeRTOS/Source/tasks.c **** 			/* Is the task waiting on an event also? */
 926:FreeRTOS/Source/tasks.c **** 			if( pxTCB->xEventListItem.pvContainer != NULL )
 983              		.loc 1 926 0 discriminator 3
 984 0044 FB68     		ldr	r3, [r7, #12]
 985 0046 9B6A     		ldr	r3, [r3, #40]
 986 0048 002B     		cmp	r3, #0
 987 004a 05D0     		beq	.L43
 927:FreeRTOS/Source/tasks.c **** 			{
 928:FreeRTOS/Source/tasks.c **** 				vListRemove( &( pxTCB->xEventListItem ) );
 988              		.loc 1 928 0
 989 004c FB68     		ldr	r3, [r7, #12]
 990 004e 03F11803 		add	r3, r3, #24
 991 0052 1846     		mov	r0, r3
 992 0054 FFF7FEFF 		bl	vListRemove
 993              	.L43:
 929:FreeRTOS/Source/tasks.c **** 			}
 930:FreeRTOS/Source/tasks.c **** 
 931:FreeRTOS/Source/tasks.c **** 			vListInsertEnd( ( xList * ) &xSuspendedTaskList, &( pxTCB->xGenericListItem ) );
 994              		.loc 1 931 0
 995 0058 FB68     		ldr	r3, [r7, #12]
 996 005a 03F10403 		add	r3, r3, #4
 997 005e 40F20000 		movw	r0, #:lower16:xSuspendedTaskList
 998 0062 C0F20000 		movt	r0, #:upper16:xSuspendedTaskList
 999 0066 1946     		mov	r1, r3
 1000 0068 FFF7FEFF 		bl	vListInsertEnd
 932:FreeRTOS/Source/tasks.c **** 		}
 933:FreeRTOS/Source/tasks.c **** 		taskEXIT_CRITICAL();
 1001              		.loc 1 933 0
 1002 006c FFF7FEFF 		bl	vPortExitCritical
 934:FreeRTOS/Source/tasks.c **** 
 935:FreeRTOS/Source/tasks.c **** 		if( ( void * ) pxTaskToSuspend == NULL )
 1003              		.loc 1 935 0
 1004 0070 7B68     		ldr	r3, [r7, #4]
 1005 0072 002B     		cmp	r3, #0
 1006 0074 1FD1     		bne	.L39
 936:FreeRTOS/Source/tasks.c **** 		{
 937:FreeRTOS/Source/tasks.c **** 			if( xSchedulerRunning != pdFALSE )
 1007              		.loc 1 937 0
 1008 0076 40F20003 		movw	r3, #:lower16:xSchedulerRunning
 1009 007a C0F20003 		movt	r3, #:upper16:xSchedulerRunning
 1010 007e 1B68     		ldr	r3, [r3, #0]
 1011 0080 002B     		cmp	r3, #0
 1012 0082 02D0     		beq	.L45
 938:FreeRTOS/Source/tasks.c **** 			{
 939:FreeRTOS/Source/tasks.c **** 				/* We have just suspended the current task. */
 940:FreeRTOS/Source/tasks.c **** 				portYIELD_WITHIN_API();
 1013              		.loc 1 940 0
 1014 0084 FFF7FEFF 		bl	vPortYieldFromISR
 1015 0088 15E0     		b	.L39
 1016              	.L45:
 941:FreeRTOS/Source/tasks.c **** 			}
 942:FreeRTOS/Source/tasks.c **** 			else
 943:FreeRTOS/Source/tasks.c **** 			{
 944:FreeRTOS/Source/tasks.c **** 				/* The scheduler is not running, but the task that was pointed
 945:FreeRTOS/Source/tasks.c **** 				to by pxCurrentTCB has just been suspended and pxCurrentTCB
 946:FreeRTOS/Source/tasks.c **** 				must be adjusted to point to a different task. */
 947:FreeRTOS/Source/tasks.c **** 				if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == uxCurrentNumberOfTasks )
 1017              		.loc 1 947 0
 1018 008a 40F20003 		movw	r3, #:lower16:xSuspendedTaskList
 1019 008e C0F20003 		movt	r3, #:upper16:xSuspendedTaskList
 1020 0092 1A68     		ldr	r2, [r3, #0]
 1021 0094 40F20003 		movw	r3, #:lower16:uxCurrentNumberOfTasks
 1022 0098 C0F20003 		movt	r3, #:upper16:uxCurrentNumberOfTasks
 1023 009c 1B68     		ldr	r3, [r3, #0]
 1024 009e 9A42     		cmp	r2, r3
 1025 00a0 07D1     		bne	.L46
 948:FreeRTOS/Source/tasks.c **** 				{
 949:FreeRTOS/Source/tasks.c **** 					/* No other tasks are ready, so set pxCurrentTCB back to
 950:FreeRTOS/Source/tasks.c **** 					NULL so when the next task is created pxCurrentTCB will
 951:FreeRTOS/Source/tasks.c **** 					be set to point to it no matter what its relative priority
 952:FreeRTOS/Source/tasks.c **** 					is. */
 953:FreeRTOS/Source/tasks.c **** 					pxCurrentTCB = NULL;
 1026              		.loc 1 953 0
 1027 00a2 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 1028 00a6 C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 1029 00aa 4FF00002 		mov	r2, #0
 1030 00ae 1A60     		str	r2, [r3, #0]
 1031 00b0 01E0     		b	.L39
 1032              	.L46:
 954:FreeRTOS/Source/tasks.c **** 				}
 955:FreeRTOS/Source/tasks.c **** 				else
 956:FreeRTOS/Source/tasks.c **** 				{
 957:FreeRTOS/Source/tasks.c **** 					vTaskSwitchContext();
 1033              		.loc 1 957 0
 1034 00b2 FFF7FEFF 		bl	vTaskSwitchContext
 1035              	.L39:
 958:FreeRTOS/Source/tasks.c **** 				}
 959:FreeRTOS/Source/tasks.c **** 			}
 960:FreeRTOS/Source/tasks.c **** 		}
 961:FreeRTOS/Source/tasks.c **** 	}
 1036              		.loc 1 961 0
 1037 00b6 07F11007 		add	r7, r7, #16
 1038 00ba BD46     		mov	sp, r7
 1039 00bc 80BD     		pop	{r7, pc}
 1040              		.cfi_endproc
 1041              	.LFE116:
 1043 00be 00BF     		.section	.text.xTaskIsTaskSuspended,"ax",%progbits
 1044              		.align	2
 1045              		.global	xTaskIsTaskSuspended
 1046              		.thumb
 1047              		.thumb_func
 1049              	xTaskIsTaskSuspended:
 1050              	.LFB117:
 962:FreeRTOS/Source/tasks.c **** 
 963:FreeRTOS/Source/tasks.c **** #endif
 964:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 965:FreeRTOS/Source/tasks.c **** 
 966:FreeRTOS/Source/tasks.c **** #if ( INCLUDE_vTaskSuspend == 1 )
 967:FreeRTOS/Source/tasks.c **** 
 968:FreeRTOS/Source/tasks.c **** 	signed portBASE_TYPE xTaskIsTaskSuspended( xTaskHandle xTask )
 969:FreeRTOS/Source/tasks.c **** 	{
 1051              		.loc 1 969 0
 1052              		.cfi_startproc
 1053              		@ args = 0, pretend = 0, frame = 16
 1054              		@ frame_needed = 1, uses_anonymous_args = 0
 1055              		@ link register save eliminated.
 1056 0000 80B4     		push	{r7}
 1057              	.LCFI21:
 1058              		.cfi_def_cfa_offset 4
 1059              		.cfi_offset 7, -4
 1060 0002 85B0     		sub	sp, sp, #20
 1061              	.LCFI22:
 1062              		.cfi_def_cfa_offset 24
 1063 0004 00AF     		add	r7, sp, #0
 1064              	.LCFI23:
 1065              		.cfi_def_cfa_register 7
 1066 0006 7860     		str	r0, [r7, #4]
 970:FreeRTOS/Source/tasks.c **** 	portBASE_TYPE xReturn = pdFALSE;
 1067              		.loc 1 970 0
 1068 0008 4FF00003 		mov	r3, #0
 1069 000c FB60     		str	r3, [r7, #12]
 971:FreeRTOS/Source/tasks.c **** 	const tskTCB * const pxTCB = ( tskTCB * ) xTask;
 1070              		.loc 1 971 0
 1071 000e 7B68     		ldr	r3, [r7, #4]
 1072 0010 BB60     		str	r3, [r7, #8]
 972:FreeRTOS/Source/tasks.c **** 
 973:FreeRTOS/Source/tasks.c **** 		/* It does not make sense to check if the calling task is suspended. */
 974:FreeRTOS/Source/tasks.c **** 		configASSERT( xTask );
 975:FreeRTOS/Source/tasks.c **** 
 976:FreeRTOS/Source/tasks.c **** 		/* Is the task we are attempting to resume actually in the
 977:FreeRTOS/Source/tasks.c **** 		suspended list? */
 978:FreeRTOS/Source/tasks.c **** 		if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xGenericListItem ) ) != pdFALSE )
 1073              		.loc 1 978 0
 1074 0012 BB68     		ldr	r3, [r7, #8]
 1075 0014 5A69     		ldr	r2, [r3, #20]
 1076 0016 40F20003 		movw	r3, #:lower16:xSuspendedTaskList
 1077 001a C0F20003 		movt	r3, #:upper16:xSuspendedTaskList
 1078 001e 9A42     		cmp	r2, r3
 1079 0020 0ED1     		bne	.L48
 979:FreeRTOS/Source/tasks.c **** 		{
 980:FreeRTOS/Source/tasks.c **** 			/* Has the task already been resumed from within an ISR? */
 981:FreeRTOS/Source/tasks.c **** 			if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) != pdTRUE )
 1080              		.loc 1 981 0
 1081 0022 BB68     		ldr	r3, [r7, #8]
 1082 0024 9A6A     		ldr	r2, [r3, #40]
 1083 0026 40F20003 		movw	r3, #:lower16:xPendingReadyList
 1084 002a C0F20003 		movt	r3, #:upper16:xPendingReadyList
 1085 002e 9A42     		cmp	r2, r3
 1086 0030 06D0     		beq	.L48
 982:FreeRTOS/Source/tasks.c **** 			{
 983:FreeRTOS/Source/tasks.c **** 				/* Is it in the suspended list because it is in the
 984:FreeRTOS/Source/tasks.c **** 				Suspended state?  It is possible to be in the suspended
 985:FreeRTOS/Source/tasks.c **** 				list because it is blocked on a task with no timeout
 986:FreeRTOS/Source/tasks.c **** 				specified. */
 987:FreeRTOS/Source/tasks.c **** 				if( listIS_CONTAINED_WITHIN( NULL, &( pxTCB->xEventListItem ) ) == pdTRUE )
 1087              		.loc 1 987 0
 1088 0032 BB68     		ldr	r3, [r7, #8]
 1089 0034 9B6A     		ldr	r3, [r3, #40]
 1090 0036 002B     		cmp	r3, #0
 1091 0038 02D1     		bne	.L48
 988:FreeRTOS/Source/tasks.c **** 				{
 989:FreeRTOS/Source/tasks.c **** 					xReturn = pdTRUE;
 1092              		.loc 1 989 0
 1093 003a 4FF00103 		mov	r3, #1
 1094 003e FB60     		str	r3, [r7, #12]
 1095              	.L48:
 990:FreeRTOS/Source/tasks.c **** 				}
 991:FreeRTOS/Source/tasks.c **** 			}
 992:FreeRTOS/Source/tasks.c **** 		}
 993:FreeRTOS/Source/tasks.c **** 
 994:FreeRTOS/Source/tasks.c **** 		return xReturn;
 1096              		.loc 1 994 0
 1097 0040 FB68     		ldr	r3, [r7, #12]
 995:FreeRTOS/Source/tasks.c **** 	}
 1098              		.loc 1 995 0
 1099 0042 1846     		mov	r0, r3
 1100 0044 07F11407 		add	r7, r7, #20
 1101 0048 BD46     		mov	sp, r7
 1102 004a 80BC     		pop	{r7}
 1103 004c 7047     		bx	lr
 1104              		.cfi_endproc
 1105              	.LFE117:
 1107 004e 00BF     		.section	.text.vTaskResume,"ax",%progbits
 1108              		.align	2
 1109              		.global	vTaskResume
 1110              		.thumb
 1111              		.thumb_func
 1113              	vTaskResume:
 1114              	.LFB118:
 996:FreeRTOS/Source/tasks.c **** 
 997:FreeRTOS/Source/tasks.c **** #endif
 998:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 999:FreeRTOS/Source/tasks.c **** 
1000:FreeRTOS/Source/tasks.c **** #if ( INCLUDE_vTaskSuspend == 1 )
1001:FreeRTOS/Source/tasks.c **** 
1002:FreeRTOS/Source/tasks.c **** 	void vTaskResume( xTaskHandle pxTaskToResume )
1003:FreeRTOS/Source/tasks.c **** 	{
 1115              		.loc 1 1003 0
 1116              		.cfi_startproc
 1117              		@ args = 0, pretend = 0, frame = 16
 1118              		@ frame_needed = 1, uses_anonymous_args = 0
 1119 0000 80B5     		push	{r7, lr}
 1120              	.LCFI24:
 1121              		.cfi_def_cfa_offset 8
 1122              		.cfi_offset 14, -4
 1123              		.cfi_offset 7, -8
 1124 0002 84B0     		sub	sp, sp, #16
 1125              	.LCFI25:
 1126              		.cfi_def_cfa_offset 24
 1127 0004 00AF     		add	r7, sp, #0
 1128              	.LCFI26:
 1129              		.cfi_def_cfa_register 7
 1130 0006 7860     		str	r0, [r7, #4]
1004:FreeRTOS/Source/tasks.c **** 	tskTCB *pxTCB;
1005:FreeRTOS/Source/tasks.c **** 
1006:FreeRTOS/Source/tasks.c **** 		/* It does not make sense to resume the calling task. */
1007:FreeRTOS/Source/tasks.c **** 		configASSERT( pxTaskToResume );
1008:FreeRTOS/Source/tasks.c **** 
1009:FreeRTOS/Source/tasks.c **** 		/* Remove the task from whichever list it is currently in, and place
1010:FreeRTOS/Source/tasks.c **** 		it in the ready list. */
1011:FreeRTOS/Source/tasks.c **** 		pxTCB = ( tskTCB * ) pxTaskToResume;
 1131              		.loc 1 1011 0
 1132 0008 7B68     		ldr	r3, [r7, #4]
 1133 000a FB60     		str	r3, [r7, #12]
1012:FreeRTOS/Source/tasks.c **** 
1013:FreeRTOS/Source/tasks.c **** 		/* The parameter cannot be NULL as it is impossible to resume the
1014:FreeRTOS/Source/tasks.c **** 		currently executing task. */
1015:FreeRTOS/Source/tasks.c **** 		if( ( pxTCB != NULL ) && ( pxTCB != pxCurrentTCB ) )
 1134              		.loc 1 1015 0
 1135 000c FB68     		ldr	r3, [r7, #12]
 1136 000e 002B     		cmp	r3, #0
 1137 0010 48D0     		beq	.L49
 1138              		.loc 1 1015 0 is_stmt 0 discriminator 1
 1139 0012 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 1140 0016 C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 1141 001a 1B68     		ldr	r3, [r3, #0]
 1142 001c FA68     		ldr	r2, [r7, #12]
 1143 001e 9A42     		cmp	r2, r3
 1144 0020 40D0     		beq	.L49
1016:FreeRTOS/Source/tasks.c **** 		{
1017:FreeRTOS/Source/tasks.c **** 			taskENTER_CRITICAL();
 1145              		.loc 1 1017 0 is_stmt 1
 1146 0022 FFF7FEFF 		bl	vPortEnterCritical
1018:FreeRTOS/Source/tasks.c **** 			{
1019:FreeRTOS/Source/tasks.c **** 				if( xTaskIsTaskSuspended( pxTCB ) == pdTRUE )
 1147              		.loc 1 1019 0
 1148 0026 F868     		ldr	r0, [r7, #12]
 1149 0028 FFF7FEFF 		bl	xTaskIsTaskSuspended
 1150 002c 0346     		mov	r3, r0
 1151 002e 012B     		cmp	r3, #1
 1152 0030 36D1     		bne	.L51
1020:FreeRTOS/Source/tasks.c **** 				{
1021:FreeRTOS/Source/tasks.c **** 					traceTASK_RESUME( pxTCB );
1022:FreeRTOS/Source/tasks.c **** 
1023:FreeRTOS/Source/tasks.c **** 					/* As we are in a critical section we can access the ready
1024:FreeRTOS/Source/tasks.c **** 					lists even if the scheduler is suspended. */
1025:FreeRTOS/Source/tasks.c **** 					vListRemove(  &( pxTCB->xGenericListItem ) );
 1153              		.loc 1 1025 0
 1154 0032 FB68     		ldr	r3, [r7, #12]
 1155 0034 03F10403 		add	r3, r3, #4
 1156 0038 1846     		mov	r0, r3
 1157 003a FFF7FEFF 		bl	vListRemove
1026:FreeRTOS/Source/tasks.c **** 					prvAddTaskToReadyQueue( pxTCB );
 1158              		.loc 1 1026 0
 1159 003e FB68     		ldr	r3, [r7, #12]
 1160 0040 DA6A     		ldr	r2, [r3, #44]
 1161 0042 40F20003 		movw	r3, #:lower16:uxTopReadyPriority
 1162 0046 C0F20003 		movt	r3, #:upper16:uxTopReadyPriority
 1163 004a 1B68     		ldr	r3, [r3, #0]
 1164 004c 9A42     		cmp	r2, r3
 1165 004e 06D9     		bls	.L52
 1166              		.loc 1 1026 0 is_stmt 0 discriminator 1
 1167 0050 FB68     		ldr	r3, [r7, #12]
 1168 0052 DA6A     		ldr	r2, [r3, #44]
 1169 0054 40F20003 		movw	r3, #:lower16:uxTopReadyPriority
 1170 0058 C0F20003 		movt	r3, #:upper16:uxTopReadyPriority
 1171 005c 1A60     		str	r2, [r3, #0]
 1172              	.L52:
 1173              		.loc 1 1026 0 discriminator 2
 1174 005e FB68     		ldr	r3, [r7, #12]
 1175 0060 DA6A     		ldr	r2, [r3, #44]
 1176 0062 1346     		mov	r3, r2
 1177 0064 4FEA8303 		lsl	r3, r3, #2
 1178 0068 9B18     		adds	r3, r3, r2
 1179 006a 4FEA8303 		lsl	r3, r3, #2
 1180 006e 1A46     		mov	r2, r3
 1181 0070 40F20003 		movw	r3, #:lower16:pxReadyTasksLists
 1182 0074 C0F20003 		movt	r3, #:upper16:pxReadyTasksLists
 1183 0078 D218     		adds	r2, r2, r3
 1184 007a FB68     		ldr	r3, [r7, #12]
 1185 007c 03F10403 		add	r3, r3, #4
 1186 0080 1046     		mov	r0, r2
 1187 0082 1946     		mov	r1, r3
 1188 0084 FFF7FEFF 		bl	vListInsertEnd
1027:FreeRTOS/Source/tasks.c **** 
1028:FreeRTOS/Source/tasks.c **** 					/* We may have just resumed a higher priority task. */
1029:FreeRTOS/Source/tasks.c **** 					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 1189              		.loc 1 1029 0 is_stmt 1 discriminator 2
 1190 0088 FB68     		ldr	r3, [r7, #12]
 1191 008a DA6A     		ldr	r2, [r3, #44]
 1192 008c 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 1193 0090 C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 1194 0094 1B68     		ldr	r3, [r3, #0]
 1195 0096 DB6A     		ldr	r3, [r3, #44]
 1196 0098 9A42     		cmp	r2, r3
 1197 009a 01D3     		bcc	.L51
1030:FreeRTOS/Source/tasks.c **** 					{
1031:FreeRTOS/Source/tasks.c **** 						/* This yield may not cause the task just resumed to run, but
1032:FreeRTOS/Source/tasks.c **** 						will leave the lists in the correct state for the next yield. */
1033:FreeRTOS/Source/tasks.c **** 						portYIELD_WITHIN_API();
 1198              		.loc 1 1033 0
 1199 009c FFF7FEFF 		bl	vPortYieldFromISR
 1200              	.L51:
1034:FreeRTOS/Source/tasks.c **** 					}
1035:FreeRTOS/Source/tasks.c **** 				}
1036:FreeRTOS/Source/tasks.c **** 			}
1037:FreeRTOS/Source/tasks.c **** 			taskEXIT_CRITICAL();
 1201              		.loc 1 1037 0
 1202 00a0 FFF7FEFF 		bl	vPortExitCritical
 1203              	.L49:
1038:FreeRTOS/Source/tasks.c **** 		}
1039:FreeRTOS/Source/tasks.c **** 	}
 1204              		.loc 1 1039 0
 1205 00a4 07F11007 		add	r7, r7, #16
 1206 00a8 BD46     		mov	sp, r7
 1207 00aa 80BD     		pop	{r7, pc}
 1208              		.cfi_endproc
 1209              	.LFE118:
 1211              		.section	.text.xTaskResumeFromISR,"ax",%progbits
 1212              		.align	2
 1213              		.global	xTaskResumeFromISR
 1214              		.thumb
 1215              		.thumb_func
 1217              	xTaskResumeFromISR:
 1218              	.LFB119:
1040:FreeRTOS/Source/tasks.c **** 
1041:FreeRTOS/Source/tasks.c **** #endif
1042:FreeRTOS/Source/tasks.c **** 
1043:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
1044:FreeRTOS/Source/tasks.c **** 
1045:FreeRTOS/Source/tasks.c **** #if ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) )
1046:FreeRTOS/Source/tasks.c **** 
1047:FreeRTOS/Source/tasks.c **** 	portBASE_TYPE xTaskResumeFromISR( xTaskHandle pxTaskToResume )
1048:FreeRTOS/Source/tasks.c **** 	{
 1219              		.loc 1 1048 0
 1220              		.cfi_startproc
 1221              		@ args = 0, pretend = 0, frame = 16
 1222              		@ frame_needed = 1, uses_anonymous_args = 0
 1223 0000 80B5     		push	{r7, lr}
 1224              	.LCFI27:
 1225              		.cfi_def_cfa_offset 8
 1226              		.cfi_offset 14, -4
 1227              		.cfi_offset 7, -8
 1228 0002 84B0     		sub	sp, sp, #16
 1229              	.LCFI28:
 1230              		.cfi_def_cfa_offset 24
 1231 0004 00AF     		add	r7, sp, #0
 1232              	.LCFI29:
 1233              		.cfi_def_cfa_register 7
 1234 0006 7860     		str	r0, [r7, #4]
1049:FreeRTOS/Source/tasks.c **** 	portBASE_TYPE xYieldRequired = pdFALSE;
 1235              		.loc 1 1049 0
 1236 0008 4FF00003 		mov	r3, #0
 1237 000c FB60     		str	r3, [r7, #12]
1050:FreeRTOS/Source/tasks.c **** 	tskTCB *pxTCB;
1051:FreeRTOS/Source/tasks.c **** 
1052:FreeRTOS/Source/tasks.c **** 		configASSERT( pxTaskToResume );
1053:FreeRTOS/Source/tasks.c **** 
1054:FreeRTOS/Source/tasks.c **** 		pxTCB = ( tskTCB * ) pxTaskToResume;
 1238              		.loc 1 1054 0
 1239 000e 7B68     		ldr	r3, [r7, #4]
 1240 0010 BB60     		str	r3, [r7, #8]
1055:FreeRTOS/Source/tasks.c **** 
1056:FreeRTOS/Source/tasks.c **** 		if( xTaskIsTaskSuspended( pxTCB ) == pdTRUE )
 1241              		.loc 1 1056 0
 1242 0012 B868     		ldr	r0, [r7, #8]
 1243 0014 FFF7FEFF 		bl	xTaskIsTaskSuspended
 1244 0018 0346     		mov	r3, r0
 1245 001a 012B     		cmp	r3, #1
 1246 001c 49D1     		bne	.L54
1057:FreeRTOS/Source/tasks.c **** 		{
1058:FreeRTOS/Source/tasks.c **** 			traceTASK_RESUME_FROM_ISR( pxTCB );
1059:FreeRTOS/Source/tasks.c **** 
1060:FreeRTOS/Source/tasks.c **** 			if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
 1247              		.loc 1 1060 0
 1248 001e 40F20003 		movw	r3, #:lower16:uxSchedulerSuspended
 1249 0022 C0F20003 		movt	r3, #:upper16:uxSchedulerSuspended
 1250 0026 1B68     		ldr	r3, [r3, #0]
 1251 0028 002B     		cmp	r3, #0
 1252 002a 38D1     		bne	.L55
1061:FreeRTOS/Source/tasks.c **** 			{
1062:FreeRTOS/Source/tasks.c **** 				xYieldRequired = ( pxTCB->uxPriority >= pxCurrentTCB->uxPriority );
 1253              		.loc 1 1062 0
 1254 002c BB68     		ldr	r3, [r7, #8]
 1255 002e DA6A     		ldr	r2, [r3, #44]
 1256 0030 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 1257 0034 C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 1258 0038 1B68     		ldr	r3, [r3, #0]
 1259 003a DB6A     		ldr	r3, [r3, #44]
 1260 003c 9A42     		cmp	r2, r3
 1261 003e 34BF     		ite	cc
 1262 0040 0023     		movcc	r3, #0
 1263 0042 0123     		movcs	r3, #1
 1264 0044 FB60     		str	r3, [r7, #12]
1063:FreeRTOS/Source/tasks.c **** 				vListRemove(  &( pxTCB->xGenericListItem ) );
 1265              		.loc 1 1063 0
 1266 0046 BB68     		ldr	r3, [r7, #8]
 1267 0048 03F10403 		add	r3, r3, #4
 1268 004c 1846     		mov	r0, r3
 1269 004e FFF7FEFF 		bl	vListRemove
1064:FreeRTOS/Source/tasks.c **** 				prvAddTaskToReadyQueue( pxTCB );
 1270              		.loc 1 1064 0
 1271 0052 BB68     		ldr	r3, [r7, #8]
 1272 0054 DA6A     		ldr	r2, [r3, #44]
 1273 0056 40F20003 		movw	r3, #:lower16:uxTopReadyPriority
 1274 005a C0F20003 		movt	r3, #:upper16:uxTopReadyPriority
 1275 005e 1B68     		ldr	r3, [r3, #0]
 1276 0060 9A42     		cmp	r2, r3
 1277 0062 06D9     		bls	.L56
 1278              		.loc 1 1064 0 is_stmt 0 discriminator 1
 1279 0064 BB68     		ldr	r3, [r7, #8]
 1280 0066 DA6A     		ldr	r2, [r3, #44]
 1281 0068 40F20003 		movw	r3, #:lower16:uxTopReadyPriority
 1282 006c C0F20003 		movt	r3, #:upper16:uxTopReadyPriority
 1283 0070 1A60     		str	r2, [r3, #0]
 1284              	.L56:
 1285              		.loc 1 1064 0 discriminator 2
 1286 0072 BB68     		ldr	r3, [r7, #8]
 1287 0074 DA6A     		ldr	r2, [r3, #44]
 1288 0076 1346     		mov	r3, r2
 1289 0078 4FEA8303 		lsl	r3, r3, #2
 1290 007c 9B18     		adds	r3, r3, r2
 1291 007e 4FEA8303 		lsl	r3, r3, #2
 1292 0082 1A46     		mov	r2, r3
 1293 0084 40F20003 		movw	r3, #:lower16:pxReadyTasksLists
 1294 0088 C0F20003 		movt	r3, #:upper16:pxReadyTasksLists
 1295 008c D218     		adds	r2, r2, r3
 1296 008e BB68     		ldr	r3, [r7, #8]
 1297 0090 03F10403 		add	r3, r3, #4
 1298 0094 1046     		mov	r0, r2
 1299 0096 1946     		mov	r1, r3
 1300 0098 FFF7FEFF 		bl	vListInsertEnd
 1301 009c 09E0     		b	.L54
 1302              	.L55:
1065:FreeRTOS/Source/tasks.c **** 			}
1066:FreeRTOS/Source/tasks.c **** 			else
1067:FreeRTOS/Source/tasks.c **** 			{
1068:FreeRTOS/Source/tasks.c **** 				/* We cannot access the delayed or ready lists, so will hold this
1069:FreeRTOS/Source/tasks.c **** 				task pending until the scheduler is resumed, at which point a
1070:FreeRTOS/Source/tasks.c **** 				yield will be performed if necessary. */
1071:FreeRTOS/Source/tasks.c **** 				vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
 1303              		.loc 1 1071 0 is_stmt 1
 1304 009e BB68     		ldr	r3, [r7, #8]
 1305 00a0 03F11803 		add	r3, r3, #24
 1306 00a4 40F20000 		movw	r0, #:lower16:xPendingReadyList
 1307 00a8 C0F20000 		movt	r0, #:upper16:xPendingReadyList
 1308 00ac 1946     		mov	r1, r3
 1309 00ae FFF7FEFF 		bl	vListInsertEnd
 1310              	.L54:
1072:FreeRTOS/Source/tasks.c **** 			}
1073:FreeRTOS/Source/tasks.c **** 		}
1074:FreeRTOS/Source/tasks.c **** 
1075:FreeRTOS/Source/tasks.c **** 		return xYieldRequired;
 1311              		.loc 1 1075 0
 1312 00b2 FB68     		ldr	r3, [r7, #12]
1076:FreeRTOS/Source/tasks.c **** 	}
 1313              		.loc 1 1076 0
 1314 00b4 1846     		mov	r0, r3
 1315 00b6 07F11007 		add	r7, r7, #16
 1316 00ba BD46     		mov	sp, r7
 1317 00bc 80BD     		pop	{r7, pc}
 1318              		.cfi_endproc
 1319              	.LFE119:
 1321 00be 00BF     		.section	.rodata
 1322              		.align	2
 1323              	.LC0:
 1324 0000 49444C45 		.ascii	"IDLE\000"
 1324      00
 1325              		.section	.text.vTaskStartScheduler,"ax",%progbits
 1326              		.align	2
 1327              		.global	vTaskStartScheduler
 1328              		.thumb
 1329              		.thumb_func
 1331              	vTaskStartScheduler:
 1332              	.LFB120:
1077:FreeRTOS/Source/tasks.c **** 
1078:FreeRTOS/Source/tasks.c **** #endif
1079:FreeRTOS/Source/tasks.c **** 
1080:FreeRTOS/Source/tasks.c **** 
1081:FreeRTOS/Source/tasks.c **** 
1082:FreeRTOS/Source/tasks.c **** 
1083:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------
1084:FreeRTOS/Source/tasks.c ****  * PUBLIC SCHEDULER CONTROL documented in task.h
1085:FreeRTOS/Source/tasks.c ****  *----------------------------------------------------------*/
1086:FreeRTOS/Source/tasks.c **** 
1087:FreeRTOS/Source/tasks.c **** 
1088:FreeRTOS/Source/tasks.c **** void vTaskStartScheduler( void )
1089:FreeRTOS/Source/tasks.c **** {
 1333              		.loc 1 1089 0
 1334              		.cfi_startproc
 1335              		@ args = 0, pretend = 0, frame = 8
 1336              		@ frame_needed = 1, uses_anonymous_args = 0
 1337 0000 80B5     		push	{r7, lr}
 1338              	.LCFI30:
 1339              		.cfi_def_cfa_offset 8
 1340              		.cfi_offset 14, -4
 1341              		.cfi_offset 7, -8
 1342 0002 86B0     		sub	sp, sp, #24
 1343              	.LCFI31:
 1344              		.cfi_def_cfa_offset 32
 1345 0004 04AF     		add	r7, sp, #16
 1346              	.LCFI32:
 1347              		.cfi_def_cfa 7, 16
1090:FreeRTOS/Source/tasks.c **** portBASE_TYPE xReturn;
1091:FreeRTOS/Source/tasks.c **** 
1092:FreeRTOS/Source/tasks.c **** 	/* Add the idle task at the lowest priority. */
1093:FreeRTOS/Source/tasks.c **** 	#if ( INCLUDE_xTaskGetIdleTaskHandle == 1 )
1094:FreeRTOS/Source/tasks.c **** 	{
1095:FreeRTOS/Source/tasks.c **** 		/* Create the idle task, storing its handle in xIdleTaskHandle so it can
1096:FreeRTOS/Source/tasks.c **** 		be returned by the xTaskGetIdleTaskHandle() function. */
1097:FreeRTOS/Source/tasks.c **** 		xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL
 1348              		.loc 1 1097 0
 1349 0006 4FF00003 		mov	r3, #0
 1350 000a 0093     		str	r3, [sp, #0]
 1351 000c 40F20003 		movw	r3, #:lower16:xIdleTaskHandle
 1352 0010 C0F20003 		movt	r3, #:upper16:xIdleTaskHandle
 1353 0014 0193     		str	r3, [sp, #4]
 1354 0016 4FF00003 		mov	r3, #0
 1355 001a 0293     		str	r3, [sp, #8]
 1356 001c 4FF00003 		mov	r3, #0
 1357 0020 0393     		str	r3, [sp, #12]
 1358 0022 40F20000 		movw	r0, #:lower16:prvIdleTask
 1359 0026 C0F20000 		movt	r0, #:upper16:prvIdleTask
 1360 002a 40F20001 		movw	r1, #:lower16:.LC0
 1361 002e C0F20001 		movt	r1, #:upper16:.LC0
 1362 0032 4FF48072 		mov	r2, #256
 1363 0036 4FF00003 		mov	r3, #0
 1364 003a FFF7FEFF 		bl	xTaskGenericCreate
 1365 003e 7860     		str	r0, [r7, #4]
1098:FreeRTOS/Source/tasks.c **** 	}
1099:FreeRTOS/Source/tasks.c **** 	#else
1100:FreeRTOS/Source/tasks.c **** 	{
1101:FreeRTOS/Source/tasks.c **** 		/* Create the idle task without storing its handle. */
1102:FreeRTOS/Source/tasks.c **** 		xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL
1103:FreeRTOS/Source/tasks.c **** 	}
1104:FreeRTOS/Source/tasks.c **** 	#endif
1105:FreeRTOS/Source/tasks.c **** 
1106:FreeRTOS/Source/tasks.c **** 	#if ( configUSE_TIMERS == 1 )
1107:FreeRTOS/Source/tasks.c **** 	{
1108:FreeRTOS/Source/tasks.c **** 		if( xReturn == pdPASS )
1109:FreeRTOS/Source/tasks.c **** 		{
1110:FreeRTOS/Source/tasks.c **** 			xReturn = xTimerCreateTimerTask();
1111:FreeRTOS/Source/tasks.c **** 		}
1112:FreeRTOS/Source/tasks.c **** 	}
1113:FreeRTOS/Source/tasks.c **** 	#endif
1114:FreeRTOS/Source/tasks.c **** 
1115:FreeRTOS/Source/tasks.c **** 	if( xReturn == pdPASS )
 1366              		.loc 1 1115 0
 1367 0040 7B68     		ldr	r3, [r7, #4]
 1368 0042 012B     		cmp	r3, #1
 1369 0044 15D1     		bne	.L57
1116:FreeRTOS/Source/tasks.c **** 	{
1117:FreeRTOS/Source/tasks.c **** 		/* Interrupts are turned off here, to ensure a tick does not occur
1118:FreeRTOS/Source/tasks.c **** 		before or during the call to xPortStartScheduler().  The stacks of
1119:FreeRTOS/Source/tasks.c **** 		the created tasks contain a status word with interrupts switched on
1120:FreeRTOS/Source/tasks.c **** 		so interrupts will automatically get re-enabled when the first task
1121:FreeRTOS/Source/tasks.c **** 		starts to run.
1122:FreeRTOS/Source/tasks.c **** 
1123:FreeRTOS/Source/tasks.c **** 		STEPPING THROUGH HERE USING A DEBUGGER CAN CAUSE BIG PROBLEMS IF THE
1124:FreeRTOS/Source/tasks.c **** 		DEBUGGER ALLOWS INTERRUPTS TO BE PROCESSED. */
1125:FreeRTOS/Source/tasks.c **** 		portDISABLE_INTERRUPTS();
 1370              		.loc 1 1125 0
 1371              	@ 1125 "FreeRTOS/Source/tasks.c" 1
 1372 0046 4FF0BF00 			mov r0, #191								
 1373 004a 80F31188 		msr basepri, r0							
 1374              	
 1375              	@ 0 "" 2
1126:FreeRTOS/Source/tasks.c **** 
1127:FreeRTOS/Source/tasks.c **** 		xSchedulerRunning = pdTRUE;
 1376              		.loc 1 1127 0
 1377              		.thumb
 1378 004e 40F20003 		movw	r3, #:lower16:xSchedulerRunning
 1379 0052 C0F20003 		movt	r3, #:upper16:xSchedulerRunning
 1380 0056 4FF00102 		mov	r2, #1
 1381 005a 1A60     		str	r2, [r3, #0]
1128:FreeRTOS/Source/tasks.c **** 		xTickCount = ( portTickType ) 0U;
 1382              		.loc 1 1128 0
 1383 005c 40F20003 		movw	r3, #:lower16:xTickCount
 1384 0060 C0F20003 		movt	r3, #:upper16:xTickCount
 1385 0064 4FF00002 		mov	r2, #0
 1386 0068 1A60     		str	r2, [r3, #0]
1129:FreeRTOS/Source/tasks.c **** 
1130:FreeRTOS/Source/tasks.c **** 		/* If configGENERATE_RUN_TIME_STATS is defined then the following
1131:FreeRTOS/Source/tasks.c **** 		macro must be defined to configure the timer/counter used to generate
1132:FreeRTOS/Source/tasks.c **** 		the run time counter time base. */
1133:FreeRTOS/Source/tasks.c **** 		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();
 1387              		.loc 1 1133 0
 1388 006a FFF7FEFF 		bl	init_us_timer
1134:FreeRTOS/Source/tasks.c **** 		
1135:FreeRTOS/Source/tasks.c **** 		/* Setting up the timer tick is hardware specific and thus in the
1136:FreeRTOS/Source/tasks.c **** 		portable interface. */
1137:FreeRTOS/Source/tasks.c **** 		if( xPortStartScheduler() != pdFALSE )
 1389              		.loc 1 1137 0
 1390 006e FFF7FEFF 		bl	xPortStartScheduler
 1391              	.L57:
1138:FreeRTOS/Source/tasks.c **** 		{
1139:FreeRTOS/Source/tasks.c **** 			/* Should not reach here as if the scheduler is running the
1140:FreeRTOS/Source/tasks.c **** 			function will not return. */
1141:FreeRTOS/Source/tasks.c **** 		}
1142:FreeRTOS/Source/tasks.c **** 		else
1143:FreeRTOS/Source/tasks.c **** 		{
1144:FreeRTOS/Source/tasks.c **** 			/* Should only reach here if a task calls xTaskEndScheduler(). */
1145:FreeRTOS/Source/tasks.c **** 		}
1146:FreeRTOS/Source/tasks.c **** 	}
1147:FreeRTOS/Source/tasks.c **** 
1148:FreeRTOS/Source/tasks.c **** 	/* This line will only be reached if the kernel could not be started. */
1149:FreeRTOS/Source/tasks.c **** 	configASSERT( xReturn );
1150:FreeRTOS/Source/tasks.c **** }
 1392              		.loc 1 1150 0
 1393 0072 07F10807 		add	r7, r7, #8
 1394 0076 BD46     		mov	sp, r7
 1395 0078 80BD     		pop	{r7, pc}
 1396              		.cfi_endproc
 1397              	.LFE120:
 1399 007a 00BF     		.section	.text.vTaskEndScheduler,"ax",%progbits
 1400              		.align	2
 1401              		.global	vTaskEndScheduler
 1402              		.thumb
 1403              		.thumb_func
 1405              	vTaskEndScheduler:
 1406              	.LFB121:
1151:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
1152:FreeRTOS/Source/tasks.c **** 
1153:FreeRTOS/Source/tasks.c **** void vTaskEndScheduler( void )
1154:FreeRTOS/Source/tasks.c **** {
 1407              		.loc 1 1154 0
 1408              		.cfi_startproc
 1409              		@ args = 0, pretend = 0, frame = 0
 1410              		@ frame_needed = 1, uses_anonymous_args = 0
 1411 0000 80B5     		push	{r7, lr}
 1412              	.LCFI33:
 1413              		.cfi_def_cfa_offset 8
 1414              		.cfi_offset 14, -4
 1415              		.cfi_offset 7, -8
 1416 0002 00AF     		add	r7, sp, #0
 1417              	.LCFI34:
 1418              		.cfi_def_cfa_register 7
1155:FreeRTOS/Source/tasks.c **** 	/* Stop the scheduler interrupts and call the portable scheduler end
1156:FreeRTOS/Source/tasks.c **** 	routine so the original ISRs can be restored if necessary.  The port
1157:FreeRTOS/Source/tasks.c **** 	layer must ensure interrupts enable	bit is left in the correct state. */
1158:FreeRTOS/Source/tasks.c **** 	portDISABLE_INTERRUPTS();
 1419              		.loc 1 1158 0
 1420              	@ 1158 "FreeRTOS/Source/tasks.c" 1
 1421 0004 4FF0BF00 			mov r0, #191								
 1422 0008 80F31188 		msr basepri, r0							
 1423              	
 1424              	@ 0 "" 2
1159:FreeRTOS/Source/tasks.c **** 	xSchedulerRunning = pdFALSE;
 1425              		.loc 1 1159 0
 1426              		.thumb
 1427 000c 40F20003 		movw	r3, #:lower16:xSchedulerRunning
 1428 0010 C0F20003 		movt	r3, #:upper16:xSchedulerRunning
 1429 0014 4FF00002 		mov	r2, #0
 1430 0018 1A60     		str	r2, [r3, #0]
1160:FreeRTOS/Source/tasks.c **** 	vPortEndScheduler();
 1431              		.loc 1 1160 0
 1432 001a FFF7FEFF 		bl	vPortEndScheduler
1161:FreeRTOS/Source/tasks.c **** }
 1433              		.loc 1 1161 0
 1434 001e 80BD     		pop	{r7, pc}
 1435              		.cfi_endproc
 1436              	.LFE121:
 1438              		.section	.text.vTaskSuspendAll,"ax",%progbits
 1439              		.align	2
 1440              		.global	vTaskSuspendAll
 1441              		.thumb
 1442              		.thumb_func
 1444              	vTaskSuspendAll:
 1445              	.LFB122:
1162:FreeRTOS/Source/tasks.c **** /*----------------------------------------------------------*/
1163:FreeRTOS/Source/tasks.c **** 
1164:FreeRTOS/Source/tasks.c **** void vTaskSuspendAll( void )
1165:FreeRTOS/Source/tasks.c **** {
 1446              		.loc 1 1165 0
 1447              		.cfi_startproc
 1448              		@ args = 0, pretend = 0, frame = 0
 1449              		@ frame_needed = 1, uses_anonymous_args = 0
 1450              		@ link register save eliminated.
 1451 0000 80B4     		push	{r7}
 1452              	.LCFI35:
 1453              		.cfi_def_cfa_offset 4
 1454              		.cfi_offset 7, -4
 1455 0002 00AF     		add	r7, sp, #0
 1456              	.LCFI36:
 1457              		.cfi_def_cfa_register 7
1166:FreeRTOS/Source/tasks.c **** 	/* A critical section is not required as the variable is of type
1167:FreeRTOS/Source/tasks.c **** 	portBASE_TYPE. */
1168:FreeRTOS/Source/tasks.c **** 	++uxSchedulerSuspended;
 1458              		.loc 1 1168 0
 1459 0004 40F20003 		movw	r3, #:lower16:uxSchedulerSuspended
 1460 0008 C0F20003 		movt	r3, #:upper16:uxSchedulerSuspended
 1461 000c 1B68     		ldr	r3, [r3, #0]
 1462 000e 03F10102 		add	r2, r3, #1
 1463 0012 40F20003 		movw	r3, #:lower16:uxSchedulerSuspended
 1464 0016 C0F20003 		movt	r3, #:upper16:uxSchedulerSuspended
 1465 001a 1A60     		str	r2, [r3, #0]
1169:FreeRTOS/Source/tasks.c **** }
 1466              		.loc 1 1169 0
 1467 001c BD46     		mov	sp, r7
 1468 001e 80BC     		pop	{r7}
 1469 0020 7047     		bx	lr
 1470              		.cfi_endproc
 1471              	.LFE122:
 1473 0022 00BF     		.section	.text.xTaskResumeAll,"ax",%progbits
 1474              		.align	2
 1475              		.global	xTaskResumeAll
 1476              		.thumb
 1477              		.thumb_func
 1479              	xTaskResumeAll:
 1480              	.LFB123:
1170:FreeRTOS/Source/tasks.c **** /*----------------------------------------------------------*/
1171:FreeRTOS/Source/tasks.c **** 
1172:FreeRTOS/Source/tasks.c **** signed portBASE_TYPE xTaskResumeAll( void )
1173:FreeRTOS/Source/tasks.c **** {
 1481              		.loc 1 1173 0
 1482              		.cfi_startproc
 1483              		@ args = 0, pretend = 0, frame = 8
 1484              		@ frame_needed = 1, uses_anonymous_args = 0
 1485 0000 90B5     		push	{r4, r7, lr}
 1486              	.LCFI37:
 1487              		.cfi_def_cfa_offset 12
 1488              		.cfi_offset 14, -4
 1489              		.cfi_offset 7, -8
 1490              		.cfi_offset 4, -12
 1491 0002 83B0     		sub	sp, sp, #12
 1492              	.LCFI38:
 1493              		.cfi_def_cfa_offset 24
 1494 0004 00AF     		add	r7, sp, #0
 1495              	.LCFI39:
 1496              		.cfi_def_cfa_register 7
1174:FreeRTOS/Source/tasks.c **** register tskTCB *pxTCB;
1175:FreeRTOS/Source/tasks.c **** signed portBASE_TYPE xAlreadyYielded = pdFALSE;
 1497              		.loc 1 1175 0
 1498 0006 4FF00003 		mov	r3, #0
 1499 000a 7B60     		str	r3, [r7, #4]
1176:FreeRTOS/Source/tasks.c **** 
1177:FreeRTOS/Source/tasks.c **** 	/* If uxSchedulerSuspended is zero then this function does not match a
1178:FreeRTOS/Source/tasks.c **** 	previous call to vTaskSuspendAll(). */
1179:FreeRTOS/Source/tasks.c **** 	configASSERT( uxSchedulerSuspended );
1180:FreeRTOS/Source/tasks.c **** 
1181:FreeRTOS/Source/tasks.c **** 	/* It is possible that an ISR caused a task to be removed from an event
1182:FreeRTOS/Source/tasks.c **** 	list while the scheduler was suspended.  If this was the case then the
1183:FreeRTOS/Source/tasks.c **** 	removed task will have been added to the xPendingReadyList.  Once the
1184:FreeRTOS/Source/tasks.c **** 	scheduler has been resumed it is safe to move all the pending ready
1185:FreeRTOS/Source/tasks.c **** 	tasks from this list into their appropriate ready list. */
1186:FreeRTOS/Source/tasks.c **** 	taskENTER_CRITICAL();
 1500              		.loc 1 1186 0
 1501 000c FFF7FEFF 		bl	vPortEnterCritical
1187:FreeRTOS/Source/tasks.c **** 	{
1188:FreeRTOS/Source/tasks.c **** 		--uxSchedulerSuspended;
 1502              		.loc 1 1188 0
 1503 0010 40F20003 		movw	r3, #:lower16:uxSchedulerSuspended
 1504 0014 C0F20003 		movt	r3, #:upper16:uxSchedulerSuspended
 1505 0018 1B68     		ldr	r3, [r3, #0]
 1506 001a 03F1FF32 		add	r2, r3, #-1
 1507 001e 40F20003 		movw	r3, #:lower16:uxSchedulerSuspended
 1508 0022 C0F20003 		movt	r3, #:upper16:uxSchedulerSuspended
 1509 0026 1A60     		str	r2, [r3, #0]
1189:FreeRTOS/Source/tasks.c **** 
1190:FreeRTOS/Source/tasks.c **** 		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
 1510              		.loc 1 1190 0
 1511 0028 40F20003 		movw	r3, #:lower16:uxSchedulerSuspended
 1512 002c C0F20003 		movt	r3, #:upper16:uxSchedulerSuspended
 1513 0030 1B68     		ldr	r3, [r3, #0]
 1514 0032 002B     		cmp	r3, #0
 1515 0034 40F08580 		bne	.L62
1191:FreeRTOS/Source/tasks.c **** 		{
1192:FreeRTOS/Source/tasks.c **** 			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0U )
 1516              		.loc 1 1192 0
 1517 0038 40F20003 		movw	r3, #:lower16:uxCurrentNumberOfTasks
 1518 003c C0F20003 		movt	r3, #:upper16:uxCurrentNumberOfTasks
 1519 0040 1B68     		ldr	r3, [r3, #0]
 1520 0042 002B     		cmp	r3, #0
 1521 0044 7DD0     		beq	.L62
 1522              	.LBB3:
1193:FreeRTOS/Source/tasks.c **** 			{
1194:FreeRTOS/Source/tasks.c **** 				portBASE_TYPE xYieldRequired = pdFALSE;
 1523              		.loc 1 1194 0
 1524 0046 4FF00003 		mov	r3, #0
 1525 004a 3B60     		str	r3, [r7, #0]
1195:FreeRTOS/Source/tasks.c **** 
1196:FreeRTOS/Source/tasks.c **** 				/* Move any readied tasks from the pending list into the
1197:FreeRTOS/Source/tasks.c **** 				appropriate ready list. */
1198:FreeRTOS/Source/tasks.c **** 				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
 1526              		.loc 1 1198 0
 1527 004c 3CE0     		b	.L63
 1528              	.L65:
1199:FreeRTOS/Source/tasks.c **** 				{
1200:FreeRTOS/Source/tasks.c **** 					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
 1529              		.loc 1 1200 0
 1530 004e 40F20003 		movw	r3, #:lower16:xPendingReadyList
 1531 0052 C0F20003 		movt	r3, #:upper16:xPendingReadyList
 1532 0056 DB68     		ldr	r3, [r3, #12]
 1533 0058 DC68     		ldr	r4, [r3, #12]
1201:FreeRTOS/Source/tasks.c **** 					vListRemove( &( pxTCB->xEventListItem ) );
 1534              		.loc 1 1201 0
 1535 005a 04F11803 		add	r3, r4, #24
 1536 005e 1846     		mov	r0, r3
 1537 0060 FFF7FEFF 		bl	vListRemove
1202:FreeRTOS/Source/tasks.c **** 					vListRemove( &( pxTCB->xGenericListItem ) );
 1538              		.loc 1 1202 0
 1539 0064 04F10403 		add	r3, r4, #4
 1540 0068 1846     		mov	r0, r3
 1541 006a FFF7FEFF 		bl	vListRemove
1203:FreeRTOS/Source/tasks.c **** 					prvAddTaskToReadyQueue( pxTCB );
 1542              		.loc 1 1203 0
 1543 006e E26A     		ldr	r2, [r4, #44]
 1544 0070 40F20003 		movw	r3, #:lower16:uxTopReadyPriority
 1545 0074 C0F20003 		movt	r3, #:upper16:uxTopReadyPriority
 1546 0078 1B68     		ldr	r3, [r3, #0]
 1547 007a 9A42     		cmp	r2, r3
 1548 007c 05D9     		bls	.L64
 1549              		.loc 1 1203 0 is_stmt 0 discriminator 1
 1550 007e E26A     		ldr	r2, [r4, #44]
 1551 0080 40F20003 		movw	r3, #:lower16:uxTopReadyPriority
 1552 0084 C0F20003 		movt	r3, #:upper16:uxTopReadyPriority
 1553 0088 1A60     		str	r2, [r3, #0]
 1554              	.L64:
 1555              		.loc 1 1203 0 discriminator 2
 1556 008a E26A     		ldr	r2, [r4, #44]
 1557 008c 1346     		mov	r3, r2
 1558 008e 4FEA8303 		lsl	r3, r3, #2
 1559 0092 9B18     		adds	r3, r3, r2
 1560 0094 4FEA8303 		lsl	r3, r3, #2
 1561 0098 1A46     		mov	r2, r3
 1562 009a 40F20003 		movw	r3, #:lower16:pxReadyTasksLists
 1563 009e C0F20003 		movt	r3, #:upper16:pxReadyTasksLists
 1564 00a2 D218     		adds	r2, r2, r3
 1565 00a4 04F10403 		add	r3, r4, #4
 1566 00a8 1046     		mov	r0, r2
 1567 00aa 1946     		mov	r1, r3
 1568 00ac FFF7FEFF 		bl	vListInsertEnd
1204:FreeRTOS/Source/tasks.c **** 
1205:FreeRTOS/Source/tasks.c **** 					/* If we have moved a task that has a priority higher than
1206:FreeRTOS/Source/tasks.c **** 					the current task then we should yield. */
1207:FreeRTOS/Source/tasks.c **** 					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 1569              		.loc 1 1207 0 is_stmt 1 discriminator 2
 1570 00b0 E26A     		ldr	r2, [r4, #44]
 1571 00b2 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 1572 00b6 C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 1573 00ba 1B68     		ldr	r3, [r3, #0]
 1574 00bc DB6A     		ldr	r3, [r3, #44]
 1575 00be 9A42     		cmp	r2, r3
 1576 00c0 02D3     		bcc	.L63
1208:FreeRTOS/Source/tasks.c **** 					{
1209:FreeRTOS/Source/tasks.c **** 						xYieldRequired = pdTRUE;
 1577              		.loc 1 1209 0
 1578 00c2 4FF00103 		mov	r3, #1
 1579 00c6 3B60     		str	r3, [r7, #0]
 1580              	.L63:
1198:FreeRTOS/Source/tasks.c **** 				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
 1581              		.loc 1 1198 0 discriminator 1
 1582 00c8 40F20003 		movw	r3, #:lower16:xPendingReadyList
 1583 00cc C0F20003 		movt	r3, #:upper16:xPendingReadyList
 1584 00d0 1B68     		ldr	r3, [r3, #0]
 1585 00d2 002B     		cmp	r3, #0
 1586 00d4 BBD1     		bne	.L65
1210:FreeRTOS/Source/tasks.c **** 					}
1211:FreeRTOS/Source/tasks.c **** 				}
1212:FreeRTOS/Source/tasks.c **** 
1213:FreeRTOS/Source/tasks.c **** 				/* If any ticks occurred while the scheduler was suspended then
1214:FreeRTOS/Source/tasks.c **** 				they should be processed now.  This ensures the tick count does not
1215:FreeRTOS/Source/tasks.c **** 				slip, and that any delayed tasks are resumed at the correct time. */
1216:FreeRTOS/Source/tasks.c **** 				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
 1587              		.loc 1 1216 0
 1588 00d6 40F20003 		movw	r3, #:lower16:uxMissedTicks
 1589 00da C0F20003 		movt	r3, #:upper16:uxMissedTicks
 1590 00de 1B68     		ldr	r3, [r3, #0]
 1591 00e0 002B     		cmp	r3, #0
 1592 00e2 18D0     		beq	.L66
1217:FreeRTOS/Source/tasks.c **** 				{
1218:FreeRTOS/Source/tasks.c **** 					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
 1593              		.loc 1 1218 0
 1594 00e4 0DE0     		b	.L67
 1595              	.L68:
1219:FreeRTOS/Source/tasks.c **** 					{
1220:FreeRTOS/Source/tasks.c **** 						vTaskIncrementTick();
 1596              		.loc 1 1220 0
 1597 00e6 FFF7FEFF 		bl	vTaskIncrementTick
1221:FreeRTOS/Source/tasks.c **** 						--uxMissedTicks;
 1598              		.loc 1 1221 0
 1599 00ea 40F20003 		movw	r3, #:lower16:uxMissedTicks
 1600 00ee C0F20003 		movt	r3, #:upper16:uxMissedTicks
 1601 00f2 1B68     		ldr	r3, [r3, #0]
 1602 00f4 03F1FF32 		add	r2, r3, #-1
 1603 00f8 40F20003 		movw	r3, #:lower16:uxMissedTicks
 1604 00fc C0F20003 		movt	r3, #:upper16:uxMissedTicks
 1605 0100 1A60     		str	r2, [r3, #0]
 1606              	.L67:
1218:FreeRTOS/Source/tasks.c **** 					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
 1607              		.loc 1 1218 0 discriminator 1
 1608 0102 40F20003 		movw	r3, #:lower16:uxMissedTicks
 1609 0106 C0F20003 		movt	r3, #:upper16:uxMissedTicks
 1610 010a 1B68     		ldr	r3, [r3, #0]
 1611 010c 002B     		cmp	r3, #0
 1612 010e EAD1     		bne	.L68
1222:FreeRTOS/Source/tasks.c **** 					}
1223:FreeRTOS/Source/tasks.c **** 
1224:FreeRTOS/Source/tasks.c **** 					/* As we have processed some ticks it is appropriate to yield
1225:FreeRTOS/Source/tasks.c **** 					to ensure the highest priority task that is ready to run is
1226:FreeRTOS/Source/tasks.c **** 					the task actually running. */
1227:FreeRTOS/Source/tasks.c **** 					#if configUSE_PREEMPTION == 1
1228:FreeRTOS/Source/tasks.c **** 					{
1229:FreeRTOS/Source/tasks.c **** 						xYieldRequired = pdTRUE;
 1613              		.loc 1 1229 0
 1614 0110 4FF00103 		mov	r3, #1
 1615 0114 3B60     		str	r3, [r7, #0]
 1616              	.L66:
1230:FreeRTOS/Source/tasks.c **** 					}
1231:FreeRTOS/Source/tasks.c **** 					#endif
1232:FreeRTOS/Source/tasks.c **** 				}
1233:FreeRTOS/Source/tasks.c **** 
1234:FreeRTOS/Source/tasks.c **** 				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
 1617              		.loc 1 1234 0
 1618 0116 3B68     		ldr	r3, [r7, #0]
 1619 0118 012B     		cmp	r3, #1
 1620 011a 06D0     		beq	.L69
 1621              		.loc 1 1234 0 is_stmt 0 discriminator 1
 1622 011c 40F20003 		movw	r3, #:lower16:xMissedYield
 1623 0120 C0F20003 		movt	r3, #:upper16:xMissedYield
 1624 0124 1B68     		ldr	r3, [r3, #0]
 1625 0126 012B     		cmp	r3, #1
 1626 0128 0BD1     		bne	.L62
 1627              	.L69:
1235:FreeRTOS/Source/tasks.c **** 				{
1236:FreeRTOS/Source/tasks.c **** 					xAlreadyYielded = pdTRUE;
 1628              		.loc 1 1236 0 is_stmt 1
 1629 012a 4FF00103 		mov	r3, #1
 1630 012e 7B60     		str	r3, [r7, #4]
1237:FreeRTOS/Source/tasks.c **** 					xMissedYield = pdFALSE;
 1631              		.loc 1 1237 0
 1632 0130 40F20003 		movw	r3, #:lower16:xMissedYield
 1633 0134 C0F20003 		movt	r3, #:upper16:xMissedYield
 1634 0138 4FF00002 		mov	r2, #0
 1635 013c 1A60     		str	r2, [r3, #0]
1238:FreeRTOS/Source/tasks.c **** 					portYIELD_WITHIN_API();
 1636              		.loc 1 1238 0
 1637 013e FFF7FEFF 		bl	vPortYieldFromISR
 1638              	.L62:
 1639              	.LBE3:
1239:FreeRTOS/Source/tasks.c **** 				}
1240:FreeRTOS/Source/tasks.c **** 			}
1241:FreeRTOS/Source/tasks.c **** 		}
1242:FreeRTOS/Source/tasks.c **** 	}
1243:FreeRTOS/Source/tasks.c **** 	taskEXIT_CRITICAL();
 1640              		.loc 1 1243 0
 1641 0142 FFF7FEFF 		bl	vPortExitCritical
1244:FreeRTOS/Source/tasks.c **** 
1245:FreeRTOS/Source/tasks.c **** 	return xAlreadyYielded;
 1642              		.loc 1 1245 0
 1643 0146 7B68     		ldr	r3, [r7, #4]
1246:FreeRTOS/Source/tasks.c **** }
 1644              		.loc 1 1246 0
 1645 0148 1846     		mov	r0, r3
 1646 014a 07F10C07 		add	r7, r7, #12
 1647 014e BD46     		mov	sp, r7
 1648 0150 90BD     		pop	{r4, r7, pc}
 1649              		.cfi_endproc
 1650              	.LFE123:
 1652 0152 00BF     		.section	.text.xTaskGetTickCount,"ax",%progbits
 1653              		.align	2
 1654              		.global	xTaskGetTickCount
 1655              		.thumb
 1656              		.thumb_func
 1658              	xTaskGetTickCount:
 1659              	.LFB124:
1247:FreeRTOS/Source/tasks.c **** 
1248:FreeRTOS/Source/tasks.c **** 
1249:FreeRTOS/Source/tasks.c **** 
1250:FreeRTOS/Source/tasks.c **** 
1251:FreeRTOS/Source/tasks.c **** 
1252:FreeRTOS/Source/tasks.c **** 
1253:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------
1254:FreeRTOS/Source/tasks.c ****  * PUBLIC TASK UTILITIES documented in task.h
1255:FreeRTOS/Source/tasks.c ****  *----------------------------------------------------------*/
1256:FreeRTOS/Source/tasks.c **** 
1257:FreeRTOS/Source/tasks.c **** 
1258:FreeRTOS/Source/tasks.c **** 
1259:FreeRTOS/Source/tasks.c **** portTickType xTaskGetTickCount( void )
1260:FreeRTOS/Source/tasks.c **** {
 1660              		.loc 1 1260 0
 1661              		.cfi_startproc
 1662              		@ args = 0, pretend = 0, frame = 8
 1663              		@ frame_needed = 1, uses_anonymous_args = 0
 1664 0000 80B5     		push	{r7, lr}
 1665              	.LCFI40:
 1666              		.cfi_def_cfa_offset 8
 1667              		.cfi_offset 14, -4
 1668              		.cfi_offset 7, -8
 1669 0002 82B0     		sub	sp, sp, #8
 1670              	.LCFI41:
 1671              		.cfi_def_cfa_offset 16
 1672 0004 00AF     		add	r7, sp, #0
 1673              	.LCFI42:
 1674              		.cfi_def_cfa_register 7
1261:FreeRTOS/Source/tasks.c **** portTickType xTicks;
1262:FreeRTOS/Source/tasks.c **** 
1263:FreeRTOS/Source/tasks.c **** 	/* Critical section required if running on a 16 bit processor. */
1264:FreeRTOS/Source/tasks.c **** 	taskENTER_CRITICAL();
 1675              		.loc 1 1264 0
 1676 0006 FFF7FEFF 		bl	vPortEnterCritical
1265:FreeRTOS/Source/tasks.c **** 	{
1266:FreeRTOS/Source/tasks.c **** 		xTicks = xTickCount;
 1677              		.loc 1 1266 0
 1678 000a 40F20003 		movw	r3, #:lower16:xTickCount
 1679 000e C0F20003 		movt	r3, #:upper16:xTickCount
 1680 0012 1B68     		ldr	r3, [r3, #0]
 1681 0014 7B60     		str	r3, [r7, #4]
1267:FreeRTOS/Source/tasks.c **** 	}
1268:FreeRTOS/Source/tasks.c **** 	taskEXIT_CRITICAL();
 1682              		.loc 1 1268 0
 1683 0016 FFF7FEFF 		bl	vPortExitCritical
1269:FreeRTOS/Source/tasks.c **** 
1270:FreeRTOS/Source/tasks.c **** 	return xTicks;
 1684              		.loc 1 1270 0
 1685 001a 7B68     		ldr	r3, [r7, #4]
1271:FreeRTOS/Source/tasks.c **** }
 1686              		.loc 1 1271 0
 1687 001c 1846     		mov	r0, r3
 1688 001e 07F10807 		add	r7, r7, #8
 1689 0022 BD46     		mov	sp, r7
 1690 0024 80BD     		pop	{r7, pc}
 1691              		.cfi_endproc
 1692              	.LFE124:
 1694 0026 00BF     		.section	.text.xTaskGetTickCountFromISR,"ax",%progbits
 1695              		.align	2
 1696              		.global	xTaskGetTickCountFromISR
 1697              		.thumb
 1698              		.thumb_func
 1700              	xTaskGetTickCountFromISR:
 1701              	.LFB125:
1272:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
1273:FreeRTOS/Source/tasks.c **** 
1274:FreeRTOS/Source/tasks.c **** portTickType xTaskGetTickCountFromISR( void )
1275:FreeRTOS/Source/tasks.c **** {
 1702              		.loc 1 1275 0
 1703              		.cfi_startproc
 1704              		@ args = 0, pretend = 0, frame = 8
 1705              		@ frame_needed = 1, uses_anonymous_args = 0
 1706              		@ link register save eliminated.
 1707 0000 80B4     		push	{r7}
 1708              	.LCFI43:
 1709              		.cfi_def_cfa_offset 4
 1710              		.cfi_offset 7, -4
 1711 0002 83B0     		sub	sp, sp, #12
 1712              	.LCFI44:
 1713              		.cfi_def_cfa_offset 16
 1714 0004 00AF     		add	r7, sp, #0
 1715              	.LCFI45:
 1716              		.cfi_def_cfa_register 7
1276:FreeRTOS/Source/tasks.c **** portTickType xReturn;
1277:FreeRTOS/Source/tasks.c **** unsigned portBASE_TYPE uxSavedInterruptStatus;
1278:FreeRTOS/Source/tasks.c **** 
1279:FreeRTOS/Source/tasks.c **** 	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 1717              		.loc 1 1279 0
 1718 0006 4FF00003 		mov	r3, #0
 1719 000a 7B60     		str	r3, [r7, #4]
 1720              	@ 1279 "FreeRTOS/Source/tasks.c" 1
 1721 000c 4FF0BF00 			mov r0, #191								
 1722 0010 80F31188 		msr basepri, r0							
 1723              	
 1724              	@ 0 "" 2
1280:FreeRTOS/Source/tasks.c **** 	xReturn = xTickCount;
 1725              		.loc 1 1280 0
 1726              		.thumb
 1727 0014 40F20003 		movw	r3, #:lower16:xTickCount
 1728 0018 C0F20003 		movt	r3, #:upper16:xTickCount
 1729 001c 1B68     		ldr	r3, [r3, #0]
 1730 001e 3B60     		str	r3, [r7, #0]
1281:FreeRTOS/Source/tasks.c **** 	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
 1731              		.loc 1 1281 0
 1732              	@ 1281 "FreeRTOS/Source/tasks.c" 1
 1733 0020 4FF00000 			mov r0, #0					
 1734 0024 80F31188 		msr basepri, r0				
 1735              	
 1736              	@ 0 "" 2
1282:FreeRTOS/Source/tasks.c **** 
1283:FreeRTOS/Source/tasks.c **** 	return xReturn;
 1737              		.loc 1 1283 0
 1738              		.thumb
 1739 0028 3B68     		ldr	r3, [r7, #0]
1284:FreeRTOS/Source/tasks.c **** }
 1740              		.loc 1 1284 0
 1741 002a 1846     		mov	r0, r3
 1742 002c 07F10C07 		add	r7, r7, #12
 1743 0030 BD46     		mov	sp, r7
 1744 0032 80BC     		pop	{r7}
 1745 0034 7047     		bx	lr
 1746              		.cfi_endproc
 1747              	.LFE125:
 1749 0036 00BF     		.section	.text.uxTaskGetNumberOfTasks,"ax",%progbits
 1750              		.align	2
 1751              		.global	uxTaskGetNumberOfTasks
 1752              		.thumb
 1753              		.thumb_func
 1755              	uxTaskGetNumberOfTasks:
 1756              	.LFB126:
1285:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
1286:FreeRTOS/Source/tasks.c **** 
1287:FreeRTOS/Source/tasks.c **** unsigned portBASE_TYPE uxTaskGetNumberOfTasks( void )
1288:FreeRTOS/Source/tasks.c **** {
 1757              		.loc 1 1288 0
 1758              		.cfi_startproc
 1759              		@ args = 0, pretend = 0, frame = 0
 1760              		@ frame_needed = 1, uses_anonymous_args = 0
 1761              		@ link register save eliminated.
 1762 0000 80B4     		push	{r7}
 1763              	.LCFI46:
 1764              		.cfi_def_cfa_offset 4
 1765              		.cfi_offset 7, -4
 1766 0002 00AF     		add	r7, sp, #0
 1767              	.LCFI47:
 1768              		.cfi_def_cfa_register 7
1289:FreeRTOS/Source/tasks.c **** 	/* A critical section is not required because the variables are of type
1290:FreeRTOS/Source/tasks.c **** 	portBASE_TYPE. */
1291:FreeRTOS/Source/tasks.c **** 	return uxCurrentNumberOfTasks;
 1769              		.loc 1 1291 0
 1770 0004 40F20003 		movw	r3, #:lower16:uxCurrentNumberOfTasks
 1771 0008 C0F20003 		movt	r3, #:upper16:uxCurrentNumberOfTasks
 1772 000c 1B68     		ldr	r3, [r3, #0]
1292:FreeRTOS/Source/tasks.c **** }
 1773              		.loc 1 1292 0
 1774 000e 1846     		mov	r0, r3
 1775 0010 BD46     		mov	sp, r7
 1776 0012 80BC     		pop	{r7}
 1777 0014 7047     		bx	lr
 1778              		.cfi_endproc
 1779              	.LFE126:
 1781 0016 00BF     		.section	.rodata
 1782 0005 000000   		.align	2
 1783              	.LC1:
 1784 0008 0D0A00   		.ascii	"\015\012\000"
 1785              		.section	.text.vTaskGetRunTimeStats,"ax",%progbits
 1786              		.align	2
 1787              		.global	vTaskGetRunTimeStats
 1788              		.thumb
 1789              		.thumb_func
 1791              	vTaskGetRunTimeStats:
 1792              	.LFB127:
1293:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
1294:FreeRTOS/Source/tasks.c **** 
1295:FreeRTOS/Source/tasks.c **** #if ( INCLUDE_pcTaskGetTaskName == 1 )
1296:FreeRTOS/Source/tasks.c **** 
1297:FreeRTOS/Source/tasks.c **** 	signed char *pcTaskGetTaskName( xTaskHandle xTaskToQuery )
1298:FreeRTOS/Source/tasks.c **** 	{
1299:FreeRTOS/Source/tasks.c **** 	tskTCB *pxTCB;
1300:FreeRTOS/Source/tasks.c **** 
1301:FreeRTOS/Source/tasks.c **** 		/* If null is passed in here then the name of the calling task is being queried. */
1302:FreeRTOS/Source/tasks.c **** 		pxTCB = prvGetTCBFromHandle( xTaskToQuery );
1303:FreeRTOS/Source/tasks.c **** 		configASSERT( pxTCB );
1304:FreeRTOS/Source/tasks.c **** 		return &( pxTCB->pcTaskName[ 0 ] );
1305:FreeRTOS/Source/tasks.c **** 	}
1306:FreeRTOS/Source/tasks.c **** 
1307:FreeRTOS/Source/tasks.c **** #endif
1308:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
1309:FreeRTOS/Source/tasks.c **** 
1310:FreeRTOS/Source/tasks.c **** #if ( configUSE_TRACE_FACILITY == 1 )
1311:FreeRTOS/Source/tasks.c **** 
1312:FreeRTOS/Source/tasks.c **** 	void vTaskList( signed char *pcWriteBuffer )
1313:FreeRTOS/Source/tasks.c **** 	{
1314:FreeRTOS/Source/tasks.c **** 	unsigned portBASE_TYPE uxQueue;
1315:FreeRTOS/Source/tasks.c **** 
1316:FreeRTOS/Source/tasks.c **** 		/* This is a VERY costly function that should be used for debug only.
1317:FreeRTOS/Source/tasks.c **** 		It leaves interrupts disabled for a LONG time. */
1318:FreeRTOS/Source/tasks.c **** 
1319:FreeRTOS/Source/tasks.c **** 		vTaskSuspendAll();
1320:FreeRTOS/Source/tasks.c **** 		{
1321:FreeRTOS/Source/tasks.c **** 			/* Run through all the lists that could potentially contain a TCB and
1322:FreeRTOS/Source/tasks.c **** 			report the task name, state and stack high water mark. */
1323:FreeRTOS/Source/tasks.c **** 
1324:FreeRTOS/Source/tasks.c **** 			*pcWriteBuffer = ( signed char ) 0x00;
1325:FreeRTOS/Source/tasks.c **** 			strcat( ( char * ) pcWriteBuffer, ( const char * ) "\r\n" );
1326:FreeRTOS/Source/tasks.c **** 
1327:FreeRTOS/Source/tasks.c **** 			uxQueue = uxTopUsedPriority + ( unsigned portBASE_TYPE ) 1U;
1328:FreeRTOS/Source/tasks.c **** 
1329:FreeRTOS/Source/tasks.c **** 			do
1330:FreeRTOS/Source/tasks.c **** 			{
1331:FreeRTOS/Source/tasks.c **** 				uxQueue--;
1332:FreeRTOS/Source/tasks.c **** 
1333:FreeRTOS/Source/tasks.c **** 				if( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxQueue ] ) ) == pdFALSE )
1334:FreeRTOS/Source/tasks.c **** 				{
1335:FreeRTOS/Source/tasks.c **** 					prvListTaskWithinSingleList( pcWriteBuffer, ( xList * ) &( pxReadyTasksLists[ uxQueue ] ), tsk
1336:FreeRTOS/Source/tasks.c **** 				}
1337:FreeRTOS/Source/tasks.c **** 			}while( uxQueue > ( unsigned short ) tskIDLE_PRIORITY );
1338:FreeRTOS/Source/tasks.c **** 
1339:FreeRTOS/Source/tasks.c **** 			if( listLIST_IS_EMPTY( pxDelayedTaskList ) == pdFALSE )
1340:FreeRTOS/Source/tasks.c **** 			{
1341:FreeRTOS/Source/tasks.c **** 				prvListTaskWithinSingleList( pcWriteBuffer, ( xList * ) pxDelayedTaskList, tskBLOCKED_CHAR );
1342:FreeRTOS/Source/tasks.c **** 			}
1343:FreeRTOS/Source/tasks.c **** 
1344:FreeRTOS/Source/tasks.c **** 			if( listLIST_IS_EMPTY( pxOverflowDelayedTaskList ) == pdFALSE )
1345:FreeRTOS/Source/tasks.c **** 			{
1346:FreeRTOS/Source/tasks.c **** 				prvListTaskWithinSingleList( pcWriteBuffer, ( xList * ) pxOverflowDelayedTaskList, tskBLOCKED_C
1347:FreeRTOS/Source/tasks.c **** 			}
1348:FreeRTOS/Source/tasks.c **** 
1349:FreeRTOS/Source/tasks.c **** 			#if( INCLUDE_vTaskDelete == 1 )
1350:FreeRTOS/Source/tasks.c **** 			{
1351:FreeRTOS/Source/tasks.c **** 				if( listLIST_IS_EMPTY( &xTasksWaitingTermination ) == pdFALSE )
1352:FreeRTOS/Source/tasks.c **** 				{
1353:FreeRTOS/Source/tasks.c **** 					prvListTaskWithinSingleList( pcWriteBuffer, &xTasksWaitingTermination, tskDELETED_CHAR );
1354:FreeRTOS/Source/tasks.c **** 				}
1355:FreeRTOS/Source/tasks.c **** 			}
1356:FreeRTOS/Source/tasks.c **** 			#endif
1357:FreeRTOS/Source/tasks.c **** 
1358:FreeRTOS/Source/tasks.c **** 			#if ( INCLUDE_vTaskSuspend == 1 )
1359:FreeRTOS/Source/tasks.c **** 			{
1360:FreeRTOS/Source/tasks.c **** 				if( listLIST_IS_EMPTY( &xSuspendedTaskList ) == pdFALSE )
1361:FreeRTOS/Source/tasks.c **** 				{
1362:FreeRTOS/Source/tasks.c **** 					prvListTaskWithinSingleList( pcWriteBuffer, &xSuspendedTaskList, tskSUSPENDED_CHAR );
1363:FreeRTOS/Source/tasks.c **** 				}
1364:FreeRTOS/Source/tasks.c **** 			}
1365:FreeRTOS/Source/tasks.c **** 			#endif
1366:FreeRTOS/Source/tasks.c **** 		}
1367:FreeRTOS/Source/tasks.c **** 		xTaskResumeAll();
1368:FreeRTOS/Source/tasks.c **** 	}
1369:FreeRTOS/Source/tasks.c **** 
1370:FreeRTOS/Source/tasks.c **** #endif
1371:FreeRTOS/Source/tasks.c **** /*----------------------------------------------------------*/
1372:FreeRTOS/Source/tasks.c **** 
1373:FreeRTOS/Source/tasks.c **** #if ( configGENERATE_RUN_TIME_STATS == 1 )
1374:FreeRTOS/Source/tasks.c **** 
1375:FreeRTOS/Source/tasks.c **** 	void vTaskGetRunTimeStats( signed char *pcWriteBuffer )
1376:FreeRTOS/Source/tasks.c **** 	{
 1793              		.loc 1 1376 0
 1794              		.cfi_startproc
 1795              		@ args = 0, pretend = 0, frame = 16
 1796              		@ frame_needed = 1, uses_anonymous_args = 0
 1797 0000 90B5     		push	{r4, r7, lr}
 1798              	.LCFI48:
 1799              		.cfi_def_cfa_offset 12
 1800              		.cfi_offset 14, -4
 1801              		.cfi_offset 7, -8
 1802              		.cfi_offset 4, -12
 1803 0002 85B0     		sub	sp, sp, #20
 1804              	.LCFI49:
 1805              		.cfi_def_cfa_offset 32
 1806 0004 00AF     		add	r7, sp, #0
 1807              	.LCFI50:
 1808              		.cfi_def_cfa_register 7
 1809 0006 7860     		str	r0, [r7, #4]
1377:FreeRTOS/Source/tasks.c **** 	unsigned portBASE_TYPE uxQueue;
1378:FreeRTOS/Source/tasks.c **** 	unsigned long ulTotalRunTime;
1379:FreeRTOS/Source/tasks.c **** 
1380:FreeRTOS/Source/tasks.c **** 		/* This is a VERY costly function that should be used for debug only.
1381:FreeRTOS/Source/tasks.c **** 		It leaves interrupts disabled for a LONG time. */
1382:FreeRTOS/Source/tasks.c **** 
1383:FreeRTOS/Source/tasks.c **** 		vTaskSuspendAll();
 1810              		.loc 1 1383 0
 1811 0008 FFF7FEFF 		bl	vTaskSuspendAll
1384:FreeRTOS/Source/tasks.c **** 		{
1385:FreeRTOS/Source/tasks.c **** 			#ifdef portALT_GET_RUN_TIME_COUNTER_VALUE
1386:FreeRTOS/Source/tasks.c **** 				portALT_GET_RUN_TIME_COUNTER_VALUE( ulTotalRunTime );
1387:FreeRTOS/Source/tasks.c **** 			#else
1388:FreeRTOS/Source/tasks.c **** 				ulTotalRunTime = portGET_RUN_TIME_COUNTER_VALUE();
 1812              		.loc 1 1388 0
 1813 000c FFF7FEFF 		bl	get_us_time
 1814 0010 0246     		mov	r2, r0
 1815 0012 0B46     		mov	r3, r1
 1816 0014 1346     		mov	r3, r2
 1817 0016 BB60     		str	r3, [r7, #8]
1389:FreeRTOS/Source/tasks.c **** 			#endif
1390:FreeRTOS/Source/tasks.c **** 
1391:FreeRTOS/Source/tasks.c **** 			/* Divide ulTotalRunTime by 100 to make the percentage caluclations
1392:FreeRTOS/Source/tasks.c **** 			simpler in the prvGenerateRunTimeStatsForTasksInList() function. */
1393:FreeRTOS/Source/tasks.c **** 			ulTotalRunTime /= 100UL;
 1818              		.loc 1 1393 0
 1819 0018 BA68     		ldr	r2, [r7, #8]
 1820 001a 48F21F53 		movw	r3, #34079
 1821 001e C5F2EB13 		movt	r3, 20971
 1822 0022 A3FB0213 		umull	r1, r3, r3, r2
 1823 0026 4FEA5313 		lsr	r3, r3, #5
 1824 002a BB60     		str	r3, [r7, #8]
1394:FreeRTOS/Source/tasks.c **** 			
1395:FreeRTOS/Source/tasks.c **** 			/* Run through all the lists that could potentially contain a TCB,
1396:FreeRTOS/Source/tasks.c **** 			generating a table of run timer percentages in the provided
1397:FreeRTOS/Source/tasks.c **** 			buffer. */
1398:FreeRTOS/Source/tasks.c **** 
1399:FreeRTOS/Source/tasks.c **** 			*pcWriteBuffer = ( signed char ) 0x00;
 1825              		.loc 1 1399 0
 1826 002c 7B68     		ldr	r3, [r7, #4]
 1827 002e 4FF00002 		mov	r2, #0
 1828 0032 1A70     		strb	r2, [r3, #0]
1400:FreeRTOS/Source/tasks.c **** 			strcat( ( char * ) pcWriteBuffer, ( const char * ) "\r\n" );
 1829              		.loc 1 1400 0
 1830 0034 7C68     		ldr	r4, [r7, #4]
 1831 0036 2046     		mov	r0, r4
 1832 0038 FFF7FEFF 		bl	strlen
 1833 003c 0346     		mov	r3, r0
 1834 003e E218     		adds	r2, r4, r3
 1835 0040 40F20003 		movw	r3, #:lower16:.LC1
 1836 0044 C0F20003 		movt	r3, #:upper16:.LC1
 1837 0048 1988     		ldrh	r1, [r3, #0]	@ unaligned
 1838 004a 9B78     		ldrb	r3, [r3, #2]
 1839 004c 1180     		strh	r1, [r2, #0]	@ unaligned
 1840 004e 9370     		strb	r3, [r2, #2]
1401:FreeRTOS/Source/tasks.c **** 
1402:FreeRTOS/Source/tasks.c **** 			uxQueue = uxTopUsedPriority + ( unsigned portBASE_TYPE ) 1U;
 1841              		.loc 1 1402 0
 1842 0050 40F20003 		movw	r3, #:lower16:uxTopUsedPriority
 1843 0054 C0F20003 		movt	r3, #:upper16:uxTopUsedPriority
 1844 0058 1B68     		ldr	r3, [r3, #0]
 1845 005a 03F10103 		add	r3, r3, #1
 1846 005e FB60     		str	r3, [r7, #12]
 1847              	.L75:
1403:FreeRTOS/Source/tasks.c **** 
1404:FreeRTOS/Source/tasks.c **** 			do
1405:FreeRTOS/Source/tasks.c **** 			{
1406:FreeRTOS/Source/tasks.c **** 				uxQueue--;
 1848              		.loc 1 1406 0
 1849 0060 FB68     		ldr	r3, [r7, #12]
 1850 0062 03F1FF33 		add	r3, r3, #-1
 1851 0066 FB60     		str	r3, [r7, #12]
1407:FreeRTOS/Source/tasks.c **** 
1408:FreeRTOS/Source/tasks.c **** 				if( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxQueue ] ) ) == pdFALSE )
 1852              		.loc 1 1408 0
 1853 0068 FA68     		ldr	r2, [r7, #12]
 1854 006a 1346     		mov	r3, r2
 1855 006c 4FEA8303 		lsl	r3, r3, #2
 1856 0070 9B18     		adds	r3, r3, r2
 1857 0072 4FEA8303 		lsl	r3, r3, #2
 1858 0076 1A46     		mov	r2, r3
 1859 0078 40F20003 		movw	r3, #:lower16:pxReadyTasksLists
 1860 007c C0F20003 		movt	r3, #:upper16:pxReadyTasksLists
 1861 0080 D318     		adds	r3, r2, r3
 1862 0082 1B68     		ldr	r3, [r3, #0]
 1863 0084 002B     		cmp	r3, #0
 1864 0086 13D0     		beq	.L74
1409:FreeRTOS/Source/tasks.c **** 				{
1410:FreeRTOS/Source/tasks.c **** 					prvGenerateRunTimeStatsForTasksInList( pcWriteBuffer, ( xList * ) &( pxReadyTasksLists[ uxQueu
 1865              		.loc 1 1410 0
 1866 0088 FA68     		ldr	r2, [r7, #12]
 1867 008a 1346     		mov	r3, r2
 1868 008c 4FEA8303 		lsl	r3, r3, #2
 1869 0090 9B18     		adds	r3, r3, r2
 1870 0092 4FEA8303 		lsl	r3, r3, #2
 1871 0096 1A46     		mov	r2, r3
 1872 0098 40F20003 		movw	r3, #:lower16:pxReadyTasksLists
 1873 009c C0F20003 		movt	r3, #:upper16:pxReadyTasksLists
 1874 00a0 D318     		adds	r3, r2, r3
 1875 00a2 7868     		ldr	r0, [r7, #4]
 1876 00a4 1946     		mov	r1, r3
 1877 00a6 BA68     		ldr	r2, [r7, #8]
 1878 00a8 4FF05203 		mov	r3, #82
 1879 00ac FFF7FEFF 		bl	prvGenerateRunTimeStatsForTasksInList
 1880              	.L74:
1411:FreeRTOS/Source/tasks.c **** 				}
1412:FreeRTOS/Source/tasks.c **** 			}while( uxQueue > ( unsigned short ) tskIDLE_PRIORITY );
 1881              		.loc 1 1412 0
 1882 00b0 FB68     		ldr	r3, [r7, #12]
 1883 00b2 002B     		cmp	r3, #0
 1884 00b4 D4D1     		bne	.L75
1413:FreeRTOS/Source/tasks.c **** 
1414:FreeRTOS/Source/tasks.c **** 			if( listLIST_IS_EMPTY( pxDelayedTaskList ) == pdFALSE )
 1885              		.loc 1 1414 0
 1886 00b6 40F20003 		movw	r3, #:lower16:pxDelayedTaskList
 1887 00ba C0F20003 		movt	r3, #:upper16:pxDelayedTaskList
 1888 00be 1B68     		ldr	r3, [r3, #0]
 1889 00c0 1B68     		ldr	r3, [r3, #0]
 1890 00c2 002B     		cmp	r3, #0
 1891 00c4 0BD0     		beq	.L76
1415:FreeRTOS/Source/tasks.c **** 			{
1416:FreeRTOS/Source/tasks.c **** 				prvGenerateRunTimeStatsForTasksInList( pcWriteBuffer, ( xList * ) pxDelayedTaskList, ulTotalRun
 1892              		.loc 1 1416 0
 1893 00c6 40F20003 		movw	r3, #:lower16:pxDelayedTaskList
 1894 00ca C0F20003 		movt	r3, #:upper16:pxDelayedTaskList
 1895 00ce 1B68     		ldr	r3, [r3, #0]
 1896 00d0 7868     		ldr	r0, [r7, #4]
 1897 00d2 1946     		mov	r1, r3
 1898 00d4 BA68     		ldr	r2, [r7, #8]
 1899 00d6 4FF04203 		mov	r3, #66
 1900 00da FFF7FEFF 		bl	prvGenerateRunTimeStatsForTasksInList
 1901              	.L76:
1417:FreeRTOS/Source/tasks.c **** 			}
1418:FreeRTOS/Source/tasks.c **** 
1419:FreeRTOS/Source/tasks.c **** 			if( listLIST_IS_EMPTY( pxOverflowDelayedTaskList ) == pdFALSE )
 1902              		.loc 1 1419 0
 1903 00de 40F20003 		movw	r3, #:lower16:pxOverflowDelayedTaskList
 1904 00e2 C0F20003 		movt	r3, #:upper16:pxOverflowDelayedTaskList
 1905 00e6 1B68     		ldr	r3, [r3, #0]
 1906 00e8 1B68     		ldr	r3, [r3, #0]
 1907 00ea 002B     		cmp	r3, #0
 1908 00ec 0BD0     		beq	.L77
1420:FreeRTOS/Source/tasks.c **** 			{
1421:FreeRTOS/Source/tasks.c **** 				prvGenerateRunTimeStatsForTasksInList( pcWriteBuffer, ( xList * ) pxOverflowDelayedTaskList, ul
 1909              		.loc 1 1421 0
 1910 00ee 40F20003 		movw	r3, #:lower16:pxOverflowDelayedTaskList
 1911 00f2 C0F20003 		movt	r3, #:upper16:pxOverflowDelayedTaskList
 1912 00f6 1B68     		ldr	r3, [r3, #0]
 1913 00f8 7868     		ldr	r0, [r7, #4]
 1914 00fa 1946     		mov	r1, r3
 1915 00fc BA68     		ldr	r2, [r7, #8]
 1916 00fe 4FF04203 		mov	r3, #66
 1917 0102 FFF7FEFF 		bl	prvGenerateRunTimeStatsForTasksInList
 1918              	.L77:
1422:FreeRTOS/Source/tasks.c **** 			}
1423:FreeRTOS/Source/tasks.c **** 
1424:FreeRTOS/Source/tasks.c **** 			#if ( INCLUDE_vTaskDelete == 1 )
1425:FreeRTOS/Source/tasks.c **** 			{
1426:FreeRTOS/Source/tasks.c **** 				if( listLIST_IS_EMPTY( &xTasksWaitingTermination ) == pdFALSE )
 1919              		.loc 1 1426 0
 1920 0106 40F20003 		movw	r3, #:lower16:xTasksWaitingTermination
 1921 010a C0F20003 		movt	r3, #:upper16:xTasksWaitingTermination
 1922 010e 1B68     		ldr	r3, [r3, #0]
 1923 0110 002B     		cmp	r3, #0
 1924 0112 09D0     		beq	.L78
1427:FreeRTOS/Source/tasks.c **** 				{
1428:FreeRTOS/Source/tasks.c **** 					prvGenerateRunTimeStatsForTasksInList( pcWriteBuffer, &xTasksWaitingTermination, ulTotalRunTim
 1925              		.loc 1 1428 0
 1926 0114 7868     		ldr	r0, [r7, #4]
 1927 0116 40F20001 		movw	r1, #:lower16:xTasksWaitingTermination
 1928 011a C0F20001 		movt	r1, #:upper16:xTasksWaitingTermination
 1929 011e BA68     		ldr	r2, [r7, #8]
 1930 0120 4FF04403 		mov	r3, #68
 1931 0124 FFF7FEFF 		bl	prvGenerateRunTimeStatsForTasksInList
 1932              	.L78:
1429:FreeRTOS/Source/tasks.c **** 				}
1430:FreeRTOS/Source/tasks.c **** 			}
1431:FreeRTOS/Source/tasks.c **** 			#endif
1432:FreeRTOS/Source/tasks.c **** 
1433:FreeRTOS/Source/tasks.c **** 			#if ( INCLUDE_vTaskSuspend == 1 )
1434:FreeRTOS/Source/tasks.c **** 			{
1435:FreeRTOS/Source/tasks.c **** 				if( listLIST_IS_EMPTY( &xSuspendedTaskList ) == pdFALSE )
 1933              		.loc 1 1435 0
 1934 0128 40F20003 		movw	r3, #:lower16:xSuspendedTaskList
 1935 012c C0F20003 		movt	r3, #:upper16:xSuspendedTaskList
 1936 0130 1B68     		ldr	r3, [r3, #0]
 1937 0132 002B     		cmp	r3, #0
 1938 0134 09D0     		beq	.L79
1436:FreeRTOS/Source/tasks.c **** 				{
1437:FreeRTOS/Source/tasks.c **** 					prvGenerateRunTimeStatsForTasksInList( pcWriteBuffer, &xSuspendedTaskList, ulTotalRunTime, tsk
 1939              		.loc 1 1437 0
 1940 0136 7868     		ldr	r0, [r7, #4]
 1941 0138 40F20001 		movw	r1, #:lower16:xSuspendedTaskList
 1942 013c C0F20001 		movt	r1, #:upper16:xSuspendedTaskList
 1943 0140 BA68     		ldr	r2, [r7, #8]
 1944 0142 4FF05303 		mov	r3, #83
 1945 0146 FFF7FEFF 		bl	prvGenerateRunTimeStatsForTasksInList
 1946              	.L79:
1438:FreeRTOS/Source/tasks.c **** 				}
1439:FreeRTOS/Source/tasks.c **** 			}
1440:FreeRTOS/Source/tasks.c **** 			#endif
1441:FreeRTOS/Source/tasks.c **** 		}
1442:FreeRTOS/Source/tasks.c **** 		xTaskResumeAll();
 1947              		.loc 1 1442 0
 1948 014a FFF7FEFF 		bl	xTaskResumeAll
1443:FreeRTOS/Source/tasks.c **** 	}
 1949              		.loc 1 1443 0
 1950 014e 07F11407 		add	r7, r7, #20
 1951 0152 BD46     		mov	sp, r7
 1952 0154 90BD     		pop	{r4, r7, pc}
 1953              		.cfi_endproc
 1954              	.LFE127:
 1956 0156 00BF     		.section	.text.xTaskGetIdleTaskHandle,"ax",%progbits
 1957              		.align	2
 1958              		.global	xTaskGetIdleTaskHandle
 1959              		.thumb
 1960              		.thumb_func
 1962              	xTaskGetIdleTaskHandle:
 1963              	.LFB128:
1444:FreeRTOS/Source/tasks.c **** 
1445:FreeRTOS/Source/tasks.c **** #endif
1446:FreeRTOS/Source/tasks.c **** /*----------------------------------------------------------*/
1447:FreeRTOS/Source/tasks.c **** 
1448:FreeRTOS/Source/tasks.c **** #if ( configUSE_TRACE_FACILITY == 1 )
1449:FreeRTOS/Source/tasks.c **** 
1450:FreeRTOS/Source/tasks.c **** 	void vTaskStartTrace( signed char * pcBuffer, unsigned long ulBufferSize )
1451:FreeRTOS/Source/tasks.c **** 	{
1452:FreeRTOS/Source/tasks.c **** 		configASSERT( pcBuffer );
1453:FreeRTOS/Source/tasks.c **** 		configASSERT( ulBufferSize );
1454:FreeRTOS/Source/tasks.c **** 
1455:FreeRTOS/Source/tasks.c **** 		taskENTER_CRITICAL();
1456:FreeRTOS/Source/tasks.c **** 		{
1457:FreeRTOS/Source/tasks.c **** 			pcTraceBuffer = ( signed char * )pcBuffer;
1458:FreeRTOS/Source/tasks.c **** 			pcTraceBufferStart = pcBuffer;
1459:FreeRTOS/Source/tasks.c **** 			pcTraceBufferEnd = pcBuffer + ( ulBufferSize - tskSIZE_OF_EACH_TRACE_LINE );
1460:FreeRTOS/Source/tasks.c **** 			xTracing = pdTRUE;
1461:FreeRTOS/Source/tasks.c **** 		}
1462:FreeRTOS/Source/tasks.c **** 		taskEXIT_CRITICAL();
1463:FreeRTOS/Source/tasks.c **** 	}
1464:FreeRTOS/Source/tasks.c **** 
1465:FreeRTOS/Source/tasks.c **** #endif
1466:FreeRTOS/Source/tasks.c **** /*----------------------------------------------------------*/
1467:FreeRTOS/Source/tasks.c **** 
1468:FreeRTOS/Source/tasks.c **** #if ( configUSE_TRACE_FACILITY == 1 )
1469:FreeRTOS/Source/tasks.c **** 
1470:FreeRTOS/Source/tasks.c **** 	unsigned long ulTaskEndTrace( void )
1471:FreeRTOS/Source/tasks.c **** 	{
1472:FreeRTOS/Source/tasks.c **** 	unsigned long ulBufferLength;
1473:FreeRTOS/Source/tasks.c **** 
1474:FreeRTOS/Source/tasks.c **** 		taskENTER_CRITICAL();
1475:FreeRTOS/Source/tasks.c **** 			xTracing = pdFALSE;
1476:FreeRTOS/Source/tasks.c **** 		taskEXIT_CRITICAL();
1477:FreeRTOS/Source/tasks.c **** 
1478:FreeRTOS/Source/tasks.c **** 		ulBufferLength = ( unsigned long ) ( pcTraceBuffer - pcTraceBufferStart );
1479:FreeRTOS/Source/tasks.c **** 
1480:FreeRTOS/Source/tasks.c **** 		return ulBufferLength;
1481:FreeRTOS/Source/tasks.c **** 	}
1482:FreeRTOS/Source/tasks.c **** 
1483:FreeRTOS/Source/tasks.c **** #endif
1484:FreeRTOS/Source/tasks.c **** /*----------------------------------------------------------*/
1485:FreeRTOS/Source/tasks.c **** 
1486:FreeRTOS/Source/tasks.c **** #if ( INCLUDE_xTaskGetIdleTaskHandle == 1 )
1487:FreeRTOS/Source/tasks.c **** 
1488:FreeRTOS/Source/tasks.c **** 	xTaskHandle xTaskGetIdleTaskHandle( void )
1489:FreeRTOS/Source/tasks.c **** 	{
 1964              		.loc 1 1489 0
 1965              		.cfi_startproc
 1966              		@ args = 0, pretend = 0, frame = 0
 1967              		@ frame_needed = 1, uses_anonymous_args = 0
 1968              		@ link register save eliminated.
 1969 0000 80B4     		push	{r7}
 1970              	.LCFI51:
 1971              		.cfi_def_cfa_offset 4
 1972              		.cfi_offset 7, -4
 1973 0002 00AF     		add	r7, sp, #0
 1974              	.LCFI52:
 1975              		.cfi_def_cfa_register 7
1490:FreeRTOS/Source/tasks.c **** 		/* If xTaskGetIdleTaskHandle() is called before the scheduler has been
1491:FreeRTOS/Source/tasks.c **** 		started, then xIdleTaskHandle will be NULL. */
1492:FreeRTOS/Source/tasks.c **** 		configASSERT( ( xIdleTaskHandle != NULL ) );
1493:FreeRTOS/Source/tasks.c **** 		return xIdleTaskHandle;
 1976              		.loc 1 1493 0
 1977 0004 40F20003 		movw	r3, #:lower16:xIdleTaskHandle
 1978 0008 C0F20003 		movt	r3, #:upper16:xIdleTaskHandle
 1979 000c 1B68     		ldr	r3, [r3, #0]
1494:FreeRTOS/Source/tasks.c **** 	}
 1980              		.loc 1 1494 0
 1981 000e 1846     		mov	r0, r3
 1982 0010 BD46     		mov	sp, r7
 1983 0012 80BC     		pop	{r7}
 1984 0014 7047     		bx	lr
 1985              		.cfi_endproc
 1986              	.LFE128:
 1988 0016 00BF     		.section	.text.vTaskIncrementTick,"ax",%progbits
 1989              		.align	2
 1990              		.global	vTaskIncrementTick
 1991              		.thumb
 1992              		.thumb_func
 1994              	vTaskIncrementTick:
 1995              	.LFB129:
1495:FreeRTOS/Source/tasks.c **** 	
1496:FreeRTOS/Source/tasks.c **** #endif
1497:FreeRTOS/Source/tasks.c **** 
1498:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------
1499:FreeRTOS/Source/tasks.c ****  * SCHEDULER INTERNALS AVAILABLE FOR PORTING PURPOSES
1500:FreeRTOS/Source/tasks.c ****  * documented in task.h
1501:FreeRTOS/Source/tasks.c ****  *----------------------------------------------------------*/
1502:FreeRTOS/Source/tasks.c **** 
1503:FreeRTOS/Source/tasks.c **** void vTaskIncrementTick( void )
1504:FreeRTOS/Source/tasks.c **** {
 1996              		.loc 1 1504 0
 1997              		.cfi_startproc
 1998              		@ args = 0, pretend = 0, frame = 16
 1999              		@ frame_needed = 1, uses_anonymous_args = 0
 2000 0000 80B5     		push	{r7, lr}
 2001              	.LCFI53:
 2002              		.cfi_def_cfa_offset 8
 2003              		.cfi_offset 14, -4
 2004              		.cfi_offset 7, -8
 2005 0002 84B0     		sub	sp, sp, #16
 2006              	.LCFI54:
 2007              		.cfi_def_cfa_offset 24
 2008 0004 00AF     		add	r7, sp, #0
 2009              	.LCFI55:
 2010              		.cfi_def_cfa_register 7
1505:FreeRTOS/Source/tasks.c **** tskTCB * pxTCB;
1506:FreeRTOS/Source/tasks.c **** 
1507:FreeRTOS/Source/tasks.c **** 	/* Called by the portable layer each time a tick interrupt occurs.
1508:FreeRTOS/Source/tasks.c **** 	Increments the tick then checks to see if the new tick value will cause any
1509:FreeRTOS/Source/tasks.c **** 	tasks to be unblocked. */
1510:FreeRTOS/Source/tasks.c **** 	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
 2011              		.loc 1 1510 0
 2012 0006 40F20003 		movw	r3, #:lower16:uxSchedulerSuspended
 2013 000a C0F20003 		movt	r3, #:upper16:uxSchedulerSuspended
 2014 000e 1B68     		ldr	r3, [r3, #0]
 2015 0010 002B     		cmp	r3, #0
 2016 0012 40F0C080 		bne	.L82
1511:FreeRTOS/Source/tasks.c **** 	{
1512:FreeRTOS/Source/tasks.c **** 		++xTickCount;
 2017              		.loc 1 1512 0
 2018 0016 40F20003 		movw	r3, #:lower16:xTickCount
 2019 001a C0F20003 		movt	r3, #:upper16:xTickCount
 2020 001e 1B68     		ldr	r3, [r3, #0]
 2021 0020 03F10102 		add	r2, r3, #1
 2022 0024 40F20003 		movw	r3, #:lower16:xTickCount
 2023 0028 C0F20003 		movt	r3, #:upper16:xTickCount
 2024 002c 1A60     		str	r2, [r3, #0]
1513:FreeRTOS/Source/tasks.c **** 		if( xTickCount == ( portTickType ) 0U )
 2025              		.loc 1 1513 0
 2026 002e 40F20003 		movw	r3, #:lower16:xTickCount
 2027 0032 C0F20003 		movt	r3, #:upper16:xTickCount
 2028 0036 1B68     		ldr	r3, [r3, #0]
 2029 0038 002B     		cmp	r3, #0
 2030 003a 40D1     		bne	.L83
 2031              	.LBB4:
1514:FreeRTOS/Source/tasks.c **** 		{
1515:FreeRTOS/Source/tasks.c **** 			xList *pxTemp;
1516:FreeRTOS/Source/tasks.c **** 
1517:FreeRTOS/Source/tasks.c **** 			/* Tick count has overflowed so we need to swap the delay lists.
1518:FreeRTOS/Source/tasks.c **** 			If there are any items in pxDelayedTaskList here then there is
1519:FreeRTOS/Source/tasks.c **** 			an error! */
1520:FreeRTOS/Source/tasks.c **** 			configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );
1521:FreeRTOS/Source/tasks.c **** 			
1522:FreeRTOS/Source/tasks.c **** 			pxTemp = pxDelayedTaskList;
 2032              		.loc 1 1522 0
 2033 003c 40F20003 		movw	r3, #:lower16:pxDelayedTaskList
 2034 0040 C0F20003 		movt	r3, #:upper16:pxDelayedTaskList
 2035 0044 1B68     		ldr	r3, [r3, #0]
 2036 0046 FB60     		str	r3, [r7, #12]
1523:FreeRTOS/Source/tasks.c **** 			pxDelayedTaskList = pxOverflowDelayedTaskList;
 2037              		.loc 1 1523 0
 2038 0048 40F20003 		movw	r3, #:lower16:pxOverflowDelayedTaskList
 2039 004c C0F20003 		movt	r3, #:upper16:pxOverflowDelayedTaskList
 2040 0050 1A68     		ldr	r2, [r3, #0]
 2041 0052 40F20003 		movw	r3, #:lower16:pxDelayedTaskList
 2042 0056 C0F20003 		movt	r3, #:upper16:pxDelayedTaskList
 2043 005a 1A60     		str	r2, [r3, #0]
1524:FreeRTOS/Source/tasks.c **** 			pxOverflowDelayedTaskList = pxTemp;
 2044              		.loc 1 1524 0
 2045 005c 40F20003 		movw	r3, #:lower16:pxOverflowDelayedTaskList
 2046 0060 C0F20003 		movt	r3, #:upper16:pxOverflowDelayedTaskList
 2047 0064 FA68     		ldr	r2, [r7, #12]
 2048 0066 1A60     		str	r2, [r3, #0]
1525:FreeRTOS/Source/tasks.c **** 			xNumOfOverflows++;
 2049              		.loc 1 1525 0
 2050 0068 40F20003 		movw	r3, #:lower16:xNumOfOverflows
 2051 006c C0F20003 		movt	r3, #:upper16:xNumOfOverflows
 2052 0070 1B68     		ldr	r3, [r3, #0]
 2053 0072 03F10102 		add	r2, r3, #1
 2054 0076 40F20003 		movw	r3, #:lower16:xNumOfOverflows
 2055 007a C0F20003 		movt	r3, #:upper16:xNumOfOverflows
 2056 007e 1A60     		str	r2, [r3, #0]
1526:FreeRTOS/Source/tasks.c **** 	
1527:FreeRTOS/Source/tasks.c **** 			if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 2057              		.loc 1 1527 0
 2058 0080 40F20003 		movw	r3, #:lower16:pxDelayedTaskList
 2059 0084 C0F20003 		movt	r3, #:upper16:pxDelayedTaskList
 2060 0088 1B68     		ldr	r3, [r3, #0]
 2061 008a 1B68     		ldr	r3, [r3, #0]
 2062 008c 002B     		cmp	r3, #0
 2063 008e 07D1     		bne	.L84
1528:FreeRTOS/Source/tasks.c **** 			{
1529:FreeRTOS/Source/tasks.c **** 				/* The new current delayed list is empty.  Set
1530:FreeRTOS/Source/tasks.c **** 				xNextTaskUnblockTime to the maximum possible value so it is
1531:FreeRTOS/Source/tasks.c **** 				extremely unlikely that the	
1532:FreeRTOS/Source/tasks.c **** 				if( xTickCount >= xNextTaskUnblockTime ) test will pass until
1533:FreeRTOS/Source/tasks.c **** 				there is an item in the delayed list. */
1534:FreeRTOS/Source/tasks.c **** 				xNextTaskUnblockTime = portMAX_DELAY;
 2064              		.loc 1 1534 0
 2065 0090 40F20003 		movw	r3, #:lower16:xNextTaskUnblockTime
 2066 0094 C0F20003 		movt	r3, #:upper16:xNextTaskUnblockTime
 2067 0098 4FF0FF32 		mov	r2, #-1
 2068 009c 1A60     		str	r2, [r3, #0]
 2069 009e 0EE0     		b	.L83
 2070              	.L84:
1535:FreeRTOS/Source/tasks.c **** 			}
1536:FreeRTOS/Source/tasks.c **** 			else
1537:FreeRTOS/Source/tasks.c **** 			{
1538:FreeRTOS/Source/tasks.c **** 				/* The new current delayed list is not empty, get the value of
1539:FreeRTOS/Source/tasks.c **** 				the item at the head of the delayed list.  This is the time at
1540:FreeRTOS/Source/tasks.c **** 				which the task at the head of the delayed list should be removed
1541:FreeRTOS/Source/tasks.c **** 				from the Blocked state. */
1542:FreeRTOS/Source/tasks.c **** 				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
 2071              		.loc 1 1542 0
 2072 00a0 40F20003 		movw	r3, #:lower16:pxDelayedTaskList
 2073 00a4 C0F20003 		movt	r3, #:upper16:pxDelayedTaskList
 2074 00a8 1B68     		ldr	r3, [r3, #0]
 2075 00aa DB68     		ldr	r3, [r3, #12]
 2076 00ac DB68     		ldr	r3, [r3, #12]
 2077 00ae BB60     		str	r3, [r7, #8]
1543:FreeRTOS/Source/tasks.c **** 				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
 2078              		.loc 1 1543 0
 2079 00b0 BB68     		ldr	r3, [r7, #8]
 2080 00b2 5A68     		ldr	r2, [r3, #4]
 2081 00b4 40F20003 		movw	r3, #:lower16:xNextTaskUnblockTime
 2082 00b8 C0F20003 		movt	r3, #:upper16:xNextTaskUnblockTime
 2083 00bc 1A60     		str	r2, [r3, #0]
 2084              	.L83:
 2085              	.LBE4:
 2086              	.LBB5:
1544:FreeRTOS/Source/tasks.c **** 			}
1545:FreeRTOS/Source/tasks.c **** 		}
1546:FreeRTOS/Source/tasks.c **** 
1547:FreeRTOS/Source/tasks.c **** 		/* See if this tick has made a timeout expire. */
1548:FreeRTOS/Source/tasks.c **** 		prvCheckDelayedTasks();
 2087              		.loc 1 1548 0
 2088 00be 40F20003 		movw	r3, #:lower16:xTickCount
 2089 00c2 C0F20003 		movt	r3, #:upper16:xTickCount
 2090 00c6 1A68     		ldr	r2, [r3, #0]
 2091 00c8 40F20003 		movw	r3, #:lower16:xNextTaskUnblockTime
 2092 00cc C0F20003 		movt	r3, #:upper16:xNextTaskUnblockTime
 2093 00d0 1B68     		ldr	r3, [r3, #0]
 2094 00d2 9A42     		cmp	r2, r3
 2095 00d4 6BD3     		bcc	.L81
 2096              	.L90:
 2097              		.loc 1 1548 0 is_stmt 0 discriminator 1
 2098 00d6 40F20003 		movw	r3, #:lower16:pxDelayedTaskList
 2099 00da C0F20003 		movt	r3, #:upper16:pxDelayedTaskList
 2100 00de 1B68     		ldr	r3, [r3, #0]
 2101 00e0 1B68     		ldr	r3, [r3, #0]
 2102 00e2 002B     		cmp	r3, #0
 2103 00e4 07D1     		bne	.L86
 2104              		.loc 1 1548 0 discriminator 2
 2105 00e6 40F20003 		movw	r3, #:lower16:xNextTaskUnblockTime
 2106 00ea C0F20003 		movt	r3, #:upper16:xNextTaskUnblockTime
 2107 00ee 4FF0FF32 		mov	r2, #-1
 2108 00f2 1A60     		str	r2, [r3, #0]
 2109 00f4 5BE0     		b	.L81
 2110              	.L86:
 2111              		.loc 1 1548 0 discriminator 3
 2112 00f6 40F20003 		movw	r3, #:lower16:pxDelayedTaskList
 2113 00fa C0F20003 		movt	r3, #:upper16:pxDelayedTaskList
 2114 00fe 1B68     		ldr	r3, [r3, #0]
 2115 0100 DB68     		ldr	r3, [r3, #12]
 2116 0102 DB68     		ldr	r3, [r3, #12]
 2117 0104 BB60     		str	r3, [r7, #8]
 2118 0106 BB68     		ldr	r3, [r7, #8]
 2119 0108 5B68     		ldr	r3, [r3, #4]
 2120 010a 7B60     		str	r3, [r7, #4]
 2121 010c 40F20003 		movw	r3, #:lower16:xTickCount
 2122 0110 C0F20003 		movt	r3, #:upper16:xTickCount
 2123 0114 1A68     		ldr	r2, [r3, #0]
 2124 0116 7B68     		ldr	r3, [r7, #4]
 2125 0118 9A42     		cmp	r2, r3
 2126 011a 06D2     		bcs	.L87
 2127              		.loc 1 1548 0 discriminator 4
 2128 011c 40F20003 		movw	r3, #:lower16:xNextTaskUnblockTime
 2129 0120 C0F20003 		movt	r3, #:upper16:xNextTaskUnblockTime
 2130 0124 7A68     		ldr	r2, [r7, #4]
 2131 0126 1A60     		str	r2, [r3, #0]
 2132 0128 41E0     		b	.L81
 2133              	.L87:
 2134              		.loc 1 1548 0 discriminator 5
 2135 012a BB68     		ldr	r3, [r7, #8]
 2136 012c 03F10403 		add	r3, r3, #4
 2137 0130 1846     		mov	r0, r3
 2138 0132 FFF7FEFF 		bl	vListRemove
 2139 0136 BB68     		ldr	r3, [r7, #8]
 2140 0138 9B6A     		ldr	r3, [r3, #40]
 2141 013a 002B     		cmp	r3, #0
 2142 013c 05D0     		beq	.L88
 2143              		.loc 1 1548 0 discriminator 6
 2144 013e BB68     		ldr	r3, [r7, #8]
 2145 0140 03F11803 		add	r3, r3, #24
 2146 0144 1846     		mov	r0, r3
 2147 0146 FFF7FEFF 		bl	vListRemove
 2148              	.L88:
 2149              		.loc 1 1548 0 discriminator 7
 2150 014a BB68     		ldr	r3, [r7, #8]
 2151 014c DA6A     		ldr	r2, [r3, #44]
 2152 014e 40F20003 		movw	r3, #:lower16:uxTopReadyPriority
 2153 0152 C0F20003 		movt	r3, #:upper16:uxTopReadyPriority
 2154 0156 1B68     		ldr	r3, [r3, #0]
 2155 0158 9A42     		cmp	r2, r3
 2156 015a 06D9     		bls	.L89
 2157              		.loc 1 1548 0 discriminator 8
 2158 015c BB68     		ldr	r3, [r7, #8]
 2159 015e DA6A     		ldr	r2, [r3, #44]
 2160 0160 40F20003 		movw	r3, #:lower16:uxTopReadyPriority
 2161 0164 C0F20003 		movt	r3, #:upper16:uxTopReadyPriority
 2162 0168 1A60     		str	r2, [r3, #0]
 2163              	.L89:
 2164              		.loc 1 1548 0 discriminator 9
 2165 016a BB68     		ldr	r3, [r7, #8]
 2166 016c DA6A     		ldr	r2, [r3, #44]
 2167 016e 1346     		mov	r3, r2
 2168 0170 4FEA8303 		lsl	r3, r3, #2
 2169 0174 9B18     		adds	r3, r3, r2
 2170 0176 4FEA8303 		lsl	r3, r3, #2
 2171 017a 1A46     		mov	r2, r3
 2172 017c 40F20003 		movw	r3, #:lower16:pxReadyTasksLists
 2173 0180 C0F20003 		movt	r3, #:upper16:pxReadyTasksLists
 2174 0184 D218     		adds	r2, r2, r3
 2175 0186 BB68     		ldr	r3, [r7, #8]
 2176 0188 03F10403 		add	r3, r3, #4
 2177 018c 1046     		mov	r0, r2
 2178 018e 1946     		mov	r1, r3
 2179 0190 FFF7FEFF 		bl	vListInsertEnd
 2180 0194 9FE7     		b	.L90
 2181              	.L82:
 2182              	.LBE5:
1549:FreeRTOS/Source/tasks.c **** 	}
1550:FreeRTOS/Source/tasks.c **** 	else
1551:FreeRTOS/Source/tasks.c **** 	{
1552:FreeRTOS/Source/tasks.c **** 		++uxMissedTicks;
 2183              		.loc 1 1552 0 is_stmt 1
 2184 0196 40F20003 		movw	r3, #:lower16:uxMissedTicks
 2185 019a C0F20003 		movt	r3, #:upper16:uxMissedTicks
 2186 019e 1B68     		ldr	r3, [r3, #0]
 2187 01a0 03F10102 		add	r2, r3, #1
 2188 01a4 40F20003 		movw	r3, #:lower16:uxMissedTicks
 2189 01a8 C0F20003 		movt	r3, #:upper16:uxMissedTicks
 2190 01ac 1A60     		str	r2, [r3, #0]
 2191              	.L81:
1553:FreeRTOS/Source/tasks.c **** 
1554:FreeRTOS/Source/tasks.c **** 		/* The tick hook gets called at regular intervals, even if the
1555:FreeRTOS/Source/tasks.c **** 		scheduler is locked. */
1556:FreeRTOS/Source/tasks.c **** 		#if ( configUSE_TICK_HOOK == 1 )
1557:FreeRTOS/Source/tasks.c **** 		{
1558:FreeRTOS/Source/tasks.c **** 			vApplicationTickHook();
1559:FreeRTOS/Source/tasks.c **** 		}
1560:FreeRTOS/Source/tasks.c **** 		#endif
1561:FreeRTOS/Source/tasks.c **** 	}
1562:FreeRTOS/Source/tasks.c **** 
1563:FreeRTOS/Source/tasks.c **** 	#if ( configUSE_TICK_HOOK == 1 )
1564:FreeRTOS/Source/tasks.c **** 	{
1565:FreeRTOS/Source/tasks.c **** 		/* Guard against the tick hook being called when the missed tick
1566:FreeRTOS/Source/tasks.c **** 		count is being unwound (when the scheduler is being unlocked. */
1567:FreeRTOS/Source/tasks.c **** 		if( uxMissedTicks == ( unsigned portBASE_TYPE ) 0U )
1568:FreeRTOS/Source/tasks.c **** 		{
1569:FreeRTOS/Source/tasks.c **** 			vApplicationTickHook();
1570:FreeRTOS/Source/tasks.c **** 		}
1571:FreeRTOS/Source/tasks.c **** 	}
1572:FreeRTOS/Source/tasks.c **** 	#endif
1573:FreeRTOS/Source/tasks.c **** 
1574:FreeRTOS/Source/tasks.c **** 	traceTASK_INCREMENT_TICK( xTickCount );
1575:FreeRTOS/Source/tasks.c **** }
 2192              		.loc 1 1575 0
 2193 01ae 07F11007 		add	r7, r7, #16
 2194 01b2 BD46     		mov	sp, r7
 2195 01b4 80BD     		pop	{r7, pc}
 2196              		.cfi_endproc
 2197              	.LFE129:
 2199 01b6 00BF     		.section	.text.vTaskSetApplicationTaskTag,"ax",%progbits
 2200              		.align	2
 2201              		.global	vTaskSetApplicationTaskTag
 2202              		.thumb
 2203              		.thumb_func
 2205              	vTaskSetApplicationTaskTag:
 2206              	.LFB130:
1576:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
1577:FreeRTOS/Source/tasks.c **** 
1578:FreeRTOS/Source/tasks.c **** #if ( configUSE_APPLICATION_TASK_TAG == 1 )
1579:FreeRTOS/Source/tasks.c **** 
1580:FreeRTOS/Source/tasks.c **** 	void vTaskSetApplicationTaskTag( xTaskHandle xTask, pdTASK_HOOK_CODE pxHookFunction )
1581:FreeRTOS/Source/tasks.c **** 	{
 2207              		.loc 1 1581 0
 2208              		.cfi_startproc
 2209              		@ args = 0, pretend = 0, frame = 16
 2210              		@ frame_needed = 1, uses_anonymous_args = 0
 2211 0000 80B5     		push	{r7, lr}
 2212              	.LCFI56:
 2213              		.cfi_def_cfa_offset 8
 2214              		.cfi_offset 14, -4
 2215              		.cfi_offset 7, -8
 2216 0002 84B0     		sub	sp, sp, #16
 2217              	.LCFI57:
 2218              		.cfi_def_cfa_offset 24
 2219 0004 00AF     		add	r7, sp, #0
 2220              	.LCFI58:
 2221              		.cfi_def_cfa_register 7
 2222 0006 7860     		str	r0, [r7, #4]
 2223 0008 3960     		str	r1, [r7, #0]
1582:FreeRTOS/Source/tasks.c **** 	tskTCB *xTCB;
1583:FreeRTOS/Source/tasks.c **** 
1584:FreeRTOS/Source/tasks.c **** 		/* If xTask is NULL then we are setting our own task hook. */
1585:FreeRTOS/Source/tasks.c **** 		if( xTask == NULL )
 2224              		.loc 1 1585 0
 2225 000a 7B68     		ldr	r3, [r7, #4]
 2226 000c 002B     		cmp	r3, #0
 2227 000e 06D1     		bne	.L93
1586:FreeRTOS/Source/tasks.c **** 		{
1587:FreeRTOS/Source/tasks.c **** 			xTCB = ( tskTCB * ) pxCurrentTCB;
 2228              		.loc 1 1587 0
 2229 0010 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 2230 0014 C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 2231 0018 1B68     		ldr	r3, [r3, #0]
 2232 001a FB60     		str	r3, [r7, #12]
 2233 001c 01E0     		b	.L94
 2234              	.L93:
1588:FreeRTOS/Source/tasks.c **** 		}
1589:FreeRTOS/Source/tasks.c **** 		else
1590:FreeRTOS/Source/tasks.c **** 		{
1591:FreeRTOS/Source/tasks.c **** 			xTCB = ( tskTCB * ) xTask;
 2235              		.loc 1 1591 0
 2236 001e 7B68     		ldr	r3, [r7, #4]
 2237 0020 FB60     		str	r3, [r7, #12]
 2238              	.L94:
1592:FreeRTOS/Source/tasks.c **** 		}
1593:FreeRTOS/Source/tasks.c **** 
1594:FreeRTOS/Source/tasks.c **** 		/* Save the hook function in the TCB.  A critical section is required as
1595:FreeRTOS/Source/tasks.c **** 		the value can be accessed from an interrupt. */
1596:FreeRTOS/Source/tasks.c **** 		taskENTER_CRITICAL();
 2239              		.loc 1 1596 0
 2240 0022 FFF7FEFF 		bl	vPortEnterCritical
1597:FreeRTOS/Source/tasks.c **** 			xTCB->pxTaskTag = pxHookFunction;
 2241              		.loc 1 1597 0
 2242 0026 FB68     		ldr	r3, [r7, #12]
 2243 0028 3A68     		ldr	r2, [r7, #0]
 2244 002a 9A64     		str	r2, [r3, #72]
1598:FreeRTOS/Source/tasks.c **** 		taskEXIT_CRITICAL();
 2245              		.loc 1 1598 0
 2246 002c FFF7FEFF 		bl	vPortExitCritical
1599:FreeRTOS/Source/tasks.c **** 	}
 2247              		.loc 1 1599 0
 2248 0030 07F11007 		add	r7, r7, #16
 2249 0034 BD46     		mov	sp, r7
 2250 0036 80BD     		pop	{r7, pc}
 2251              		.cfi_endproc
 2252              	.LFE130:
 2254              		.section	.text.xTaskGetApplicationTaskTag,"ax",%progbits
 2255              		.align	2
 2256              		.global	xTaskGetApplicationTaskTag
 2257              		.thumb
 2258              		.thumb_func
 2260              	xTaskGetApplicationTaskTag:
 2261              	.LFB131:
1600:FreeRTOS/Source/tasks.c **** 
1601:FreeRTOS/Source/tasks.c **** #endif
1602:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
1603:FreeRTOS/Source/tasks.c **** 
1604:FreeRTOS/Source/tasks.c **** #if ( configUSE_APPLICATION_TASK_TAG == 1 )
1605:FreeRTOS/Source/tasks.c **** 
1606:FreeRTOS/Source/tasks.c **** 	pdTASK_HOOK_CODE xTaskGetApplicationTaskTag( xTaskHandle xTask )
1607:FreeRTOS/Source/tasks.c **** 	{
 2262              		.loc 1 1607 0
 2263              		.cfi_startproc
 2264              		@ args = 0, pretend = 0, frame = 16
 2265              		@ frame_needed = 1, uses_anonymous_args = 0
 2266 0000 80B5     		push	{r7, lr}
 2267              	.LCFI59:
 2268              		.cfi_def_cfa_offset 8
 2269              		.cfi_offset 14, -4
 2270              		.cfi_offset 7, -8
 2271 0002 84B0     		sub	sp, sp, #16
 2272              	.LCFI60:
 2273              		.cfi_def_cfa_offset 24
 2274 0004 00AF     		add	r7, sp, #0
 2275              	.LCFI61:
 2276              		.cfi_def_cfa_register 7
 2277 0006 7860     		str	r0, [r7, #4]
1608:FreeRTOS/Source/tasks.c **** 	tskTCB *xTCB;
1609:FreeRTOS/Source/tasks.c **** 	pdTASK_HOOK_CODE xReturn;
1610:FreeRTOS/Source/tasks.c **** 
1611:FreeRTOS/Source/tasks.c **** 		/* If xTask is NULL then we are setting our own task hook. */
1612:FreeRTOS/Source/tasks.c **** 		if( xTask == NULL )
 2278              		.loc 1 1612 0
 2279 0008 7B68     		ldr	r3, [r7, #4]
 2280 000a 002B     		cmp	r3, #0
 2281 000c 06D1     		bne	.L96
1613:FreeRTOS/Source/tasks.c **** 		{
1614:FreeRTOS/Source/tasks.c **** 			xTCB = ( tskTCB * ) pxCurrentTCB;
 2282              		.loc 1 1614 0
 2283 000e 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 2284 0012 C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 2285 0016 1B68     		ldr	r3, [r3, #0]
 2286 0018 FB60     		str	r3, [r7, #12]
 2287 001a 01E0     		b	.L97
 2288              	.L96:
1615:FreeRTOS/Source/tasks.c **** 		}
1616:FreeRTOS/Source/tasks.c **** 		else
1617:FreeRTOS/Source/tasks.c **** 		{
1618:FreeRTOS/Source/tasks.c **** 			xTCB = ( tskTCB * ) xTask;
 2289              		.loc 1 1618 0
 2290 001c 7B68     		ldr	r3, [r7, #4]
 2291 001e FB60     		str	r3, [r7, #12]
 2292              	.L97:
1619:FreeRTOS/Source/tasks.c **** 		}
1620:FreeRTOS/Source/tasks.c **** 
1621:FreeRTOS/Source/tasks.c **** 		/* Save the hook function in the TCB.  A critical section is required as
1622:FreeRTOS/Source/tasks.c **** 		the value can be accessed from an interrupt. */
1623:FreeRTOS/Source/tasks.c **** 		taskENTER_CRITICAL();
 2293              		.loc 1 1623 0
 2294 0020 FFF7FEFF 		bl	vPortEnterCritical
1624:FreeRTOS/Source/tasks.c **** 			xReturn = xTCB->pxTaskTag;
 2295              		.loc 1 1624 0
 2296 0024 FB68     		ldr	r3, [r7, #12]
 2297 0026 9B6C     		ldr	r3, [r3, #72]
 2298 0028 BB60     		str	r3, [r7, #8]
1625:FreeRTOS/Source/tasks.c **** 		taskEXIT_CRITICAL();
 2299              		.loc 1 1625 0
 2300 002a FFF7FEFF 		bl	vPortExitCritical
1626:FreeRTOS/Source/tasks.c **** 
1627:FreeRTOS/Source/tasks.c **** 		return xReturn;
 2301              		.loc 1 1627 0
 2302 002e BB68     		ldr	r3, [r7, #8]
1628:FreeRTOS/Source/tasks.c **** 	}
 2303              		.loc 1 1628 0
 2304 0030 1846     		mov	r0, r3
 2305 0032 07F11007 		add	r7, r7, #16
 2306 0036 BD46     		mov	sp, r7
 2307 0038 80BD     		pop	{r7, pc}
 2308              		.cfi_endproc
 2309              	.LFE131:
 2311 003a 00BF     		.section	.text.xTaskCallApplicationTaskHook,"ax",%progbits
 2312              		.align	2
 2313              		.global	xTaskCallApplicationTaskHook
 2314              		.thumb
 2315              		.thumb_func
 2317              	xTaskCallApplicationTaskHook:
 2318              	.LFB132:
1629:FreeRTOS/Source/tasks.c **** 
1630:FreeRTOS/Source/tasks.c **** #endif
1631:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
1632:FreeRTOS/Source/tasks.c **** 
1633:FreeRTOS/Source/tasks.c **** #if ( configUSE_APPLICATION_TASK_TAG == 1 )
1634:FreeRTOS/Source/tasks.c **** 
1635:FreeRTOS/Source/tasks.c **** 	portBASE_TYPE xTaskCallApplicationTaskHook( xTaskHandle xTask, void *pvParameter )
1636:FreeRTOS/Source/tasks.c **** 	{
 2319              		.loc 1 1636 0
 2320              		.cfi_startproc
 2321              		@ args = 0, pretend = 0, frame = 16
 2322              		@ frame_needed = 1, uses_anonymous_args = 0
 2323 0000 80B5     		push	{r7, lr}
 2324              	.LCFI62:
 2325              		.cfi_def_cfa_offset 8
 2326              		.cfi_offset 14, -4
 2327              		.cfi_offset 7, -8
 2328 0002 84B0     		sub	sp, sp, #16
 2329              	.LCFI63:
 2330              		.cfi_def_cfa_offset 24
 2331 0004 00AF     		add	r7, sp, #0
 2332              	.LCFI64:
 2333              		.cfi_def_cfa_register 7
 2334 0006 7860     		str	r0, [r7, #4]
 2335 0008 3960     		str	r1, [r7, #0]
1637:FreeRTOS/Source/tasks.c **** 	tskTCB *xTCB;
1638:FreeRTOS/Source/tasks.c **** 	portBASE_TYPE xReturn;
1639:FreeRTOS/Source/tasks.c **** 
1640:FreeRTOS/Source/tasks.c **** 		/* If xTask is NULL then we are calling our own task hook. */
1641:FreeRTOS/Source/tasks.c **** 		if( xTask == NULL )
 2336              		.loc 1 1641 0
 2337 000a 7B68     		ldr	r3, [r7, #4]
 2338 000c 002B     		cmp	r3, #0
 2339 000e 06D1     		bne	.L99
1642:FreeRTOS/Source/tasks.c **** 		{
1643:FreeRTOS/Source/tasks.c **** 			xTCB = ( tskTCB * ) pxCurrentTCB;
 2340              		.loc 1 1643 0
 2341 0010 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 2342 0014 C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 2343 0018 1B68     		ldr	r3, [r3, #0]
 2344 001a FB60     		str	r3, [r7, #12]
 2345 001c 01E0     		b	.L100
 2346              	.L99:
1644:FreeRTOS/Source/tasks.c **** 		}
1645:FreeRTOS/Source/tasks.c **** 		else
1646:FreeRTOS/Source/tasks.c **** 		{
1647:FreeRTOS/Source/tasks.c **** 			xTCB = ( tskTCB * ) xTask;
 2347              		.loc 1 1647 0
 2348 001e 7B68     		ldr	r3, [r7, #4]
 2349 0020 FB60     		str	r3, [r7, #12]
 2350              	.L100:
1648:FreeRTOS/Source/tasks.c **** 		}
1649:FreeRTOS/Source/tasks.c **** 
1650:FreeRTOS/Source/tasks.c **** 		if( xTCB->pxTaskTag != NULL )
 2351              		.loc 1 1650 0
 2352 0022 FB68     		ldr	r3, [r7, #12]
 2353 0024 9B6C     		ldr	r3, [r3, #72]
 2354 0026 002B     		cmp	r3, #0
 2355 0028 05D0     		beq	.L101
1651:FreeRTOS/Source/tasks.c **** 		{
1652:FreeRTOS/Source/tasks.c **** 			xReturn = xTCB->pxTaskTag( pvParameter );
 2356              		.loc 1 1652 0
 2357 002a FB68     		ldr	r3, [r7, #12]
 2358 002c 9B6C     		ldr	r3, [r3, #72]
 2359 002e 3868     		ldr	r0, [r7, #0]
 2360 0030 9847     		blx	r3
 2361 0032 B860     		str	r0, [r7, #8]
 2362 0034 02E0     		b	.L102
 2363              	.L101:
1653:FreeRTOS/Source/tasks.c **** 		}
1654:FreeRTOS/Source/tasks.c **** 		else
1655:FreeRTOS/Source/tasks.c **** 		{
1656:FreeRTOS/Source/tasks.c **** 			xReturn = pdFAIL;
 2364              		.loc 1 1656 0
 2365 0036 4FF00003 		mov	r3, #0
 2366 003a BB60     		str	r3, [r7, #8]
 2367              	.L102:
1657:FreeRTOS/Source/tasks.c **** 		}
1658:FreeRTOS/Source/tasks.c **** 
1659:FreeRTOS/Source/tasks.c **** 		return xReturn;
 2368              		.loc 1 1659 0
 2369 003c BB68     		ldr	r3, [r7, #8]
1660:FreeRTOS/Source/tasks.c **** 	}
 2370              		.loc 1 1660 0
 2371 003e 1846     		mov	r0, r3
 2372 0040 07F11007 		add	r7, r7, #16
 2373 0044 BD46     		mov	sp, r7
 2374 0046 80BD     		pop	{r7, pc}
 2375              		.cfi_endproc
 2376              	.LFE132:
 2378              		.section	.text.vTaskSwitchContext,"ax",%progbits
 2379              		.align	2
 2380              		.global	vTaskSwitchContext
 2381              		.thumb
 2382              		.thumb_func
 2384              	vTaskSwitchContext:
 2385              	.LFB133:
1661:FreeRTOS/Source/tasks.c **** 
1662:FreeRTOS/Source/tasks.c **** #endif
1663:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
1664:FreeRTOS/Source/tasks.c **** 
1665:FreeRTOS/Source/tasks.c **** void vTaskSwitchContext( void )
1666:FreeRTOS/Source/tasks.c **** {
 2386              		.loc 1 1666 0
 2387              		.cfi_startproc
 2388              		@ args = 0, pretend = 0, frame = 8
 2389              		@ frame_needed = 1, uses_anonymous_args = 0
 2390 0000 80B5     		push	{r7, lr}
 2391              	.LCFI65:
 2392              		.cfi_def_cfa_offset 8
 2393              		.cfi_offset 14, -4
 2394              		.cfi_offset 7, -8
 2395 0002 82B0     		sub	sp, sp, #8
 2396              	.LCFI66:
 2397              		.cfi_def_cfa_offset 16
 2398 0004 00AF     		add	r7, sp, #0
 2399              	.LCFI67:
 2400              		.cfi_def_cfa_register 7
1667:FreeRTOS/Source/tasks.c **** 	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
 2401              		.loc 1 1667 0
 2402 0006 40F20003 		movw	r3, #:lower16:uxSchedulerSuspended
 2403 000a C0F20003 		movt	r3, #:upper16:uxSchedulerSuspended
 2404 000e 1B68     		ldr	r3, [r3, #0]
 2405 0010 002B     		cmp	r3, #0
 2406 0012 07D0     		beq	.L104
1668:FreeRTOS/Source/tasks.c **** 	{
1669:FreeRTOS/Source/tasks.c **** 		/* The scheduler is currently suspended - do not allow a context
1670:FreeRTOS/Source/tasks.c **** 		switch. */
1671:FreeRTOS/Source/tasks.c **** 		xMissedYield = pdTRUE;
 2407              		.loc 1 1671 0
 2408 0014 40F20003 		movw	r3, #:lower16:xMissedYield
 2409 0018 C0F20003 		movt	r3, #:upper16:xMissedYield
 2410 001c 4FF00102 		mov	r2, #1
 2411 0020 1A60     		str	r2, [r3, #0]
 2412 0022 71E0     		b	.L103
 2413              	.L104:
 2414              	.LBB6:
1672:FreeRTOS/Source/tasks.c **** 	}
1673:FreeRTOS/Source/tasks.c **** 	else
1674:FreeRTOS/Source/tasks.c **** 	{
1675:FreeRTOS/Source/tasks.c **** 		traceTASK_SWITCHED_OUT();
1676:FreeRTOS/Source/tasks.c **** 	
1677:FreeRTOS/Source/tasks.c **** 		#if ( configGENERATE_RUN_TIME_STATS == 1 )
1678:FreeRTOS/Source/tasks.c **** 		{
1679:FreeRTOS/Source/tasks.c **** 			unsigned long ulTempCounter;
1680:FreeRTOS/Source/tasks.c **** 			
1681:FreeRTOS/Source/tasks.c **** 				#ifdef portALT_GET_RUN_TIME_COUNTER_VALUE
1682:FreeRTOS/Source/tasks.c **** 					portALT_GET_RUN_TIME_COUNTER_VALUE( ulTempCounter );
1683:FreeRTOS/Source/tasks.c **** 				#else
1684:FreeRTOS/Source/tasks.c **** 					ulTempCounter = portGET_RUN_TIME_COUNTER_VALUE();
 2415              		.loc 1 1684 0
 2416 0024 FFF7FEFF 		bl	get_us_time
 2417 0028 0246     		mov	r2, r0
 2418 002a 0B46     		mov	r3, r1
 2419 002c 1346     		mov	r3, r2
 2420 002e 7B60     		str	r3, [r7, #4]
1685:FreeRTOS/Source/tasks.c **** 				#endif
1686:FreeRTOS/Source/tasks.c **** 	
1687:FreeRTOS/Source/tasks.c **** 				/* Add the amount of time the task has been running to the accumulated
1688:FreeRTOS/Source/tasks.c **** 				time so far.  The time the task started running was stored in
1689:FreeRTOS/Source/tasks.c **** 				ulTaskSwitchedInTime.  Note that there is no overflow protection here
1690:FreeRTOS/Source/tasks.c **** 				so count values are only valid until the timer overflows.  Generally
1691:FreeRTOS/Source/tasks.c **** 				this will be about 1 hour assuming a 1uS timer increment. */
1692:FreeRTOS/Source/tasks.c **** 				pxCurrentTCB->ulRunTimeCounter += ( ulTempCounter - ulTaskSwitchedInTime );
 2421              		.loc 1 1692 0
 2422 0030 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 2423 0034 C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 2424 0038 1A68     		ldr	r2, [r3, #0]
 2425 003a D16C     		ldr	r1, [r2, #76]
 2426 003c 40F20003 		movw	r3, #:lower16:ulTaskSwitchedInTime
 2427 0040 C0F20003 		movt	r3, #:upper16:ulTaskSwitchedInTime
 2428 0044 1B68     		ldr	r3, [r3, #0]
 2429 0046 7868     		ldr	r0, [r7, #4]
 2430 0048 C31A     		subs	r3, r0, r3
 2431 004a CB18     		adds	r3, r1, r3
 2432 004c D364     		str	r3, [r2, #76]
1693:FreeRTOS/Source/tasks.c **** 				ulTaskSwitchedInTime = ulTempCounter;
 2433              		.loc 1 1693 0
 2434 004e 40F20003 		movw	r3, #:lower16:ulTaskSwitchedInTime
 2435 0052 C0F20003 		movt	r3, #:upper16:ulTaskSwitchedInTime
 2436 0056 7A68     		ldr	r2, [r7, #4]
 2437 0058 1A60     		str	r2, [r3, #0]
 2438              	.LBE6:
1694:FreeRTOS/Source/tasks.c **** 		}
1695:FreeRTOS/Source/tasks.c **** 		#endif
1696:FreeRTOS/Source/tasks.c **** 	
1697:FreeRTOS/Source/tasks.c **** 		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
1698:FreeRTOS/Source/tasks.c **** 		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
1699:FreeRTOS/Source/tasks.c **** 	
1700:FreeRTOS/Source/tasks.c **** 		/* Find the highest priority queue that contains ready tasks. */
1701:FreeRTOS/Source/tasks.c **** 		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
 2439              		.loc 1 1701 0
 2440 005a 0BE0     		b	.L106
 2441              	.L107:
1702:FreeRTOS/Source/tasks.c **** 		{
1703:FreeRTOS/Source/tasks.c **** 			configASSERT( uxTopReadyPriority );
1704:FreeRTOS/Source/tasks.c **** 			--uxTopReadyPriority;
 2442              		.loc 1 1704 0
 2443 005c 40F20003 		movw	r3, #:lower16:uxTopReadyPriority
 2444 0060 C0F20003 		movt	r3, #:upper16:uxTopReadyPriority
 2445 0064 1B68     		ldr	r3, [r3, #0]
 2446 0066 03F1FF32 		add	r2, r3, #-1
 2447 006a 40F20003 		movw	r3, #:lower16:uxTopReadyPriority
 2448 006e C0F20003 		movt	r3, #:upper16:uxTopReadyPriority
 2449 0072 1A60     		str	r2, [r3, #0]
 2450              	.L106:
1701:FreeRTOS/Source/tasks.c **** 		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
 2451              		.loc 1 1701 0 discriminator 1
 2452 0074 40F20003 		movw	r3, #:lower16:uxTopReadyPriority
 2453 0078 C0F20003 		movt	r3, #:upper16:uxTopReadyPriority
 2454 007c 1A68     		ldr	r2, [r3, #0]
 2455 007e 1346     		mov	r3, r2
 2456 0080 4FEA8303 		lsl	r3, r3, #2
 2457 0084 9B18     		adds	r3, r3, r2
 2458 0086 4FEA8303 		lsl	r3, r3, #2
 2459 008a 1A46     		mov	r2, r3
 2460 008c 40F20003 		movw	r3, #:lower16:pxReadyTasksLists
 2461 0090 C0F20003 		movt	r3, #:upper16:pxReadyTasksLists
 2462 0094 D318     		adds	r3, r2, r3
 2463 0096 1B68     		ldr	r3, [r3, #0]
 2464 0098 002B     		cmp	r3, #0
 2465 009a DFD0     		beq	.L107
 2466              	.LBB7:
1705:FreeRTOS/Source/tasks.c **** 		}
1706:FreeRTOS/Source/tasks.c **** 	
1707:FreeRTOS/Source/tasks.c **** 		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
1708:FreeRTOS/Source/tasks.c **** 		same priority get an equal share of the processor time. */
1709:FreeRTOS/Source/tasks.c **** 		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
 2467              		.loc 1 1709 0
 2468 009c 40F20003 		movw	r3, #:lower16:uxTopReadyPriority
 2469 00a0 C0F20003 		movt	r3, #:upper16:uxTopReadyPriority
 2470 00a4 1A68     		ldr	r2, [r3, #0]
 2471 00a6 1346     		mov	r3, r2
 2472 00a8 4FEA8303 		lsl	r3, r3, #2
 2473 00ac 9B18     		adds	r3, r3, r2
 2474 00ae 4FEA8303 		lsl	r3, r3, #2
 2475 00b2 1A46     		mov	r2, r3
 2476 00b4 40F20003 		movw	r3, #:lower16:pxReadyTasksLists
 2477 00b8 C0F20003 		movt	r3, #:upper16:pxReadyTasksLists
 2478 00bc D318     		adds	r3, r2, r3
 2479 00be 3B60     		str	r3, [r7, #0]
 2480 00c0 3B68     		ldr	r3, [r7, #0]
 2481 00c2 5B68     		ldr	r3, [r3, #4]
 2482 00c4 5A68     		ldr	r2, [r3, #4]
 2483 00c6 3B68     		ldr	r3, [r7, #0]
 2484 00c8 5A60     		str	r2, [r3, #4]
 2485 00ca 3B68     		ldr	r3, [r7, #0]
 2486 00cc 5A68     		ldr	r2, [r3, #4]
 2487 00ce 3B68     		ldr	r3, [r7, #0]
 2488 00d0 03F10803 		add	r3, r3, #8
 2489 00d4 9A42     		cmp	r2, r3
 2490 00d6 04D1     		bne	.L108
 2491              		.loc 1 1709 0 is_stmt 0 discriminator 1
 2492 00d8 3B68     		ldr	r3, [r7, #0]
 2493 00da 5B68     		ldr	r3, [r3, #4]
 2494 00dc 5A68     		ldr	r2, [r3, #4]
 2495 00de 3B68     		ldr	r3, [r7, #0]
 2496 00e0 5A60     		str	r2, [r3, #4]
 2497              	.L108:
 2498              		.loc 1 1709 0 discriminator 2
 2499 00e2 3B68     		ldr	r3, [r7, #0]
 2500 00e4 5B68     		ldr	r3, [r3, #4]
 2501 00e6 DA68     		ldr	r2, [r3, #12]
 2502 00e8 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 2503 00ec C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 2504 00f0 1A60     		str	r2, [r3, #0]
 2505              	.LBE7:
1710:FreeRTOS/Source/tasks.c **** 	
1711:FreeRTOS/Source/tasks.c **** 		traceTASK_SWITCHED_IN();
 2506              		.loc 1 1711 0 is_stmt 1 discriminator 2
 2507 00f2 4FF4E843 		mov	r3, #29696
 2508 00f6 C4F20003 		movt	r3, 16384
 2509 00fa 40F20002 		movw	r2, #:lower16:pxCurrentTCB
 2510 00fe C0F20002 		movt	r2, #:upper16:pxCurrentTCB
 2511 0102 1268     		ldr	r2, [r2, #0]
 2512 0104 926C     		ldr	r2, [r2, #72]
 2513 0106 DA60     		str	r2, [r3, #12]
 2514              	.L103:
1712:FreeRTOS/Source/tasks.c **** 		vWriteTraceToBuffer();
1713:FreeRTOS/Source/tasks.c **** 	}
1714:FreeRTOS/Source/tasks.c **** }
 2515              		.loc 1 1714 0
 2516 0108 07F10807 		add	r7, r7, #8
 2517 010c BD46     		mov	sp, r7
 2518 010e 80BD     		pop	{r7, pc}
 2519              		.cfi_endproc
 2520              	.LFE133:
 2522              		.section	.text.vTaskPlaceOnEventList,"ax",%progbits
 2523              		.align	2
 2524              		.global	vTaskPlaceOnEventList
 2525              		.thumb
 2526              		.thumb_func
 2528              	vTaskPlaceOnEventList:
 2529              	.LFB134:
1715:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
1716:FreeRTOS/Source/tasks.c **** 
1717:FreeRTOS/Source/tasks.c **** void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
1718:FreeRTOS/Source/tasks.c **** {
 2530              		.loc 1 1718 0
 2531              		.cfi_startproc
 2532              		@ args = 0, pretend = 0, frame = 16
 2533              		@ frame_needed = 1, uses_anonymous_args = 0
 2534 0000 80B5     		push	{r7, lr}
 2535              	.LCFI68:
 2536              		.cfi_def_cfa_offset 8
 2537              		.cfi_offset 14, -4
 2538              		.cfi_offset 7, -8
 2539 0002 84B0     		sub	sp, sp, #16
 2540              	.LCFI69:
 2541              		.cfi_def_cfa_offset 24
 2542 0004 00AF     		add	r7, sp, #0
 2543              	.LCFI70:
 2544              		.cfi_def_cfa_register 7
 2545 0006 7860     		str	r0, [r7, #4]
 2546 0008 3960     		str	r1, [r7, #0]
1719:FreeRTOS/Source/tasks.c **** portTickType xTimeToWake;
1720:FreeRTOS/Source/tasks.c **** 
1721:FreeRTOS/Source/tasks.c **** 	configASSERT( pxEventList );
1722:FreeRTOS/Source/tasks.c **** 
1723:FreeRTOS/Source/tasks.c **** 	/* THIS FUNCTION MUST BE CALLED WITH INTERRUPTS DISABLED OR THE
1724:FreeRTOS/Source/tasks.c **** 	SCHEDULER SUSPENDED. */
1725:FreeRTOS/Source/tasks.c **** 
1726:FreeRTOS/Source/tasks.c **** 	/* Place the event list item of the TCB in the appropriate event list.
1727:FreeRTOS/Source/tasks.c **** 	This is placed in the list in priority order so the highest priority task
1728:FreeRTOS/Source/tasks.c **** 	is the first to be woken by the event. */
1729:FreeRTOS/Source/tasks.c **** 	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
 2547              		.loc 1 1729 0
 2548 000a 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 2549 000e C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 2550 0012 1B68     		ldr	r3, [r3, #0]
 2551 0014 03F11803 		add	r3, r3, #24
 2552 0018 7868     		ldr	r0, [r7, #4]
 2553 001a 1946     		mov	r1, r3
 2554 001c FFF7FEFF 		bl	vListInsert
1730:FreeRTOS/Source/tasks.c **** 
1731:FreeRTOS/Source/tasks.c **** 	/* We must remove ourselves from the ready list before adding ourselves
1732:FreeRTOS/Source/tasks.c **** 	to the blocked list as the same list item is used for both lists.  We have
1733:FreeRTOS/Source/tasks.c **** 	exclusive access to the ready lists as the scheduler is locked. */
1734:FreeRTOS/Source/tasks.c **** 	vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
 2555              		.loc 1 1734 0
 2556 0020 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 2557 0024 C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 2558 0028 1B68     		ldr	r3, [r3, #0]
 2559 002a 03F10403 		add	r3, r3, #4
 2560 002e 1846     		mov	r0, r3
 2561 0030 FFF7FEFF 		bl	vListRemove
1735:FreeRTOS/Source/tasks.c **** 
1736:FreeRTOS/Source/tasks.c **** 
1737:FreeRTOS/Source/tasks.c **** 	#if ( INCLUDE_vTaskSuspend == 1 )
1738:FreeRTOS/Source/tasks.c **** 	{
1739:FreeRTOS/Source/tasks.c **** 		if( xTicksToWait == portMAX_DELAY )
 2562              		.loc 1 1739 0
 2563 0034 3B68     		ldr	r3, [r7, #0]
 2564 0036 B3F1FF3F 		cmp	r3, #-1
 2565 003a 0ED1     		bne	.L110
1740:FreeRTOS/Source/tasks.c **** 		{
1741:FreeRTOS/Source/tasks.c **** 			/* Add ourselves to the suspended task list instead of a delayed task
1742:FreeRTOS/Source/tasks.c **** 			list to ensure we are not woken by a timing event.  We will block
1743:FreeRTOS/Source/tasks.c **** 			indefinitely. */
1744:FreeRTOS/Source/tasks.c **** 			vListInsertEnd( ( xList * ) &xSuspendedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListIt
 2566              		.loc 1 1744 0
 2567 003c 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 2568 0040 C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 2569 0044 1B68     		ldr	r3, [r3, #0]
 2570 0046 03F10403 		add	r3, r3, #4
 2571 004a 40F20000 		movw	r0, #:lower16:xSuspendedTaskList
 2572 004e C0F20000 		movt	r0, #:upper16:xSuspendedTaskList
 2573 0052 1946     		mov	r1, r3
 2574 0054 FFF7FEFF 		bl	vListInsertEnd
 2575 0058 0AE0     		b	.L109
 2576              	.L110:
1745:FreeRTOS/Source/tasks.c **** 		}
1746:FreeRTOS/Source/tasks.c **** 		else
1747:FreeRTOS/Source/tasks.c **** 		{
1748:FreeRTOS/Source/tasks.c **** 			/* Calculate the time at which the task should be woken if the event does
1749:FreeRTOS/Source/tasks.c **** 			not occur.  This may overflow but this doesn't matter. */
1750:FreeRTOS/Source/tasks.c **** 			xTimeToWake = xTickCount + xTicksToWait;
 2577              		.loc 1 1750 0
 2578 005a 40F20003 		movw	r3, #:lower16:xTickCount
 2579 005e C0F20003 		movt	r3, #:upper16:xTickCount
 2580 0062 1A68     		ldr	r2, [r3, #0]
 2581 0064 3B68     		ldr	r3, [r7, #0]
 2582 0066 D318     		adds	r3, r2, r3
 2583 0068 FB60     		str	r3, [r7, #12]
1751:FreeRTOS/Source/tasks.c **** 			prvAddCurrentTaskToDelayedList( xTimeToWake );
 2584              		.loc 1 1751 0
 2585 006a F868     		ldr	r0, [r7, #12]
 2586 006c FFF7FEFF 		bl	prvAddCurrentTaskToDelayedList
 2587              	.L109:
1752:FreeRTOS/Source/tasks.c **** 		}
1753:FreeRTOS/Source/tasks.c **** 	}
1754:FreeRTOS/Source/tasks.c **** 	#else
1755:FreeRTOS/Source/tasks.c **** 	{
1756:FreeRTOS/Source/tasks.c **** 			/* Calculate the time at which the task should be woken if the event does
1757:FreeRTOS/Source/tasks.c **** 			not occur.  This may overflow but this doesn't matter. */
1758:FreeRTOS/Source/tasks.c **** 			xTimeToWake = xTickCount + xTicksToWait;
1759:FreeRTOS/Source/tasks.c **** 			prvAddCurrentTaskToDelayedList( xTimeToWake );
1760:FreeRTOS/Source/tasks.c **** 	}
1761:FreeRTOS/Source/tasks.c **** 	#endif
1762:FreeRTOS/Source/tasks.c **** }
 2588              		.loc 1 1762 0
 2589 0070 07F11007 		add	r7, r7, #16
 2590 0074 BD46     		mov	sp, r7
 2591 0076 80BD     		pop	{r7, pc}
 2592              		.cfi_endproc
 2593              	.LFE134:
 2595              		.section	.text.xTaskRemoveFromEventList,"ax",%progbits
 2596              		.align	2
 2597              		.global	xTaskRemoveFromEventList
 2598              		.thumb
 2599              		.thumb_func
 2601              	xTaskRemoveFromEventList:
 2602              	.LFB135:
1763:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
1764:FreeRTOS/Source/tasks.c **** 
1765:FreeRTOS/Source/tasks.c **** #if configUSE_TIMERS == 1
1766:FreeRTOS/Source/tasks.c **** 
1767:FreeRTOS/Source/tasks.c **** 	void vTaskPlaceOnEventListRestricted( const xList * const pxEventList, portTickType xTicksToWait )
1768:FreeRTOS/Source/tasks.c **** 	{
1769:FreeRTOS/Source/tasks.c **** 	portTickType xTimeToWake;
1770:FreeRTOS/Source/tasks.c **** 
1771:FreeRTOS/Source/tasks.c **** 		configASSERT( pxEventList );
1772:FreeRTOS/Source/tasks.c **** 
1773:FreeRTOS/Source/tasks.c **** 		/* This function should not be called by application code hence the
1774:FreeRTOS/Source/tasks.c **** 		'Restricted' in its name.  It is not part of the public API.  It is
1775:FreeRTOS/Source/tasks.c **** 		designed for use by kernel code, and has special calling requirements -
1776:FreeRTOS/Source/tasks.c **** 		it should be called from a critical section. */
1777:FreeRTOS/Source/tasks.c **** 
1778:FreeRTOS/Source/tasks.c **** 	
1779:FreeRTOS/Source/tasks.c **** 		/* Place the event list item of the TCB in the appropriate event list.
1780:FreeRTOS/Source/tasks.c **** 		In this case it is assume that this is the only task that is going to
1781:FreeRTOS/Source/tasks.c **** 		be waiting on this event list, so the faster vListInsertEnd() function
1782:FreeRTOS/Source/tasks.c **** 		can be used in place of vListInsert. */
1783:FreeRTOS/Source/tasks.c **** 		vListInsertEnd( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
1784:FreeRTOS/Source/tasks.c **** 
1785:FreeRTOS/Source/tasks.c **** 		/* We must remove this task from the ready list before adding it to the
1786:FreeRTOS/Source/tasks.c **** 		blocked list as the same list item is used for both lists.  This
1787:FreeRTOS/Source/tasks.c **** 		function is called form a critical section. */
1788:FreeRTOS/Source/tasks.c **** 		vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
1789:FreeRTOS/Source/tasks.c **** 
1790:FreeRTOS/Source/tasks.c **** 		/* Calculate the time at which the task should be woken if the event does
1791:FreeRTOS/Source/tasks.c **** 		not occur.  This may overflow but this doesn't matter. */
1792:FreeRTOS/Source/tasks.c **** 		xTimeToWake = xTickCount + xTicksToWait;
1793:FreeRTOS/Source/tasks.c **** 		prvAddCurrentTaskToDelayedList( xTimeToWake );
1794:FreeRTOS/Source/tasks.c **** 	}
1795:FreeRTOS/Source/tasks.c **** 	
1796:FreeRTOS/Source/tasks.c **** #endif /* configUSE_TIMERS */
1797:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
1798:FreeRTOS/Source/tasks.c **** 
1799:FreeRTOS/Source/tasks.c **** signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
1800:FreeRTOS/Source/tasks.c **** {
 2603              		.loc 1 1800 0
 2604              		.cfi_startproc
 2605              		@ args = 0, pretend = 0, frame = 16
 2606              		@ frame_needed = 1, uses_anonymous_args = 0
 2607 0000 80B5     		push	{r7, lr}
 2608              	.LCFI71:
 2609              		.cfi_def_cfa_offset 8
 2610              		.cfi_offset 14, -4
 2611              		.cfi_offset 7, -8
 2612 0002 84B0     		sub	sp, sp, #16
 2613              	.LCFI72:
 2614              		.cfi_def_cfa_offset 24
 2615 0004 00AF     		add	r7, sp, #0
 2616              	.LCFI73:
 2617              		.cfi_def_cfa_register 7
 2618 0006 7860     		str	r0, [r7, #4]
1801:FreeRTOS/Source/tasks.c **** tskTCB *pxUnblockedTCB;
1802:FreeRTOS/Source/tasks.c **** portBASE_TYPE xReturn;
1803:FreeRTOS/Source/tasks.c **** 
1804:FreeRTOS/Source/tasks.c **** 	/* THIS FUNCTION MUST BE CALLED WITH INTERRUPTS DISABLED OR THE
1805:FreeRTOS/Source/tasks.c **** 	SCHEDULER SUSPENDED.  It can also be called from within an ISR. */
1806:FreeRTOS/Source/tasks.c **** 
1807:FreeRTOS/Source/tasks.c **** 	/* The event list is sorted in priority order, so we can remove the
1808:FreeRTOS/Source/tasks.c **** 	first in the list, remove the TCB from the delayed list, and add
1809:FreeRTOS/Source/tasks.c **** 	it to the ready list.
1810:FreeRTOS/Source/tasks.c **** 
1811:FreeRTOS/Source/tasks.c **** 	If an event is for a queue that is locked then this function will never
1812:FreeRTOS/Source/tasks.c **** 	get called - the lock count on the queue will get modified instead.  This
1813:FreeRTOS/Source/tasks.c **** 	means we can always expect exclusive access to the event list here.
1814:FreeRTOS/Source/tasks.c **** 	
1815:FreeRTOS/Source/tasks.c **** 	This function assumes that a check has already been made to ensure that
1816:FreeRTOS/Source/tasks.c **** 	pxEventList is not empty. */
1817:FreeRTOS/Source/tasks.c **** 	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
 2619              		.loc 1 1817 0
 2620 0008 7B68     		ldr	r3, [r7, #4]
 2621 000a DB68     		ldr	r3, [r3, #12]
 2622 000c DB68     		ldr	r3, [r3, #12]
 2623 000e BB60     		str	r3, [r7, #8]
1818:FreeRTOS/Source/tasks.c **** 	configASSERT( pxUnblockedTCB );
1819:FreeRTOS/Source/tasks.c **** 	vListRemove( &( pxUnblockedTCB->xEventListItem ) );
 2624              		.loc 1 1819 0
 2625 0010 BB68     		ldr	r3, [r7, #8]
 2626 0012 03F11803 		add	r3, r3, #24
 2627 0016 1846     		mov	r0, r3
 2628 0018 FFF7FEFF 		bl	vListRemove
1820:FreeRTOS/Source/tasks.c **** 
1821:FreeRTOS/Source/tasks.c **** 	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
 2629              		.loc 1 1821 0
 2630 001c 40F20003 		movw	r3, #:lower16:uxSchedulerSuspended
 2631 0020 C0F20003 		movt	r3, #:upper16:uxSchedulerSuspended
 2632 0024 1B68     		ldr	r3, [r3, #0]
 2633 0026 002B     		cmp	r3, #0
 2634 0028 2BD1     		bne	.L113
1822:FreeRTOS/Source/tasks.c **** 	{
1823:FreeRTOS/Source/tasks.c **** 		vListRemove( &( pxUnblockedTCB->xGenericListItem ) );
 2635              		.loc 1 1823 0
 2636 002a BB68     		ldr	r3, [r7, #8]
 2637 002c 03F10403 		add	r3, r3, #4
 2638 0030 1846     		mov	r0, r3
 2639 0032 FFF7FEFF 		bl	vListRemove
1824:FreeRTOS/Source/tasks.c **** 		prvAddTaskToReadyQueue( pxUnblockedTCB );
 2640              		.loc 1 1824 0
 2641 0036 BB68     		ldr	r3, [r7, #8]
 2642 0038 DA6A     		ldr	r2, [r3, #44]
 2643 003a 40F20003 		movw	r3, #:lower16:uxTopReadyPriority
 2644 003e C0F20003 		movt	r3, #:upper16:uxTopReadyPriority
 2645 0042 1B68     		ldr	r3, [r3, #0]
 2646 0044 9A42     		cmp	r2, r3
 2647 0046 06D9     		bls	.L114
 2648              		.loc 1 1824 0 is_stmt 0 discriminator 1
 2649 0048 BB68     		ldr	r3, [r7, #8]
 2650 004a DA6A     		ldr	r2, [r3, #44]
 2651 004c 40F20003 		movw	r3, #:lower16:uxTopReadyPriority
 2652 0050 C0F20003 		movt	r3, #:upper16:uxTopReadyPriority
 2653 0054 1A60     		str	r2, [r3, #0]
 2654              	.L114:
 2655              		.loc 1 1824 0 discriminator 2
 2656 0056 BB68     		ldr	r3, [r7, #8]
 2657 0058 DA6A     		ldr	r2, [r3, #44]
 2658 005a 1346     		mov	r3, r2
 2659 005c 4FEA8303 		lsl	r3, r3, #2
 2660 0060 9B18     		adds	r3, r3, r2
 2661 0062 4FEA8303 		lsl	r3, r3, #2
 2662 0066 1A46     		mov	r2, r3
 2663 0068 40F20003 		movw	r3, #:lower16:pxReadyTasksLists
 2664 006c C0F20003 		movt	r3, #:upper16:pxReadyTasksLists
 2665 0070 D218     		adds	r2, r2, r3
 2666 0072 BB68     		ldr	r3, [r7, #8]
 2667 0074 03F10403 		add	r3, r3, #4
 2668 0078 1046     		mov	r0, r2
 2669 007a 1946     		mov	r1, r3
 2670 007c FFF7FEFF 		bl	vListInsertEnd
 2671 0080 09E0     		b	.L115
 2672              	.L113:
1825:FreeRTOS/Source/tasks.c **** 	}
1826:FreeRTOS/Source/tasks.c **** 	else
1827:FreeRTOS/Source/tasks.c **** 	{
1828:FreeRTOS/Source/tasks.c **** 		/* We cannot access the delayed or ready lists, so will hold this
1829:FreeRTOS/Source/tasks.c **** 		task pending until the scheduler is resumed. */
1830:FreeRTOS/Source/tasks.c **** 		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
 2673              		.loc 1 1830 0 is_stmt 1
 2674 0082 BB68     		ldr	r3, [r7, #8]
 2675 0084 03F11803 		add	r3, r3, #24
 2676 0088 40F20000 		movw	r0, #:lower16:xPendingReadyList
 2677 008c C0F20000 		movt	r0, #:upper16:xPendingReadyList
 2678 0090 1946     		mov	r1, r3
 2679 0092 FFF7FEFF 		bl	vListInsertEnd
 2680              	.L115:
1831:FreeRTOS/Source/tasks.c **** 	}
1832:FreeRTOS/Source/tasks.c **** 
1833:FreeRTOS/Source/tasks.c **** 	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
 2681              		.loc 1 1833 0
 2682 0096 BB68     		ldr	r3, [r7, #8]
 2683 0098 DA6A     		ldr	r2, [r3, #44]
 2684 009a 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 2685 009e C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 2686 00a2 1B68     		ldr	r3, [r3, #0]
 2687 00a4 DB6A     		ldr	r3, [r3, #44]
 2688 00a6 9A42     		cmp	r2, r3
 2689 00a8 03D3     		bcc	.L116
1834:FreeRTOS/Source/tasks.c **** 	{
1835:FreeRTOS/Source/tasks.c **** 		/* Return true if the task removed from the event list has
1836:FreeRTOS/Source/tasks.c **** 		a higher priority than the calling task.  This allows
1837:FreeRTOS/Source/tasks.c **** 		the calling task to know if it should force a context
1838:FreeRTOS/Source/tasks.c **** 		switch now. */
1839:FreeRTOS/Source/tasks.c **** 		xReturn = pdTRUE;
 2690              		.loc 1 1839 0
 2691 00aa 4FF00103 		mov	r3, #1
 2692 00ae FB60     		str	r3, [r7, #12]
 2693 00b0 02E0     		b	.L117
 2694              	.L116:
1840:FreeRTOS/Source/tasks.c **** 	}
1841:FreeRTOS/Source/tasks.c **** 	else
1842:FreeRTOS/Source/tasks.c **** 	{
1843:FreeRTOS/Source/tasks.c **** 		xReturn = pdFALSE;
 2695              		.loc 1 1843 0
 2696 00b2 4FF00003 		mov	r3, #0
 2697 00b6 FB60     		str	r3, [r7, #12]
 2698              	.L117:
1844:FreeRTOS/Source/tasks.c **** 	}
1845:FreeRTOS/Source/tasks.c **** 
1846:FreeRTOS/Source/tasks.c **** 	return xReturn;
 2699              		.loc 1 1846 0
 2700 00b8 FB68     		ldr	r3, [r7, #12]
1847:FreeRTOS/Source/tasks.c **** }
 2701              		.loc 1 1847 0
 2702 00ba 1846     		mov	r0, r3
 2703 00bc 07F11007 		add	r7, r7, #16
 2704 00c0 BD46     		mov	sp, r7
 2705 00c2 80BD     		pop	{r7, pc}
 2706              		.cfi_endproc
 2707              	.LFE135:
 2709              		.section	.text.vTaskSetTimeOutState,"ax",%progbits
 2710              		.align	2
 2711              		.global	vTaskSetTimeOutState
 2712              		.thumb
 2713              		.thumb_func
 2715              	vTaskSetTimeOutState:
 2716              	.LFB136:
1848:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
1849:FreeRTOS/Source/tasks.c **** 
1850:FreeRTOS/Source/tasks.c **** void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
1851:FreeRTOS/Source/tasks.c **** {
 2717              		.loc 1 1851 0
 2718              		.cfi_startproc
 2719              		@ args = 0, pretend = 0, frame = 8
 2720              		@ frame_needed = 1, uses_anonymous_args = 0
 2721              		@ link register save eliminated.
 2722 0000 80B4     		push	{r7}
 2723              	.LCFI74:
 2724              		.cfi_def_cfa_offset 4
 2725              		.cfi_offset 7, -4
 2726 0002 83B0     		sub	sp, sp, #12
 2727              	.LCFI75:
 2728              		.cfi_def_cfa_offset 16
 2729 0004 00AF     		add	r7, sp, #0
 2730              	.LCFI76:
 2731              		.cfi_def_cfa_register 7
 2732 0006 7860     		str	r0, [r7, #4]
1852:FreeRTOS/Source/tasks.c **** 	configASSERT( pxTimeOut );
1853:FreeRTOS/Source/tasks.c **** 	pxTimeOut->xOverflowCount = xNumOfOverflows;
 2733              		.loc 1 1853 0
 2734 0008 40F20003 		movw	r3, #:lower16:xNumOfOverflows
 2735 000c C0F20003 		movt	r3, #:upper16:xNumOfOverflows
 2736 0010 1A68     		ldr	r2, [r3, #0]
 2737 0012 7B68     		ldr	r3, [r7, #4]
 2738 0014 1A60     		str	r2, [r3, #0]
1854:FreeRTOS/Source/tasks.c **** 	pxTimeOut->xTimeOnEntering = xTickCount;
 2739              		.loc 1 1854 0
 2740 0016 40F20003 		movw	r3, #:lower16:xTickCount
 2741 001a C0F20003 		movt	r3, #:upper16:xTickCount
 2742 001e 1A68     		ldr	r2, [r3, #0]
 2743 0020 7B68     		ldr	r3, [r7, #4]
 2744 0022 5A60     		str	r2, [r3, #4]
1855:FreeRTOS/Source/tasks.c **** }
 2745              		.loc 1 1855 0
 2746 0024 07F10C07 		add	r7, r7, #12
 2747 0028 BD46     		mov	sp, r7
 2748 002a 80BC     		pop	{r7}
 2749 002c 7047     		bx	lr
 2750              		.cfi_endproc
 2751              	.LFE136:
 2753 002e 00BF     		.section	.text.xTaskCheckForTimeOut,"ax",%progbits
 2754              		.align	2
 2755              		.global	xTaskCheckForTimeOut
 2756              		.thumb
 2757              		.thumb_func
 2759              	xTaskCheckForTimeOut:
 2760              	.LFB137:
1856:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
1857:FreeRTOS/Source/tasks.c **** 
1858:FreeRTOS/Source/tasks.c **** portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToW
1859:FreeRTOS/Source/tasks.c **** {
 2761              		.loc 1 1859 0
 2762              		.cfi_startproc
 2763              		@ args = 0, pretend = 0, frame = 16
 2764              		@ frame_needed = 1, uses_anonymous_args = 0
 2765 0000 80B5     		push	{r7, lr}
 2766              	.LCFI77:
 2767              		.cfi_def_cfa_offset 8
 2768              		.cfi_offset 14, -4
 2769              		.cfi_offset 7, -8
 2770 0002 84B0     		sub	sp, sp, #16
 2771              	.LCFI78:
 2772              		.cfi_def_cfa_offset 24
 2773 0004 00AF     		add	r7, sp, #0
 2774              	.LCFI79:
 2775              		.cfi_def_cfa_register 7
 2776 0006 7860     		str	r0, [r7, #4]
 2777 0008 3960     		str	r1, [r7, #0]
1860:FreeRTOS/Source/tasks.c **** portBASE_TYPE xReturn;
1861:FreeRTOS/Source/tasks.c **** 
1862:FreeRTOS/Source/tasks.c **** 	configASSERT( pxTimeOut );
1863:FreeRTOS/Source/tasks.c **** 	configASSERT( pxTicksToWait );
1864:FreeRTOS/Source/tasks.c **** 
1865:FreeRTOS/Source/tasks.c **** 	taskENTER_CRITICAL();
 2778              		.loc 1 1865 0
 2779 000a FFF7FEFF 		bl	vPortEnterCritical
1866:FreeRTOS/Source/tasks.c **** 	{
1867:FreeRTOS/Source/tasks.c **** 		#if ( INCLUDE_vTaskSuspend == 1 )
1868:FreeRTOS/Source/tasks.c **** 			/* If INCLUDE_vTaskSuspend is set to 1 and the block time specified is
1869:FreeRTOS/Source/tasks.c **** 			the maximum block time then the task should block indefinitely, and
1870:FreeRTOS/Source/tasks.c **** 			therefore never time out. */
1871:FreeRTOS/Source/tasks.c **** 			if( *pxTicksToWait == portMAX_DELAY )
 2780              		.loc 1 1871 0
 2781 000e 3B68     		ldr	r3, [r7, #0]
 2782 0010 1B68     		ldr	r3, [r3, #0]
 2783 0012 B3F1FF3F 		cmp	r3, #-1
 2784 0016 03D1     		bne	.L120
1872:FreeRTOS/Source/tasks.c **** 			{
1873:FreeRTOS/Source/tasks.c **** 				xReturn = pdFALSE;
 2785              		.loc 1 1873 0
 2786 0018 4FF00003 		mov	r3, #0
 2787 001c FB60     		str	r3, [r7, #12]
 2788 001e 38E0     		b	.L121
 2789              	.L120:
1874:FreeRTOS/Source/tasks.c **** 			}
1875:FreeRTOS/Source/tasks.c **** 			else /* We are not blocking indefinitely, perform the checks below. */
1876:FreeRTOS/Source/tasks.c **** 		#endif
1877:FreeRTOS/Source/tasks.c **** 
1878:FreeRTOS/Source/tasks.c **** 		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTi
 2790              		.loc 1 1878 0
 2791 0020 7B68     		ldr	r3, [r7, #4]
 2792 0022 1A68     		ldr	r2, [r3, #0]
 2793 0024 40F20003 		movw	r3, #:lower16:xNumOfOverflows
 2794 0028 C0F20003 		movt	r3, #:upper16:xNumOfOverflows
 2795 002c 1B68     		ldr	r3, [r3, #0]
 2796 002e 9A42     		cmp	r2, r3
 2797 0030 0CD0     		beq	.L122
 2798              		.loc 1 1878 0 is_stmt 0 discriminator 1
 2799 0032 7B68     		ldr	r3, [r7, #4]
 2800 0034 5A68     		ldr	r2, [r3, #4]
 2801 0036 40F20003 		movw	r3, #:lower16:xTickCount
 2802 003a C0F20003 		movt	r3, #:upper16:xTickCount
 2803 003e 1B68     		ldr	r3, [r3, #0]
 2804 0040 9A42     		cmp	r2, r3
 2805 0042 03D8     		bhi	.L122
1879:FreeRTOS/Source/tasks.c **** 		{
1880:FreeRTOS/Source/tasks.c **** 			/* The tick count is greater than the time at which vTaskSetTimeout()
1881:FreeRTOS/Source/tasks.c **** 			was called, but has also overflowed since vTaskSetTimeOut() was called.
1882:FreeRTOS/Source/tasks.c **** 			It must have wrapped all the way around and gone past us again. This
1883:FreeRTOS/Source/tasks.c **** 			passed since vTaskSetTimeout() was called. */
1884:FreeRTOS/Source/tasks.c **** 			xReturn = pdTRUE;
 2806              		.loc 1 1884 0 is_stmt 1
 2807 0044 4FF00103 		mov	r3, #1
 2808 0048 FB60     		str	r3, [r7, #12]
 2809 004a 22E0     		b	.L121
 2810              	.L122:
1885:FreeRTOS/Source/tasks.c **** 		}
1886:FreeRTOS/Source/tasks.c **** 		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEn
 2811              		.loc 1 1886 0
 2812 004c 40F20003 		movw	r3, #:lower16:xTickCount
 2813 0050 C0F20003 		movt	r3, #:upper16:xTickCount
 2814 0054 1A68     		ldr	r2, [r3, #0]
 2815 0056 7B68     		ldr	r3, [r7, #4]
 2816 0058 5B68     		ldr	r3, [r3, #4]
 2817 005a D21A     		subs	r2, r2, r3
 2818 005c 3B68     		ldr	r3, [r7, #0]
 2819 005e 1B68     		ldr	r3, [r3, #0]
 2820 0060 9A42     		cmp	r2, r3
 2821 0062 13D2     		bcs	.L123
1887:FreeRTOS/Source/tasks.c **** 		{
1888:FreeRTOS/Source/tasks.c **** 			/* Not a genuine timeout. Adjust parameters for time remaining. */
1889:FreeRTOS/Source/tasks.c **** 			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
 2822              		.loc 1 1889 0
 2823 0064 3B68     		ldr	r3, [r7, #0]
 2824 0066 1A68     		ldr	r2, [r3, #0]
 2825 0068 7B68     		ldr	r3, [r7, #4]
 2826 006a 5968     		ldr	r1, [r3, #4]
 2827 006c 40F20003 		movw	r3, #:lower16:xTickCount
 2828 0070 C0F20003 		movt	r3, #:upper16:xTickCount
 2829 0074 1B68     		ldr	r3, [r3, #0]
 2830 0076 CB1A     		subs	r3, r1, r3
 2831 0078 D218     		adds	r2, r2, r3
 2832 007a 3B68     		ldr	r3, [r7, #0]
 2833 007c 1A60     		str	r2, [r3, #0]
1890:FreeRTOS/Source/tasks.c **** 			vTaskSetTimeOutState( pxTimeOut );
 2834              		.loc 1 1890 0
 2835 007e 7868     		ldr	r0, [r7, #4]
 2836 0080 FFF7FEFF 		bl	vTaskSetTimeOutState
1891:FreeRTOS/Source/tasks.c **** 			xReturn = pdFALSE;
 2837              		.loc 1 1891 0
 2838 0084 4FF00003 		mov	r3, #0
 2839 0088 FB60     		str	r3, [r7, #12]
 2840 008a 02E0     		b	.L121
 2841              	.L123:
1892:FreeRTOS/Source/tasks.c **** 		}
1893:FreeRTOS/Source/tasks.c **** 		else
1894:FreeRTOS/Source/tasks.c **** 		{
1895:FreeRTOS/Source/tasks.c **** 			xReturn = pdTRUE;
 2842              		.loc 1 1895 0
 2843 008c 4FF00103 		mov	r3, #1
 2844 0090 FB60     		str	r3, [r7, #12]
 2845              	.L121:
1896:FreeRTOS/Source/tasks.c **** 		}
1897:FreeRTOS/Source/tasks.c **** 	}
1898:FreeRTOS/Source/tasks.c **** 	taskEXIT_CRITICAL();
 2846              		.loc 1 1898 0
 2847 0092 FFF7FEFF 		bl	vPortExitCritical
1899:FreeRTOS/Source/tasks.c **** 
1900:FreeRTOS/Source/tasks.c **** 	return xReturn;
 2848              		.loc 1 1900 0
 2849 0096 FB68     		ldr	r3, [r7, #12]
1901:FreeRTOS/Source/tasks.c **** }
 2850              		.loc 1 1901 0
 2851 0098 1846     		mov	r0, r3
 2852 009a 07F11007 		add	r7, r7, #16
 2853 009e BD46     		mov	sp, r7
 2854 00a0 80BD     		pop	{r7, pc}
 2855              		.cfi_endproc
 2856              	.LFE137:
 2858 00a2 00BF     		.section	.text.vTaskMissedYield,"ax",%progbits
 2859              		.align	2
 2860              		.global	vTaskMissedYield
 2861              		.thumb
 2862              		.thumb_func
 2864              	vTaskMissedYield:
 2865              	.LFB138:
1902:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
1903:FreeRTOS/Source/tasks.c **** 
1904:FreeRTOS/Source/tasks.c **** void vTaskMissedYield( void )
1905:FreeRTOS/Source/tasks.c **** {
 2866              		.loc 1 1905 0
 2867              		.cfi_startproc
 2868              		@ args = 0, pretend = 0, frame = 0
 2869              		@ frame_needed = 1, uses_anonymous_args = 0
 2870              		@ link register save eliminated.
 2871 0000 80B4     		push	{r7}
 2872              	.LCFI80:
 2873              		.cfi_def_cfa_offset 4
 2874              		.cfi_offset 7, -4
 2875 0002 00AF     		add	r7, sp, #0
 2876              	.LCFI81:
 2877              		.cfi_def_cfa_register 7
1906:FreeRTOS/Source/tasks.c **** 	xMissedYield = pdTRUE;
 2878              		.loc 1 1906 0
 2879 0004 40F20003 		movw	r3, #:lower16:xMissedYield
 2880 0008 C0F20003 		movt	r3, #:upper16:xMissedYield
 2881 000c 4FF00102 		mov	r2, #1
 2882 0010 1A60     		str	r2, [r3, #0]
1907:FreeRTOS/Source/tasks.c **** }
 2883              		.loc 1 1907 0
 2884 0012 BD46     		mov	sp, r7
 2885 0014 80BC     		pop	{r7}
 2886 0016 7047     		bx	lr
 2887              		.cfi_endproc
 2888              	.LFE138:
 2890              		.section	.text.prvIdleTask,"ax",%progbits
 2891              		.align	2
 2892              		.thumb
 2893              		.thumb_func
 2895              	prvIdleTask:
 2896              	.LFB139:
1908:FreeRTOS/Source/tasks.c **** 
1909:FreeRTOS/Source/tasks.c **** /*
1910:FreeRTOS/Source/tasks.c ****  * -----------------------------------------------------------
1911:FreeRTOS/Source/tasks.c ****  * The Idle task.
1912:FreeRTOS/Source/tasks.c ****  * ----------------------------------------------------------
1913:FreeRTOS/Source/tasks.c ****  *
1914:FreeRTOS/Source/tasks.c ****  * The portTASK_FUNCTION() macro is used to allow port/compiler specific
1915:FreeRTOS/Source/tasks.c ****  * language extensions.  The equivalent prototype for this function is:
1916:FreeRTOS/Source/tasks.c ****  *
1917:FreeRTOS/Source/tasks.c ****  * void prvIdleTask( void *pvParameters );
1918:FreeRTOS/Source/tasks.c ****  *
1919:FreeRTOS/Source/tasks.c ****  */
1920:FreeRTOS/Source/tasks.c **** static portTASK_FUNCTION( prvIdleTask, pvParameters )
1921:FreeRTOS/Source/tasks.c **** {
 2897              		.loc 1 1921 0
 2898              		.cfi_startproc
 2899              		@ args = 0, pretend = 0, frame = 8
 2900              		@ frame_needed = 1, uses_anonymous_args = 0
 2901 0000 80B5     		push	{r7, lr}
 2902              	.LCFI82:
 2903              		.cfi_def_cfa_offset 8
 2904              		.cfi_offset 14, -4
 2905              		.cfi_offset 7, -8
 2906 0002 82B0     		sub	sp, sp, #8
 2907              	.LCFI83:
 2908              		.cfi_def_cfa_offset 16
 2909 0004 00AF     		add	r7, sp, #0
 2910              	.LCFI84:
 2911              		.cfi_def_cfa_register 7
 2912 0006 7860     		str	r0, [r7, #4]
 2913 0008 00E0     		b	.L127
 2914              	.L128:
1922:FreeRTOS/Source/tasks.c **** 	/* Stop warnings. */
1923:FreeRTOS/Source/tasks.c **** 	( void ) pvParameters;
1924:FreeRTOS/Source/tasks.c **** 
1925:FreeRTOS/Source/tasks.c **** 	for( ;; )
1926:FreeRTOS/Source/tasks.c **** 	{
1927:FreeRTOS/Source/tasks.c **** 		/* See if any tasks have been deleted. */
1928:FreeRTOS/Source/tasks.c **** 		prvCheckTasksWaitingTermination();
1929:FreeRTOS/Source/tasks.c **** 
1930:FreeRTOS/Source/tasks.c **** 		#if ( configUSE_PREEMPTION == 0 )
1931:FreeRTOS/Source/tasks.c **** 		{
1932:FreeRTOS/Source/tasks.c **** 			/* If we are not using preemption we keep forcing a task switch to
1933:FreeRTOS/Source/tasks.c **** 			see if any other task has become available.  If we are using
1934:FreeRTOS/Source/tasks.c **** 			preemption we don't need to do this as any task becoming available
1935:FreeRTOS/Source/tasks.c **** 			will automatically get the processor anyway. */
1936:FreeRTOS/Source/tasks.c **** 			taskYIELD();
1937:FreeRTOS/Source/tasks.c **** 		}
1938:FreeRTOS/Source/tasks.c **** 		#endif
1939:FreeRTOS/Source/tasks.c **** 
1940:FreeRTOS/Source/tasks.c **** 		#if ( ( configUSE_PREEMPTION == 1 ) && ( configIDLE_SHOULD_YIELD == 1 ) )
1941:FreeRTOS/Source/tasks.c **** 		{
1942:FreeRTOS/Source/tasks.c **** 			/* When using preemption tasks of equal priority will be
1943:FreeRTOS/Source/tasks.c **** 			timesliced.  If a task that is sharing the idle priority is ready
1944:FreeRTOS/Source/tasks.c **** 			to run then the idle task should yield before the end of the
1945:FreeRTOS/Source/tasks.c **** 			timeslice.
1946:FreeRTOS/Source/tasks.c **** 
1947:FreeRTOS/Source/tasks.c **** 			A critical region is not required here as we are just reading from
1948:FreeRTOS/Source/tasks.c **** 			the list, and an occasional incorrect value will not matter.  If
1949:FreeRTOS/Source/tasks.c **** 			the ready list at the idle priority contains more than one task
1950:FreeRTOS/Source/tasks.c **** 			then a task other than the idle task is ready to execute. */
1951:FreeRTOS/Source/tasks.c **** 			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_
1952:FreeRTOS/Source/tasks.c **** 			{
1953:FreeRTOS/Source/tasks.c **** 				taskYIELD();
1954:FreeRTOS/Source/tasks.c **** 			}
1955:FreeRTOS/Source/tasks.c **** 		}
1956:FreeRTOS/Source/tasks.c **** 		#endif
1957:FreeRTOS/Source/tasks.c **** 
1958:FreeRTOS/Source/tasks.c **** 		#if ( configUSE_IDLE_HOOK == 1 )
1959:FreeRTOS/Source/tasks.c **** 		{
1960:FreeRTOS/Source/tasks.c **** 			extern void vApplicationIdleHook( void );
1961:FreeRTOS/Source/tasks.c **** 
1962:FreeRTOS/Source/tasks.c **** 			/* Call the user defined function from within the idle task.  This
1963:FreeRTOS/Source/tasks.c **** 			allows the application designer to add background functionality
1964:FreeRTOS/Source/tasks.c **** 			without the overhead of a separate task.
1965:FreeRTOS/Source/tasks.c **** 			NOTE: vApplicationIdleHook() MUST NOT, UNDER ANY CIRCUMSTANCES,
1966:FreeRTOS/Source/tasks.c **** 			CALL A FUNCTION THAT MIGHT BLOCK. */
1967:FreeRTOS/Source/tasks.c **** 			vApplicationIdleHook();
1968:FreeRTOS/Source/tasks.c **** 		}
1969:FreeRTOS/Source/tasks.c **** 		#endif
1970:FreeRTOS/Source/tasks.c **** 	}
 2915              		.loc 1 1970 0
 2916 000a 00BF     		nop
 2917              	.L127:
1928:FreeRTOS/Source/tasks.c **** 		prvCheckTasksWaitingTermination();
 2918              		.loc 1 1928 0
 2919 000c FFF7FEFF 		bl	prvCheckTasksWaitingTermination
1951:FreeRTOS/Source/tasks.c **** 			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_
 2920              		.loc 1 1951 0
 2921 0010 40F20003 		movw	r3, #:lower16:pxReadyTasksLists
 2922 0014 C0F20003 		movt	r3, #:upper16:pxReadyTasksLists
 2923 0018 1B68     		ldr	r3, [r3, #0]
 2924 001a 012B     		cmp	r3, #1
 2925 001c F5D9     		bls	.L128
1953:FreeRTOS/Source/tasks.c **** 				taskYIELD();
 2926              		.loc 1 1953 0
 2927 001e FFF7FEFF 		bl	vPortYieldFromISR
 2928              		.loc 1 1970 0
 2929 0022 F2E7     		b	.L128
 2930              		.cfi_endproc
 2931              	.LFE139:
 2933              		.section	.text.prvInitialiseTCBVariables,"ax",%progbits
 2934              		.align	2
 2935              		.thumb
 2936              		.thumb_func
 2938              	prvInitialiseTCBVariables:
 2939              	.LFB140:
1971:FreeRTOS/Source/tasks.c **** } /*lint !e715 pvParameters is not accessed but all task functions require the same prototype. */
1972:FreeRTOS/Source/tasks.c **** 
1973:FreeRTOS/Source/tasks.c **** 
1974:FreeRTOS/Source/tasks.c **** 
1975:FreeRTOS/Source/tasks.c **** 
1976:FreeRTOS/Source/tasks.c **** 
1977:FreeRTOS/Source/tasks.c **** 
1978:FreeRTOS/Source/tasks.c **** 
1979:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------
1980:FreeRTOS/Source/tasks.c ****  * File private functions documented at the top of the file.
1981:FreeRTOS/Source/tasks.c ****  *----------------------------------------------------------*/
1982:FreeRTOS/Source/tasks.c **** 
1983:FreeRTOS/Source/tasks.c **** 
1984:FreeRTOS/Source/tasks.c **** 
1985:FreeRTOS/Source/tasks.c **** static void prvInitialiseTCBVariables( tskTCB *pxTCB, const signed char * const pcName, unsigned po
1986:FreeRTOS/Source/tasks.c **** {
 2940              		.loc 1 1986 0
 2941              		.cfi_startproc
 2942              		@ args = 4, pretend = 0, frame = 16
 2943              		@ frame_needed = 1, uses_anonymous_args = 0
 2944 0000 80B5     		push	{r7, lr}
 2945              	.LCFI85:
 2946              		.cfi_def_cfa_offset 8
 2947              		.cfi_offset 14, -4
 2948              		.cfi_offset 7, -8
 2949 0002 84B0     		sub	sp, sp, #16
 2950              	.LCFI86:
 2951              		.cfi_def_cfa_offset 24
 2952 0004 00AF     		add	r7, sp, #0
 2953              	.LCFI87:
 2954              		.cfi_def_cfa_register 7
 2955 0006 F860     		str	r0, [r7, #12]
 2956 0008 B960     		str	r1, [r7, #8]
 2957 000a 7A60     		str	r2, [r7, #4]
 2958 000c 3B60     		str	r3, [r7, #0]
1987:FreeRTOS/Source/tasks.c **** 	/* Store the function name in the TCB. */
1988:FreeRTOS/Source/tasks.c **** 	#if configMAX_TASK_NAME_LEN > 1
1989:FreeRTOS/Source/tasks.c **** 	{
1990:FreeRTOS/Source/tasks.c **** 		/* Don't bring strncpy into the build unnecessarily. */
1991:FreeRTOS/Source/tasks.c **** 		strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned short ) configMAX_TASK
 2959              		.loc 1 1991 0
 2960 000e FB68     		ldr	r3, [r7, #12]
 2961 0010 03F13403 		add	r3, r3, #52
 2962 0014 1846     		mov	r0, r3
 2963 0016 B968     		ldr	r1, [r7, #8]
 2964 0018 4FF01002 		mov	r2, #16
 2965 001c FFF7FEFF 		bl	strncpy
1992:FreeRTOS/Source/tasks.c **** 	}
1993:FreeRTOS/Source/tasks.c **** 	#endif
1994:FreeRTOS/Source/tasks.c **** 	pxTCB->pcTaskName[ ( unsigned short ) configMAX_TASK_NAME_LEN - ( unsigned short ) 1 ] = ( signed 
 2966              		.loc 1 1994 0
 2967 0020 FB68     		ldr	r3, [r7, #12]
 2968 0022 4FF00002 		mov	r2, #0
 2969 0026 83F84320 		strb	r2, [r3, #67]
1995:FreeRTOS/Source/tasks.c **** 
1996:FreeRTOS/Source/tasks.c **** 	/* This is used as an array index so must ensure it's not too large.  First
1997:FreeRTOS/Source/tasks.c **** 	remove the privilege bit if one is present. */
1998:FreeRTOS/Source/tasks.c **** 	if( uxPriority >= configMAX_PRIORITIES )
 2970              		.loc 1 1998 0
 2971 002a 7B68     		ldr	r3, [r7, #4]
 2972 002c 042B     		cmp	r3, #4
 2973 002e 02D9     		bls	.L130
1999:FreeRTOS/Source/tasks.c **** 	{
2000:FreeRTOS/Source/tasks.c **** 		uxPriority = configMAX_PRIORITIES - ( unsigned portBASE_TYPE ) 1U;
 2974              		.loc 1 2000 0
 2975 0030 4FF00403 		mov	r3, #4
 2976 0034 7B60     		str	r3, [r7, #4]
 2977              	.L130:
2001:FreeRTOS/Source/tasks.c **** 	}
2002:FreeRTOS/Source/tasks.c **** 
2003:FreeRTOS/Source/tasks.c **** 	pxTCB->uxPriority = uxPriority;
 2978              		.loc 1 2003 0
 2979 0036 FB68     		ldr	r3, [r7, #12]
 2980 0038 7A68     		ldr	r2, [r7, #4]
 2981 003a DA62     		str	r2, [r3, #44]
2004:FreeRTOS/Source/tasks.c **** 	#if ( configUSE_MUTEXES == 1 )
2005:FreeRTOS/Source/tasks.c **** 	{
2006:FreeRTOS/Source/tasks.c **** 		pxTCB->uxBasePriority = uxPriority;
 2982              		.loc 1 2006 0
 2983 003c FB68     		ldr	r3, [r7, #12]
 2984 003e 7A68     		ldr	r2, [r7, #4]
 2985 0040 5A64     		str	r2, [r3, #68]
2007:FreeRTOS/Source/tasks.c **** 	}
2008:FreeRTOS/Source/tasks.c **** 	#endif
2009:FreeRTOS/Source/tasks.c **** 
2010:FreeRTOS/Source/tasks.c **** 	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
 2986              		.loc 1 2010 0
 2987 0042 FB68     		ldr	r3, [r7, #12]
 2988 0044 03F10403 		add	r3, r3, #4
 2989 0048 1846     		mov	r0, r3
 2990 004a FFF7FEFF 		bl	vListInitialiseItem
2011:FreeRTOS/Source/tasks.c **** 	vListInitialiseItem( &( pxTCB->xEventListItem ) );
 2991              		.loc 1 2011 0
 2992 004e FB68     		ldr	r3, [r7, #12]
 2993 0050 03F11803 		add	r3, r3, #24
 2994 0054 1846     		mov	r0, r3
 2995 0056 FFF7FEFF 		bl	vListInitialiseItem
2012:FreeRTOS/Source/tasks.c **** 
2013:FreeRTOS/Source/tasks.c **** 	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
2014:FreeRTOS/Source/tasks.c **** 	back to	the containing TCB from a generic item in a list. */
2015:FreeRTOS/Source/tasks.c **** 	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
 2996              		.loc 1 2015 0
 2997 005a FB68     		ldr	r3, [r7, #12]
 2998 005c FA68     		ldr	r2, [r7, #12]
 2999 005e 1A61     		str	r2, [r3, #16]
2016:FreeRTOS/Source/tasks.c **** 
2017:FreeRTOS/Source/tasks.c **** 	/* Event lists are always in priority order. */
2018:FreeRTOS/Source/tasks.c **** 	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPri
 3000              		.loc 1 2018 0
 3001 0060 7B68     		ldr	r3, [r7, #4]
 3002 0062 C3F10502 		rsb	r2, r3, #5
 3003 0066 FB68     		ldr	r3, [r7, #12]
 3004 0068 9A61     		str	r2, [r3, #24]
2019:FreeRTOS/Source/tasks.c **** 	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
 3005              		.loc 1 2019 0
 3006 006a FB68     		ldr	r3, [r7, #12]
 3007 006c FA68     		ldr	r2, [r7, #12]
 3008 006e 5A62     		str	r2, [r3, #36]
2020:FreeRTOS/Source/tasks.c **** 
2021:FreeRTOS/Source/tasks.c **** 	#if ( portCRITICAL_NESTING_IN_TCB == 1 )
2022:FreeRTOS/Source/tasks.c **** 	{
2023:FreeRTOS/Source/tasks.c **** 		pxTCB->uxCriticalNesting = ( unsigned portBASE_TYPE ) 0U;
2024:FreeRTOS/Source/tasks.c **** 	}
2025:FreeRTOS/Source/tasks.c **** 	#endif
2026:FreeRTOS/Source/tasks.c **** 
2027:FreeRTOS/Source/tasks.c **** 	#if ( configUSE_APPLICATION_TASK_TAG == 1 )
2028:FreeRTOS/Source/tasks.c **** 	{
2029:FreeRTOS/Source/tasks.c **** 		pxTCB->pxTaskTag = NULL;
 3009              		.loc 1 2029 0
 3010 0070 FB68     		ldr	r3, [r7, #12]
 3011 0072 4FF00002 		mov	r2, #0
 3012 0076 9A64     		str	r2, [r3, #72]
2030:FreeRTOS/Source/tasks.c **** 	}
2031:FreeRTOS/Source/tasks.c **** 	#endif
2032:FreeRTOS/Source/tasks.c **** 
2033:FreeRTOS/Source/tasks.c **** 	#if ( configGENERATE_RUN_TIME_STATS == 1 )
2034:FreeRTOS/Source/tasks.c **** 	{
2035:FreeRTOS/Source/tasks.c **** 		pxTCB->ulRunTimeCounter = 0UL;
 3013              		.loc 1 2035 0
 3014 0078 FB68     		ldr	r3, [r7, #12]
 3015 007a 4FF00002 		mov	r2, #0
 3016 007e DA64     		str	r2, [r3, #76]
2036:FreeRTOS/Source/tasks.c **** 	}
2037:FreeRTOS/Source/tasks.c **** 	#endif
2038:FreeRTOS/Source/tasks.c **** 
2039:FreeRTOS/Source/tasks.c **** 	#if ( portUSING_MPU_WRAPPERS == 1 )
2040:FreeRTOS/Source/tasks.c **** 	{
2041:FreeRTOS/Source/tasks.c **** 		vPortStoreTaskMPUSettings( &( pxTCB->xMPUSettings ), xRegions, pxTCB->pxStack, usStackDepth );
2042:FreeRTOS/Source/tasks.c **** 	}
2043:FreeRTOS/Source/tasks.c **** 	#else
2044:FreeRTOS/Source/tasks.c **** 	{
2045:FreeRTOS/Source/tasks.c **** 		( void ) xRegions;
2046:FreeRTOS/Source/tasks.c **** 		( void ) usStackDepth;
2047:FreeRTOS/Source/tasks.c **** 	}
2048:FreeRTOS/Source/tasks.c **** 	#endif
2049:FreeRTOS/Source/tasks.c **** }
 3017              		.loc 1 2049 0
 3018 0080 07F11007 		add	r7, r7, #16
 3019 0084 BD46     		mov	sp, r7
 3020 0086 80BD     		pop	{r7, pc}
 3021              		.cfi_endproc
 3022              	.LFE140:
 3024              		.section	.text.prvInitialiseTaskLists,"ax",%progbits
 3025              		.align	2
 3026              		.thumb
 3027              		.thumb_func
 3029              	prvInitialiseTaskLists:
 3030              	.LFB141:
2050:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
2051:FreeRTOS/Source/tasks.c **** 
2052:FreeRTOS/Source/tasks.c **** #if ( portUSING_MPU_WRAPPERS == 1 )
2053:FreeRTOS/Source/tasks.c **** 
2054:FreeRTOS/Source/tasks.c **** 	void vTaskAllocateMPURegions( xTaskHandle xTaskToModify, const xMemoryRegion * const xRegions )
2055:FreeRTOS/Source/tasks.c **** 	{
2056:FreeRTOS/Source/tasks.c **** 	tskTCB *pxTCB;
2057:FreeRTOS/Source/tasks.c **** 	
2058:FreeRTOS/Source/tasks.c **** 		if( xTaskToModify == pxCurrentTCB )
2059:FreeRTOS/Source/tasks.c **** 		{
2060:FreeRTOS/Source/tasks.c **** 			xTaskToModify = NULL;
2061:FreeRTOS/Source/tasks.c **** 		}
2062:FreeRTOS/Source/tasks.c **** 
2063:FreeRTOS/Source/tasks.c **** 		/* If null is passed in here then we are deleting ourselves. */
2064:FreeRTOS/Source/tasks.c **** 		pxTCB = prvGetTCBFromHandle( xTaskToModify );
2065:FreeRTOS/Source/tasks.c **** 
2066:FreeRTOS/Source/tasks.c ****         vPortStoreTaskMPUSettings( &( pxTCB->xMPUSettings ), xRegions, NULL, 0 );
2067:FreeRTOS/Source/tasks.c **** 	}
2068:FreeRTOS/Source/tasks.c **** 	/*-----------------------------------------------------------*/
2069:FreeRTOS/Source/tasks.c **** #endif
2070:FreeRTOS/Source/tasks.c **** 
2071:FreeRTOS/Source/tasks.c **** static void prvInitialiseTaskLists( void )
2072:FreeRTOS/Source/tasks.c **** {
 3031              		.loc 1 2072 0
 3032              		.cfi_startproc
 3033              		@ args = 0, pretend = 0, frame = 8
 3034              		@ frame_needed = 1, uses_anonymous_args = 0
 3035 0000 80B5     		push	{r7, lr}
 3036              	.LCFI88:
 3037              		.cfi_def_cfa_offset 8
 3038              		.cfi_offset 14, -4
 3039              		.cfi_offset 7, -8
 3040 0002 82B0     		sub	sp, sp, #8
 3041              	.LCFI89:
 3042              		.cfi_def_cfa_offset 16
 3043 0004 00AF     		add	r7, sp, #0
 3044              	.LCFI90:
 3045              		.cfi_def_cfa_register 7
2073:FreeRTOS/Source/tasks.c **** unsigned portBASE_TYPE uxPriority;
2074:FreeRTOS/Source/tasks.c **** 
2075:FreeRTOS/Source/tasks.c **** 	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
 3046              		.loc 1 2075 0
 3047 0006 4FF00003 		mov	r3, #0
 3048 000a 7B60     		str	r3, [r7, #4]
 3049 000c 13E0     		b	.L132
 3050              	.L133:
2076:FreeRTOS/Source/tasks.c **** 	{
2077:FreeRTOS/Source/tasks.c **** 		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
 3051              		.loc 1 2077 0 discriminator 2
 3052 000e 7A68     		ldr	r2, [r7, #4]
 3053 0010 1346     		mov	r3, r2
 3054 0012 4FEA8303 		lsl	r3, r3, #2
 3055 0016 9B18     		adds	r3, r3, r2
 3056 0018 4FEA8303 		lsl	r3, r3, #2
 3057 001c 1A46     		mov	r2, r3
 3058 001e 40F20003 		movw	r3, #:lower16:pxReadyTasksLists
 3059 0022 C0F20003 		movt	r3, #:upper16:pxReadyTasksLists
 3060 0026 D318     		adds	r3, r2, r3
 3061 0028 1846     		mov	r0, r3
 3062 002a FFF7FEFF 		bl	vListInitialise
2075:FreeRTOS/Source/tasks.c **** 	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
 3063              		.loc 1 2075 0 discriminator 2
 3064 002e 7B68     		ldr	r3, [r7, #4]
 3065 0030 03F10103 		add	r3, r3, #1
 3066 0034 7B60     		str	r3, [r7, #4]
 3067              	.L132:
2075:FreeRTOS/Source/tasks.c **** 	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
 3068              		.loc 1 2075 0 is_stmt 0 discriminator 1
 3069 0036 7B68     		ldr	r3, [r7, #4]
 3070 0038 042B     		cmp	r3, #4
 3071 003a E8D9     		bls	.L133
2078:FreeRTOS/Source/tasks.c **** 	}
2079:FreeRTOS/Source/tasks.c **** 
2080:FreeRTOS/Source/tasks.c **** 	vListInitialise( ( xList * ) &xDelayedTaskList1 );
 3072              		.loc 1 2080 0 is_stmt 1
 3073 003c 40F20000 		movw	r0, #:lower16:xDelayedTaskList1
 3074 0040 C0F20000 		movt	r0, #:upper16:xDelayedTaskList1
 3075 0044 FFF7FEFF 		bl	vListInitialise
2081:FreeRTOS/Source/tasks.c **** 	vListInitialise( ( xList * ) &xDelayedTaskList2 );
 3076              		.loc 1 2081 0
 3077 0048 40F20000 		movw	r0, #:lower16:xDelayedTaskList2
 3078 004c C0F20000 		movt	r0, #:upper16:xDelayedTaskList2
 3079 0050 FFF7FEFF 		bl	vListInitialise
2082:FreeRTOS/Source/tasks.c **** 	vListInitialise( ( xList * ) &xPendingReadyList );
 3080              		.loc 1 2082 0
 3081 0054 40F20000 		movw	r0, #:lower16:xPendingReadyList
 3082 0058 C0F20000 		movt	r0, #:upper16:xPendingReadyList
 3083 005c FFF7FEFF 		bl	vListInitialise
2083:FreeRTOS/Source/tasks.c **** 
2084:FreeRTOS/Source/tasks.c **** 	#if ( INCLUDE_vTaskDelete == 1 )
2085:FreeRTOS/Source/tasks.c **** 	{
2086:FreeRTOS/Source/tasks.c **** 		vListInitialise( ( xList * ) &xTasksWaitingTermination );
 3084              		.loc 1 2086 0
 3085 0060 40F20000 		movw	r0, #:lower16:xTasksWaitingTermination
 3086 0064 C0F20000 		movt	r0, #:upper16:xTasksWaitingTermination
 3087 0068 FFF7FEFF 		bl	vListInitialise
2087:FreeRTOS/Source/tasks.c **** 	}
2088:FreeRTOS/Source/tasks.c **** 	#endif
2089:FreeRTOS/Source/tasks.c **** 
2090:FreeRTOS/Source/tasks.c **** 	#if ( INCLUDE_vTaskSuspend == 1 )
2091:FreeRTOS/Source/tasks.c **** 	{
2092:FreeRTOS/Source/tasks.c **** 		vListInitialise( ( xList * ) &xSuspendedTaskList );
 3088              		.loc 1 2092 0
 3089 006c 40F20000 		movw	r0, #:lower16:xSuspendedTaskList
 3090 0070 C0F20000 		movt	r0, #:upper16:xSuspendedTaskList
 3091 0074 FFF7FEFF 		bl	vListInitialise
2093:FreeRTOS/Source/tasks.c **** 	}
2094:FreeRTOS/Source/tasks.c **** 	#endif
2095:FreeRTOS/Source/tasks.c **** 
2096:FreeRTOS/Source/tasks.c **** 	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
2097:FreeRTOS/Source/tasks.c **** 	using list2. */
2098:FreeRTOS/Source/tasks.c **** 	pxDelayedTaskList = &xDelayedTaskList1;
 3092              		.loc 1 2098 0
 3093 0078 40F20003 		movw	r3, #:lower16:pxDelayedTaskList
 3094 007c C0F20003 		movt	r3, #:upper16:pxDelayedTaskList
 3095 0080 40F20002 		movw	r2, #:lower16:xDelayedTaskList1
 3096 0084 C0F20002 		movt	r2, #:upper16:xDelayedTaskList1
 3097 0088 1A60     		str	r2, [r3, #0]
2099:FreeRTOS/Source/tasks.c **** 	pxOverflowDelayedTaskList = &xDelayedTaskList2;
 3098              		.loc 1 2099 0
 3099 008a 40F20003 		movw	r3, #:lower16:pxOverflowDelayedTaskList
 3100 008e C0F20003 		movt	r3, #:upper16:pxOverflowDelayedTaskList
 3101 0092 40F20002 		movw	r2, #:lower16:xDelayedTaskList2
 3102 0096 C0F20002 		movt	r2, #:upper16:xDelayedTaskList2
 3103 009a 1A60     		str	r2, [r3, #0]
2100:FreeRTOS/Source/tasks.c **** }
 3104              		.loc 1 2100 0
 3105 009c 07F10807 		add	r7, r7, #8
 3106 00a0 BD46     		mov	sp, r7
 3107 00a2 80BD     		pop	{r7, pc}
 3108              		.cfi_endproc
 3109              	.LFE141:
 3111              		.section	.text.prvCheckTasksWaitingTermination,"ax",%progbits
 3112              		.align	2
 3113              		.thumb
 3114              		.thumb_func
 3116              	prvCheckTasksWaitingTermination:
 3117              	.LFB142:
2101:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
2102:FreeRTOS/Source/tasks.c **** 
2103:FreeRTOS/Source/tasks.c **** static void prvCheckTasksWaitingTermination( void )
2104:FreeRTOS/Source/tasks.c **** {
 3118              		.loc 1 2104 0
 3119              		.cfi_startproc
 3120              		@ args = 0, pretend = 0, frame = 8
 3121              		@ frame_needed = 1, uses_anonymous_args = 0
 3122 0000 80B5     		push	{r7, lr}
 3123              	.LCFI91:
 3124              		.cfi_def_cfa_offset 8
 3125              		.cfi_offset 14, -4
 3126              		.cfi_offset 7, -8
 3127 0002 82B0     		sub	sp, sp, #8
 3128              	.LCFI92:
 3129              		.cfi_def_cfa_offset 16
 3130 0004 00AF     		add	r7, sp, #0
 3131              	.LCFI93:
 3132              		.cfi_def_cfa_register 7
 3133              	.LBB8:
2105:FreeRTOS/Source/tasks.c **** 	#if ( INCLUDE_vTaskDelete == 1 )
2106:FreeRTOS/Source/tasks.c **** 	{
2107:FreeRTOS/Source/tasks.c **** 		portBASE_TYPE xListIsEmpty;
2108:FreeRTOS/Source/tasks.c **** 
2109:FreeRTOS/Source/tasks.c **** 		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
2110:FreeRTOS/Source/tasks.c **** 		too often in the idle task. */
2111:FreeRTOS/Source/tasks.c **** 		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0U )
 3134              		.loc 1 2111 0
 3135 0006 40F20003 		movw	r3, #:lower16:uxTasksDeleted
 3136 000a C0F20003 		movt	r3, #:upper16:uxTasksDeleted
 3137 000e 1B68     		ldr	r3, [r3, #0]
 3138 0010 002B     		cmp	r3, #0
 3139 0012 3CD0     		beq	.L134
2112:FreeRTOS/Source/tasks.c **** 		{
2113:FreeRTOS/Source/tasks.c **** 			vTaskSuspendAll();
 3140              		.loc 1 2113 0
 3141 0014 FFF7FEFF 		bl	vTaskSuspendAll
2114:FreeRTOS/Source/tasks.c **** 				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
 3142              		.loc 1 2114 0
 3143 0018 40F20003 		movw	r3, #:lower16:xTasksWaitingTermination
 3144 001c C0F20003 		movt	r3, #:upper16:xTasksWaitingTermination
 3145 0020 1B68     		ldr	r3, [r3, #0]
 3146 0022 002B     		cmp	r3, #0
 3147 0024 14BF     		ite	ne
 3148 0026 0023     		movne	r3, #0
 3149 0028 0123     		moveq	r3, #1
 3150 002a 7B60     		str	r3, [r7, #4]
2115:FreeRTOS/Source/tasks.c **** 			xTaskResumeAll();
 3151              		.loc 1 2115 0
 3152 002c FFF7FEFF 		bl	xTaskResumeAll
2116:FreeRTOS/Source/tasks.c **** 
2117:FreeRTOS/Source/tasks.c **** 			if( xListIsEmpty == pdFALSE )
 3153              		.loc 1 2117 0
 3154 0030 7B68     		ldr	r3, [r7, #4]
 3155 0032 002B     		cmp	r3, #0
 3156 0034 2BD1     		bne	.L134
 3157              	.LBB9:
2118:FreeRTOS/Source/tasks.c **** 			{
2119:FreeRTOS/Source/tasks.c **** 				tskTCB *pxTCB;
2120:FreeRTOS/Source/tasks.c **** 
2121:FreeRTOS/Source/tasks.c **** 				taskENTER_CRITICAL();
 3158              		.loc 1 2121 0
 3159 0036 FFF7FEFF 		bl	vPortEnterCritical
2122:FreeRTOS/Source/tasks.c **** 				{
2123:FreeRTOS/Source/tasks.c **** 					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
 3160              		.loc 1 2123 0
 3161 003a 40F20003 		movw	r3, #:lower16:xTasksWaitingTermination
 3162 003e C0F20003 		movt	r3, #:upper16:xTasksWaitingTermination
 3163 0042 DB68     		ldr	r3, [r3, #12]
 3164 0044 DB68     		ldr	r3, [r3, #12]
 3165 0046 3B60     		str	r3, [r7, #0]
2124:FreeRTOS/Source/tasks.c **** 					vListRemove( &( pxTCB->xGenericListItem ) );
 3166              		.loc 1 2124 0
 3167 0048 3B68     		ldr	r3, [r7, #0]
 3168 004a 03F10403 		add	r3, r3, #4
 3169 004e 1846     		mov	r0, r3
 3170 0050 FFF7FEFF 		bl	vListRemove
2125:FreeRTOS/Source/tasks.c **** 					--uxCurrentNumberOfTasks;
 3171              		.loc 1 2125 0
 3172 0054 40F20003 		movw	r3, #:lower16:uxCurrentNumberOfTasks
 3173 0058 C0F20003 		movt	r3, #:upper16:uxCurrentNumberOfTasks
 3174 005c 1B68     		ldr	r3, [r3, #0]
 3175 005e 03F1FF32 		add	r2, r3, #-1
 3176 0062 40F20003 		movw	r3, #:lower16:uxCurrentNumberOfTasks
 3177 0066 C0F20003 		movt	r3, #:upper16:uxCurrentNumberOfTasks
 3178 006a 1A60     		str	r2, [r3, #0]
2126:FreeRTOS/Source/tasks.c **** 					--uxTasksDeleted;
 3179              		.loc 1 2126 0
 3180 006c 40F20003 		movw	r3, #:lower16:uxTasksDeleted
 3181 0070 C0F20003 		movt	r3, #:upper16:uxTasksDeleted
 3182 0074 1B68     		ldr	r3, [r3, #0]
 3183 0076 03F1FF32 		add	r2, r3, #-1
 3184 007a 40F20003 		movw	r3, #:lower16:uxTasksDeleted
 3185 007e C0F20003 		movt	r3, #:upper16:uxTasksDeleted
 3186 0082 1A60     		str	r2, [r3, #0]
2127:FreeRTOS/Source/tasks.c **** 				}
2128:FreeRTOS/Source/tasks.c **** 				taskEXIT_CRITICAL();
 3187              		.loc 1 2128 0
 3188 0084 FFF7FEFF 		bl	vPortExitCritical
2129:FreeRTOS/Source/tasks.c **** 
2130:FreeRTOS/Source/tasks.c **** 				prvDeleteTCB( pxTCB );
 3189              		.loc 1 2130 0
 3190 0088 3868     		ldr	r0, [r7, #0]
 3191 008a FFF7FEFF 		bl	prvDeleteTCB
 3192              	.L134:
 3193              	.LBE9:
 3194              	.LBE8:
2131:FreeRTOS/Source/tasks.c **** 			}
2132:FreeRTOS/Source/tasks.c **** 		}
2133:FreeRTOS/Source/tasks.c **** 	}
2134:FreeRTOS/Source/tasks.c **** 	#endif
2135:FreeRTOS/Source/tasks.c **** }
 3195              		.loc 1 2135 0
 3196 008e 07F10807 		add	r7, r7, #8
 3197 0092 BD46     		mov	sp, r7
 3198 0094 80BD     		pop	{r7, pc}
 3199              		.cfi_endproc
 3200              	.LFE142:
 3202 0096 00BF     		.section	.text.prvAddCurrentTaskToDelayedList,"ax",%progbits
 3203              		.align	2
 3204              		.thumb
 3205              		.thumb_func
 3207              	prvAddCurrentTaskToDelayedList:
 3208              	.LFB143:
2136:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
2137:FreeRTOS/Source/tasks.c **** 
2138:FreeRTOS/Source/tasks.c **** static void prvAddCurrentTaskToDelayedList( portTickType xTimeToWake )
2139:FreeRTOS/Source/tasks.c **** {
 3209              		.loc 1 2139 0
 3210              		.cfi_startproc
 3211              		@ args = 0, pretend = 0, frame = 8
 3212              		@ frame_needed = 1, uses_anonymous_args = 0
 3213 0000 80B5     		push	{r7, lr}
 3214              	.LCFI94:
 3215              		.cfi_def_cfa_offset 8
 3216              		.cfi_offset 14, -4
 3217              		.cfi_offset 7, -8
 3218 0002 82B0     		sub	sp, sp, #8
 3219              	.LCFI95:
 3220              		.cfi_def_cfa_offset 16
 3221 0004 00AF     		add	r7, sp, #0
 3222              	.LCFI96:
 3223              		.cfi_def_cfa_register 7
 3224 0006 7860     		str	r0, [r7, #4]
2140:FreeRTOS/Source/tasks.c **** 	/* The list item will be inserted in wake time order. */
2141:FreeRTOS/Source/tasks.c **** 	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
 3225              		.loc 1 2141 0
 3226 0008 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 3227 000c C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 3228 0010 1B68     		ldr	r3, [r3, #0]
 3229 0012 7A68     		ldr	r2, [r7, #4]
 3230 0014 5A60     		str	r2, [r3, #4]
2142:FreeRTOS/Source/tasks.c **** 
2143:FreeRTOS/Source/tasks.c **** 	if( xTimeToWake < xTickCount )
 3231              		.loc 1 2143 0
 3232 0016 40F20003 		movw	r3, #:lower16:xTickCount
 3233 001a C0F20003 		movt	r3, #:upper16:xTickCount
 3234 001e 1B68     		ldr	r3, [r3, #0]
 3235 0020 7A68     		ldr	r2, [r7, #4]
 3236 0022 9A42     		cmp	r2, r3
 3237 0024 10D2     		bcs	.L137
2144:FreeRTOS/Source/tasks.c **** 	{
2145:FreeRTOS/Source/tasks.c **** 		/* Wake time has overflowed.  Place this item in the overflow list. */
2146:FreeRTOS/Source/tasks.c **** 		vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericList
 3238              		.loc 1 2146 0
 3239 0026 40F20003 		movw	r3, #:lower16:pxOverflowDelayedTaskList
 3240 002a C0F20003 		movt	r3, #:upper16:pxOverflowDelayedTaskList
 3241 002e 1A68     		ldr	r2, [r3, #0]
 3242 0030 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 3243 0034 C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 3244 0038 1B68     		ldr	r3, [r3, #0]
 3245 003a 03F10403 		add	r3, r3, #4
 3246 003e 1046     		mov	r0, r2
 3247 0040 1946     		mov	r1, r3
 3248 0042 FFF7FEFF 		bl	vListInsert
 3249 0046 1DE0     		b	.L136
 3250              	.L137:
2147:FreeRTOS/Source/tasks.c **** 	}
2148:FreeRTOS/Source/tasks.c **** 	else
2149:FreeRTOS/Source/tasks.c **** 	{
2150:FreeRTOS/Source/tasks.c **** 		/* The wake time has not overflowed, so we can use the current block list. */
2151:FreeRTOS/Source/tasks.c **** 		vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) )
 3251              		.loc 1 2151 0
 3252 0048 40F20003 		movw	r3, #:lower16:pxDelayedTaskList
 3253 004c C0F20003 		movt	r3, #:upper16:pxDelayedTaskList
 3254 0050 1A68     		ldr	r2, [r3, #0]
 3255 0052 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 3256 0056 C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 3257 005a 1B68     		ldr	r3, [r3, #0]
 3258 005c 03F10403 		add	r3, r3, #4
 3259 0060 1046     		mov	r0, r2
 3260 0062 1946     		mov	r1, r3
 3261 0064 FFF7FEFF 		bl	vListInsert
2152:FreeRTOS/Source/tasks.c **** 
2153:FreeRTOS/Source/tasks.c **** 		/* If the task entering the blocked state was placed at the head of the
2154:FreeRTOS/Source/tasks.c **** 		list of blocked tasks then xNextTaskUnblockTime needs to be updated
2155:FreeRTOS/Source/tasks.c **** 		too. */
2156:FreeRTOS/Source/tasks.c **** 		if( xTimeToWake < xNextTaskUnblockTime )
 3262              		.loc 1 2156 0
 3263 0068 40F20003 		movw	r3, #:lower16:xNextTaskUnblockTime
 3264 006c C0F20003 		movt	r3, #:upper16:xNextTaskUnblockTime
 3265 0070 1B68     		ldr	r3, [r3, #0]
 3266 0072 7A68     		ldr	r2, [r7, #4]
 3267 0074 9A42     		cmp	r2, r3
 3268 0076 05D2     		bcs	.L136
2157:FreeRTOS/Source/tasks.c **** 		{
2158:FreeRTOS/Source/tasks.c **** 			xNextTaskUnblockTime = xTimeToWake;
 3269              		.loc 1 2158 0
 3270 0078 40F20003 		movw	r3, #:lower16:xNextTaskUnblockTime
 3271 007c C0F20003 		movt	r3, #:upper16:xNextTaskUnblockTime
 3272 0080 7A68     		ldr	r2, [r7, #4]
 3273 0082 1A60     		str	r2, [r3, #0]
 3274              	.L136:
2159:FreeRTOS/Source/tasks.c **** 		}
2160:FreeRTOS/Source/tasks.c **** 	}
2161:FreeRTOS/Source/tasks.c **** }
 3275              		.loc 1 2161 0
 3276 0084 07F10807 		add	r7, r7, #8
 3277 0088 BD46     		mov	sp, r7
 3278 008a 80BD     		pop	{r7, pc}
 3279              		.cfi_endproc
 3280              	.LFE143:
 3282              		.section	.text.prvAllocateTCBAndStack,"ax",%progbits
 3283              		.align	2
 3284              		.thumb
 3285              		.thumb_func
 3287              	prvAllocateTCBAndStack:
 3288              	.LFB144:
2162:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
2163:FreeRTOS/Source/tasks.c **** 
2164:FreeRTOS/Source/tasks.c **** static tskTCB *prvAllocateTCBAndStack( unsigned short usStackDepth, portSTACK_TYPE *puxStackBuffer 
2165:FreeRTOS/Source/tasks.c **** {
 3289              		.loc 1 2165 0
 3290              		.cfi_startproc
 3291              		@ args = 0, pretend = 0, frame = 16
 3292              		@ frame_needed = 1, uses_anonymous_args = 0
 3293 0000 80B5     		push	{r7, lr}
 3294              	.LCFI97:
 3295              		.cfi_def_cfa_offset 8
 3296              		.cfi_offset 14, -4
 3297              		.cfi_offset 7, -8
 3298 0002 84B0     		sub	sp, sp, #16
 3299              	.LCFI98:
 3300              		.cfi_def_cfa_offset 24
 3301 0004 00AF     		add	r7, sp, #0
 3302              	.LCFI99:
 3303              		.cfi_def_cfa_register 7
 3304 0006 0346     		mov	r3, r0
 3305 0008 3960     		str	r1, [r7, #0]
 3306 000a FB80     		strh	r3, [r7, #6]	@ movhi
2166:FreeRTOS/Source/tasks.c **** tskTCB *pxNewTCB;
2167:FreeRTOS/Source/tasks.c **** 
2168:FreeRTOS/Source/tasks.c **** 	/* Allocate space for the TCB.  Where the memory comes from depends on
2169:FreeRTOS/Source/tasks.c **** 	the implementation of the port malloc function. */
2170:FreeRTOS/Source/tasks.c **** 	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
 3307              		.loc 1 2170 0
 3308 000c 4FF05000 		mov	r0, #80
 3309 0010 FFF7FEFF 		bl	malloc
 3310 0014 0346     		mov	r3, r0
 3311 0016 FB60     		str	r3, [r7, #12]
2171:FreeRTOS/Source/tasks.c **** 
2172:FreeRTOS/Source/tasks.c **** 	if( pxNewTCB != NULL )
 3312              		.loc 1 2172 0
 3313 0018 FB68     		ldr	r3, [r7, #12]
 3314 001a 002B     		cmp	r3, #0
 3315 001c 23D0     		beq	.L140
2173:FreeRTOS/Source/tasks.c **** 	{
2174:FreeRTOS/Source/tasks.c **** 		/* Allocate space for the stack used by the task being created.
2175:FreeRTOS/Source/tasks.c **** 		The base of the stack memory stored in the TCB so the task can
2176:FreeRTOS/Source/tasks.c **** 		be deleted later if required. */
2177:FreeRTOS/Source/tasks.c **** 		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * size
 3316              		.loc 1 2177 0
 3317 001e 3B68     		ldr	r3, [r7, #0]
 3318 0020 002B     		cmp	r3, #0
 3319 0022 07D1     		bne	.L141
 3320              		.loc 1 2177 0 is_stmt 0 discriminator 1
 3321 0024 FB88     		ldrh	r3, [r7, #6]
 3322 0026 4FEA8303 		lsl	r3, r3, #2
 3323 002a 1846     		mov	r0, r3
 3324 002c FFF7FEFF 		bl	malloc
 3325 0030 0346     		mov	r3, r0
 3326 0032 00E0     		b	.L142
 3327              	.L141:
 3328              		.loc 1 2177 0 discriminator 2
 3329 0034 3B68     		ldr	r3, [r7, #0]
 3330              	.L142:
 3331              		.loc 1 2177 0 discriminator 3
 3332 0036 FA68     		ldr	r2, [r7, #12]
 3333 0038 1363     		str	r3, [r2, #48]
2178:FreeRTOS/Source/tasks.c **** 
2179:FreeRTOS/Source/tasks.c **** 		if( pxNewTCB->pxStack == NULL )
 3334              		.loc 1 2179 0 is_stmt 1 discriminator 3
 3335 003a FB68     		ldr	r3, [r7, #12]
 3336 003c 1B6B     		ldr	r3, [r3, #48]
 3337 003e 002B     		cmp	r3, #0
 3338 0040 06D1     		bne	.L143
2180:FreeRTOS/Source/tasks.c **** 		{
2181:FreeRTOS/Source/tasks.c **** 			/* Could not allocate the stack.  Delete the allocated TCB. */
2182:FreeRTOS/Source/tasks.c **** 			vPortFree( pxNewTCB );
 3339              		.loc 1 2182 0
 3340 0042 F868     		ldr	r0, [r7, #12]
 3341 0044 FFF7FEFF 		bl	free
2183:FreeRTOS/Source/tasks.c **** 			pxNewTCB = NULL;
 3342              		.loc 1 2183 0
 3343 0048 4FF00003 		mov	r3, #0
 3344 004c FB60     		str	r3, [r7, #12]
 3345 004e 0AE0     		b	.L140
 3346              	.L143:
2184:FreeRTOS/Source/tasks.c **** 		}
2185:FreeRTOS/Source/tasks.c **** 		else
2186:FreeRTOS/Source/tasks.c **** 		{
2187:FreeRTOS/Source/tasks.c **** 			/* Just to help debugging. */
2188:FreeRTOS/Source/tasks.c **** 			memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) usStackDepth * sizeof( portSTA
 3347              		.loc 1 2188 0
 3348 0050 FB68     		ldr	r3, [r7, #12]
 3349 0052 1A6B     		ldr	r2, [r3, #48]
 3350 0054 FB88     		ldrh	r3, [r7, #6]
 3351 0056 4FEA8303 		lsl	r3, r3, #2
 3352 005a 1046     		mov	r0, r2
 3353 005c 4FF0A501 		mov	r1, #165
 3354 0060 1A46     		mov	r2, r3
 3355 0062 FFF7FEFF 		bl	memset
 3356              	.L140:
2189:FreeRTOS/Source/tasks.c **** 		}
2190:FreeRTOS/Source/tasks.c **** 	}
2191:FreeRTOS/Source/tasks.c **** 
2192:FreeRTOS/Source/tasks.c **** 	return pxNewTCB;
 3357              		.loc 1 2192 0
 3358 0066 FB68     		ldr	r3, [r7, #12]
2193:FreeRTOS/Source/tasks.c **** }
 3359              		.loc 1 2193 0
 3360 0068 1846     		mov	r0, r3
 3361 006a 07F11007 		add	r7, r7, #16
 3362 006e BD46     		mov	sp, r7
 3363 0070 80BD     		pop	{r7, pc}
 3364              		.cfi_endproc
 3365              	.LFE144:
 3367 0072 00BF     		.section	.rodata
 3368 000b 00       		.align	2
 3369              	.LC2:
 3370 000c 25752020 		.ascii	"%u  %c  %-16s          0   0%%  %5u\015\012\000"
 3370      25632020 
 3370      252D3136 
 3370      73202020 
 3370      20202020 
 3371 0032 0000     		.align	2
 3372              	.LC3:
 3373 0034 25752020 		.ascii	"%u  %c  %-16s %10u %3u%%  %5u\015\012\000"
 3373      25632020 
 3373      252D3136 
 3373      73202531 
 3373      30752025 
 3374              		.align	2
 3375              	.LC4:
 3376 0054 25752020 		.ascii	"%u  %c  %-16s %10u  <1%%  %5u\015\012\000"
 3376      25632020 
 3376      252D3136 
 3376      73202531 
 3376      30752020 
 3377              		.section	.text.prvGenerateRunTimeStatsForTasksInList,"ax",%progbits
 3378              		.align	2
 3379              		.thumb
 3380              		.thumb_func
 3382              	prvGenerateRunTimeStatsForTasksInList:
 3383              	.LFB145:
2194:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
2195:FreeRTOS/Source/tasks.c **** 
2196:FreeRTOS/Source/tasks.c **** #if ( configUSE_TRACE_FACILITY == 1 )
2197:FreeRTOS/Source/tasks.c **** 
2198:FreeRTOS/Source/tasks.c **** 	static void prvListTaskWithinSingleList( const signed char *pcWriteBuffer, xList *pxList, signed c
2199:FreeRTOS/Source/tasks.c **** 	{
2200:FreeRTOS/Source/tasks.c **** 	volatile tskTCB *pxNextTCB, *pxFirstTCB;
2201:FreeRTOS/Source/tasks.c **** 	unsigned short usStackRemaining;
2202:FreeRTOS/Source/tasks.c **** 
2203:FreeRTOS/Source/tasks.c **** 		/* Write the details of all the TCB's in pxList into the buffer. */
2204:FreeRTOS/Source/tasks.c **** 		listGET_OWNER_OF_NEXT_ENTRY( pxFirstTCB, pxList );
2205:FreeRTOS/Source/tasks.c **** 		do
2206:FreeRTOS/Source/tasks.c **** 		{
2207:FreeRTOS/Source/tasks.c **** 			listGET_OWNER_OF_NEXT_ENTRY( pxNextTCB, pxList );
2208:FreeRTOS/Source/tasks.c **** 			#if ( portSTACK_GROWTH > 0 )
2209:FreeRTOS/Source/tasks.c **** 			{
2210:FreeRTOS/Source/tasks.c **** 				usStackRemaining = usTaskCheckFreeStackSpace( ( unsigned char * ) pxNextTCB->pxEndOfStack );
2211:FreeRTOS/Source/tasks.c **** 			}
2212:FreeRTOS/Source/tasks.c **** 			#else
2213:FreeRTOS/Source/tasks.c **** 			{
2214:FreeRTOS/Source/tasks.c **** 				usStackRemaining = usTaskCheckFreeStackSpace( ( unsigned char * ) pxNextTCB->pxStack );
2215:FreeRTOS/Source/tasks.c **** 			}
2216:FreeRTOS/Source/tasks.c **** 			#endif			
2217:FreeRTOS/Source/tasks.c **** 			
2218:FreeRTOS/Source/tasks.c **** 			sprintf( pcStatusString, ( char * ) "%s\t\t%c\t%u\t%u\t%u\r\n", pxNextTCB->pcTaskName, cStatus, 
2219:FreeRTOS/Source/tasks.c **** 			strcat( ( char * ) pcWriteBuffer, ( char * ) pcStatusString );
2220:FreeRTOS/Source/tasks.c **** 
2221:FreeRTOS/Source/tasks.c **** 		} while( pxNextTCB != pxFirstTCB );
2222:FreeRTOS/Source/tasks.c **** 	}
2223:FreeRTOS/Source/tasks.c **** 
2224:FreeRTOS/Source/tasks.c **** #endif
2225:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
2226:FreeRTOS/Source/tasks.c **** 
2227:FreeRTOS/Source/tasks.c **** #if ( configGENERATE_RUN_TIME_STATS == 1 )
2228:FreeRTOS/Source/tasks.c **** 
2229:FreeRTOS/Source/tasks.c **** 	static void prvGenerateRunTimeStatsForTasksInList( const signed char *pcWriteBuffer, xList *pxList
2230:FreeRTOS/Source/tasks.c **** 	{
 3384              		.loc 1 2230 0
 3385              		.cfi_startproc
 3386              		@ args = 0, pretend = 0, frame = 40
 3387              		@ frame_needed = 1, uses_anonymous_args = 0
 3388 0000 2DE9F041 		push	{r4, r5, r6, r7, r8, lr}
 3389              	.LCFI100:
 3390              		.cfi_def_cfa_offset 24
 3391              		.cfi_offset 14, -4
 3392              		.cfi_offset 8, -8
 3393              		.cfi_offset 7, -12
 3394              		.cfi_offset 6, -16
 3395              		.cfi_offset 5, -20
 3396              		.cfi_offset 4, -24
 3397 0004 8EB0     		sub	sp, sp, #56
 3398              	.LCFI101:
 3399              		.cfi_def_cfa_offset 80
 3400 0006 04AF     		add	r7, sp, #16
 3401              	.LCFI102:
 3402              		.cfi_def_cfa 7, 64
 3403 0008 F860     		str	r0, [r7, #12]
 3404 000a B960     		str	r1, [r7, #8]
 3405 000c 7A60     		str	r2, [r7, #4]
 3406 000e FB70     		strb	r3, [r7, #3]
 3407              	.LBB10:
2231:FreeRTOS/Source/tasks.c **** 	volatile tskTCB *pxNextTCB, *pxFirstTCB;
2232:FreeRTOS/Source/tasks.c **** 	unsigned long ulStatsAsPercentage;
2233:FreeRTOS/Source/tasks.c **** 
2234:FreeRTOS/Source/tasks.c **** 		/* Write the run time stats of all the TCB's in pxList into the buffer. */
2235:FreeRTOS/Source/tasks.c **** 		listGET_OWNER_OF_NEXT_ENTRY( pxFirstTCB, pxList );
 3408              		.loc 1 2235 0
 3409 0010 BB68     		ldr	r3, [r7, #8]
 3410 0012 7B62     		str	r3, [r7, #36]
 3411 0014 7B6A     		ldr	r3, [r7, #36]
 3412 0016 5B68     		ldr	r3, [r3, #4]
 3413 0018 5A68     		ldr	r2, [r3, #4]
 3414 001a 7B6A     		ldr	r3, [r7, #36]
 3415 001c 5A60     		str	r2, [r3, #4]
 3416 001e 7B6A     		ldr	r3, [r7, #36]
 3417 0020 5A68     		ldr	r2, [r3, #4]
 3418 0022 7B6A     		ldr	r3, [r7, #36]
 3419 0024 03F10803 		add	r3, r3, #8
 3420 0028 9A42     		cmp	r2, r3
 3421 002a 04D1     		bne	.L145
 3422              		.loc 1 2235 0 is_stmt 0 discriminator 1
 3423 002c 7B6A     		ldr	r3, [r7, #36]
 3424 002e 5B68     		ldr	r3, [r3, #4]
 3425 0030 5A68     		ldr	r2, [r3, #4]
 3426 0032 7B6A     		ldr	r3, [r7, #36]
 3427 0034 5A60     		str	r2, [r3, #4]
 3428              	.L145:
 3429              		.loc 1 2235 0 discriminator 2
 3430 0036 7B6A     		ldr	r3, [r7, #36]
 3431 0038 5B68     		ldr	r3, [r3, #4]
 3432 003a DB68     		ldr	r3, [r3, #12]
 3433 003c 3B62     		str	r3, [r7, #32]
 3434              	.L151:
 3435              	.LBE10:
 3436              	.LBB11:
2236:FreeRTOS/Source/tasks.c **** 		do
2237:FreeRTOS/Source/tasks.c **** 		{
2238:FreeRTOS/Source/tasks.c **** 			/* Get next TCB in from the list. */
2239:FreeRTOS/Source/tasks.c **** 			listGET_OWNER_OF_NEXT_ENTRY( pxNextTCB, pxList );
 3437              		.loc 1 2239 0 is_stmt 1
 3438 003e BB68     		ldr	r3, [r7, #8]
 3439 0040 FB61     		str	r3, [r7, #28]
 3440 0042 FB69     		ldr	r3, [r7, #28]
 3441 0044 5B68     		ldr	r3, [r3, #4]
 3442 0046 5A68     		ldr	r2, [r3, #4]
 3443 0048 FB69     		ldr	r3, [r7, #28]
 3444 004a 5A60     		str	r2, [r3, #4]
 3445 004c FB69     		ldr	r3, [r7, #28]
 3446 004e 5A68     		ldr	r2, [r3, #4]
 3447 0050 FB69     		ldr	r3, [r7, #28]
 3448 0052 03F10803 		add	r3, r3, #8
 3449 0056 9A42     		cmp	r2, r3
 3450 0058 04D1     		bne	.L146
 3451              		.loc 1 2239 0 is_stmt 0 discriminator 1
 3452 005a FB69     		ldr	r3, [r7, #28]
 3453 005c 5B68     		ldr	r3, [r3, #4]
 3454 005e 5A68     		ldr	r2, [r3, #4]
 3455 0060 FB69     		ldr	r3, [r7, #28]
 3456 0062 5A60     		str	r2, [r3, #4]
 3457              	.L146:
 3458              		.loc 1 2239 0 discriminator 2
 3459 0064 FB69     		ldr	r3, [r7, #28]
 3460 0066 5B68     		ldr	r3, [r3, #4]
 3461 0068 DB68     		ldr	r3, [r3, #12]
 3462 006a BB61     		str	r3, [r7, #24]
 3463              	.LBE11:
2240:FreeRTOS/Source/tasks.c **** 
2241:FreeRTOS/Source/tasks.c **** 			/* Divide by zero check. */
2242:FreeRTOS/Source/tasks.c **** 			if( ulTotalRunTime > 0UL )
 3464              		.loc 1 2242 0 is_stmt 1 discriminator 2
 3465 006c 7B68     		ldr	r3, [r7, #4]
 3466 006e 002B     		cmp	r3, #0
 3467 0070 70D0     		beq	.L147
2243:FreeRTOS/Source/tasks.c **** 			{
2244:FreeRTOS/Source/tasks.c **** 				/* Has the task run at all? */
2245:FreeRTOS/Source/tasks.c **** 				if( pxNextTCB->ulRunTimeCounter == 0UL )
 3468              		.loc 1 2245 0
 3469 0072 BB69     		ldr	r3, [r7, #24]
 3470 0074 DB6C     		ldr	r3, [r3, #76]
 3471 0076 002B     		cmp	r3, #0
 3472 0078 1BD1     		bne	.L148
2246:FreeRTOS/Source/tasks.c **** 				{
2247:FreeRTOS/Source/tasks.c **** 					/* The task has used no CPU time at all. */
2248:FreeRTOS/Source/tasks.c **** 					sprintf( pcStatsString, ( char * ) "%u  %c  %-16s          0   0%%  %5u\r\n", (unsigned int) p
 3473              		.loc 1 2248 0
 3474 007a BB69     		ldr	r3, [r7, #24]
 3475 007c DD6A     		ldr	r5, [r3, #44]
 3476 007e 97F90340 		ldrsb	r4, [r7, #3]
 3477 0082 BB69     		ldr	r3, [r7, #24]
 3478 0084 03F13406 		add	r6, r3, #52
 3479 0088 BB69     		ldr	r3, [r7, #24]
 3480 008a 1B6B     		ldr	r3, [r3, #48]
 3481 008c 1846     		mov	r0, r3
 3482 008e FFF7FEFF 		bl	usTaskCheckFreeStackSpace
 3483 0092 0346     		mov	r3, r0
 3484 0094 0096     		str	r6, [sp, #0]
 3485 0096 0193     		str	r3, [sp, #4]
 3486 0098 40F20000 		movw	r0, #:lower16:pcStatsString
 3487 009c C0F20000 		movt	r0, #:upper16:pcStatsString
 3488 00a0 40F20001 		movw	r1, #:lower16:.LC2
 3489 00a4 C0F20001 		movt	r1, #:upper16:.LC2
 3490 00a8 2A46     		mov	r2, r5
 3491 00aa 2346     		mov	r3, r4
 3492 00ac FFF7FEFF 		bl	sprintf
 3493 00b0 49E0     		b	.L149
 3494              	.L148:
2249:FreeRTOS/Source/tasks.c **** 				}
2250:FreeRTOS/Source/tasks.c **** 				else
2251:FreeRTOS/Source/tasks.c **** 				{
2252:FreeRTOS/Source/tasks.c **** 					/* What percentage of the total run time has the task used?
2253:FreeRTOS/Source/tasks.c **** 					This will always be rounded down to the nearest integer.
2254:FreeRTOS/Source/tasks.c **** 					ulTotalRunTime has already been divided by 100. */
2255:FreeRTOS/Source/tasks.c **** 					ulStatsAsPercentage = pxNextTCB->ulRunTimeCounter / ulTotalRunTime;
 3495              		.loc 1 2255 0
 3496 00b2 BB69     		ldr	r3, [r7, #24]
 3497 00b4 DA6C     		ldr	r2, [r3, #76]
 3498 00b6 7B68     		ldr	r3, [r7, #4]
 3499 00b8 B2FBF3F3 		udiv	r3, r2, r3
 3500 00bc 7B61     		str	r3, [r7, #20]
2256:FreeRTOS/Source/tasks.c **** 
2257:FreeRTOS/Source/tasks.c **** 					if( ulStatsAsPercentage > 0UL )
 3501              		.loc 1 2257 0
 3502 00be 7B69     		ldr	r3, [r7, #20]
 3503 00c0 002B     		cmp	r3, #0
 3504 00c2 21D0     		beq	.L150
2258:FreeRTOS/Source/tasks.c **** 					{
2259:FreeRTOS/Source/tasks.c **** 						#ifdef portLU_PRINTF_SPECIFIER_REQUIRED
2260:FreeRTOS/Source/tasks.c **** 						{
2261:FreeRTOS/Source/tasks.c **** 							sprintf( pcStatsString, ( char * ) "%s\t\t%lu\t\t%lu%%\r\n", pxNextTCB->pcTaskName, pxNextTC
2262:FreeRTOS/Source/tasks.c **** 						}
2263:FreeRTOS/Source/tasks.c **** 						#else
2264:FreeRTOS/Source/tasks.c **** 						{
2265:FreeRTOS/Source/tasks.c **** 							/* sizeof( int ) == sizeof( long ) so a smaller
2266:FreeRTOS/Source/tasks.c **** 							printf() library can be used. */
2267:FreeRTOS/Source/tasks.c **** 							sprintf( pcStatsString, ( char * ) "%u  %c  %-16s %10u %3u%%  %5u\r\n", (unsigned int) pxNex
 3505              		.loc 1 2267 0
 3506 00c4 BB69     		ldr	r3, [r7, #24]
 3507 00c6 DD6A     		ldr	r5, [r3, #44]
 3508 00c8 97F90340 		ldrsb	r4, [r7, #3]
 3509 00cc BB69     		ldr	r3, [r7, #24]
 3510 00ce 03F13408 		add	r8, r3, #52
 3511 00d2 BB69     		ldr	r3, [r7, #24]
 3512 00d4 DE6C     		ldr	r6, [r3, #76]
 3513 00d6 BB69     		ldr	r3, [r7, #24]
 3514 00d8 1B6B     		ldr	r3, [r3, #48]
 3515 00da 1846     		mov	r0, r3
 3516 00dc FFF7FEFF 		bl	usTaskCheckFreeStackSpace
 3517 00e0 0346     		mov	r3, r0
 3518 00e2 CDF80080 		str	r8, [sp, #0]
 3519 00e6 0196     		str	r6, [sp, #4]
 3520 00e8 7A69     		ldr	r2, [r7, #20]
 3521 00ea 0292     		str	r2, [sp, #8]
 3522 00ec 0393     		str	r3, [sp, #12]
 3523 00ee 40F20000 		movw	r0, #:lower16:pcStatsString
 3524 00f2 C0F20000 		movt	r0, #:upper16:pcStatsString
 3525 00f6 40F20001 		movw	r1, #:lower16:.LC3
 3526 00fa C0F20001 		movt	r1, #:upper16:.LC3
 3527 00fe 2A46     		mov	r2, r5
 3528 0100 2346     		mov	r3, r4
 3529 0102 FFF7FEFF 		bl	sprintf
 3530 0106 1EE0     		b	.L149
 3531              	.L150:
2268:FreeRTOS/Source/tasks.c **** 						}
2269:FreeRTOS/Source/tasks.c **** 						#endif
2270:FreeRTOS/Source/tasks.c **** 					}
2271:FreeRTOS/Source/tasks.c **** 					else
2272:FreeRTOS/Source/tasks.c **** 					{
2273:FreeRTOS/Source/tasks.c **** 						/* If the percentage is zero here then the task has
2274:FreeRTOS/Source/tasks.c **** 						consumed less than 1% of the total run time. */
2275:FreeRTOS/Source/tasks.c **** 						#ifdef portLU_PRINTF_SPECIFIER_REQUIRED
2276:FreeRTOS/Source/tasks.c **** 						{
2277:FreeRTOS/Source/tasks.c **** 							sprintf( pcStatsString, ( char * ) "%s\t\t%lu\t\t<1%%\r\n", pxNextTCB->pcTaskName, pxNextTCB
2278:FreeRTOS/Source/tasks.c **** 						}
2279:FreeRTOS/Source/tasks.c **** 						#else
2280:FreeRTOS/Source/tasks.c **** 						{
2281:FreeRTOS/Source/tasks.c **** 							/* sizeof( int ) == sizeof( long ) so a smaller
2282:FreeRTOS/Source/tasks.c **** 							printf() library can be used. */
2283:FreeRTOS/Source/tasks.c **** 							sprintf( pcStatsString, ( char * ) "%u  %c  %-16s %10u  <1%%  %5u\r\n",  (unsigned int) pxNe
 3532              		.loc 1 2283 0
 3533 0108 BB69     		ldr	r3, [r7, #24]
 3534 010a DD6A     		ldr	r5, [r3, #44]
 3535 010c 97F90340 		ldrsb	r4, [r7, #3]
 3536 0110 BB69     		ldr	r3, [r7, #24]
 3537 0112 03F13408 		add	r8, r3, #52
 3538 0116 BB69     		ldr	r3, [r7, #24]
 3539 0118 DE6C     		ldr	r6, [r3, #76]
 3540 011a BB69     		ldr	r3, [r7, #24]
 3541 011c 1B6B     		ldr	r3, [r3, #48]
 3542 011e 1846     		mov	r0, r3
 3543 0120 FFF7FEFF 		bl	usTaskCheckFreeStackSpace
 3544 0124 0346     		mov	r3, r0
 3545 0126 CDF80080 		str	r8, [sp, #0]
 3546 012a 0196     		str	r6, [sp, #4]
 3547 012c 0293     		str	r3, [sp, #8]
 3548 012e 40F20000 		movw	r0, #:lower16:pcStatsString
 3549 0132 C0F20000 		movt	r0, #:upper16:pcStatsString
 3550 0136 40F20001 		movw	r1, #:lower16:.LC4
 3551 013a C0F20001 		movt	r1, #:upper16:.LC4
 3552 013e 2A46     		mov	r2, r5
 3553 0140 2346     		mov	r3, r4
 3554 0142 FFF7FEFF 		bl	sprintf
 3555              	.L149:
2284:FreeRTOS/Source/tasks.c **** 						}
2285:FreeRTOS/Source/tasks.c **** 						#endif
2286:FreeRTOS/Source/tasks.c **** 					}
2287:FreeRTOS/Source/tasks.c **** 				}
2288:FreeRTOS/Source/tasks.c **** 
2289:FreeRTOS/Source/tasks.c **** 				strcat( ( char * ) pcWriteBuffer, ( char * ) pcStatsString );
 3556              		.loc 1 2289 0
 3557 0146 F868     		ldr	r0, [r7, #12]
 3558 0148 40F20001 		movw	r1, #:lower16:pcStatsString
 3559 014c C0F20001 		movt	r1, #:upper16:pcStatsString
 3560 0150 FFF7FEFF 		bl	strcat
 3561              	.L147:
2290:FreeRTOS/Source/tasks.c **** 			}
2291:FreeRTOS/Source/tasks.c **** 
2292:FreeRTOS/Source/tasks.c **** 		} while( pxNextTCB != pxFirstTCB );
 3562              		.loc 1 2292 0
 3563 0154 BA69     		ldr	r2, [r7, #24]
 3564 0156 3B6A     		ldr	r3, [r7, #32]
 3565 0158 9A42     		cmp	r2, r3
 3566 015a 7FF470AF 		bne	.L151
2293:FreeRTOS/Source/tasks.c **** 	}
 3567              		.loc 1 2293 0
 3568 015e 07F12807 		add	r7, r7, #40
 3569 0162 BD46     		mov	sp, r7
 3570 0164 BDE8F081 		pop	{r4, r5, r6, r7, r8, pc}
 3571              		.cfi_endproc
 3572              	.LFE145:
 3574              		.section	.text.usTaskCheckFreeStackSpace,"ax",%progbits
 3575              		.align	2
 3576              		.thumb
 3577              		.thumb_func
 3579              	usTaskCheckFreeStackSpace:
 3580              	.LFB146:
2294:FreeRTOS/Source/tasks.c **** 
2295:FreeRTOS/Source/tasks.c **** #endif
2296:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
2297:FreeRTOS/Source/tasks.c **** 
2298:FreeRTOS/Source/tasks.c **** #if ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) )
2299:FreeRTOS/Source/tasks.c **** 
2300:FreeRTOS/Source/tasks.c **** 	static unsigned short usTaskCheckFreeStackSpace( const unsigned char * pucStackByte )
2301:FreeRTOS/Source/tasks.c **** 	{
 3581              		.loc 1 2301 0
 3582              		.cfi_startproc
 3583              		@ args = 0, pretend = 0, frame = 8
 3584              		@ frame_needed = 1, uses_anonymous_args = 0
 3585              		@ link register save eliminated.
 3586 0000 90B4     		push	{r4, r7}
 3587              	.LCFI103:
 3588              		.cfi_def_cfa_offset 8
 3589              		.cfi_offset 7, -4
 3590              		.cfi_offset 4, -8
 3591 0002 82B0     		sub	sp, sp, #8
 3592              	.LCFI104:
 3593              		.cfi_def_cfa_offset 16
 3594 0004 00AF     		add	r7, sp, #0
 3595              	.LCFI105:
 3596              		.cfi_def_cfa_register 7
 3597 0006 7860     		str	r0, [r7, #4]
2302:FreeRTOS/Source/tasks.c **** 	register unsigned short usCount = 0U;
 3598              		.loc 1 2302 0
 3599 0008 4FF00004 		mov	r4, #0
2303:FreeRTOS/Source/tasks.c **** 
2304:FreeRTOS/Source/tasks.c **** 		while( *pucStackByte == tskSTACK_FILL_BYTE )
 3600              		.loc 1 2304 0
 3601 000c 06E0     		b	.L153
 3602              	.L154:
2305:FreeRTOS/Source/tasks.c **** 		{
2306:FreeRTOS/Source/tasks.c **** 			pucStackByte -= portSTACK_GROWTH;
 3603              		.loc 1 2306 0
 3604 000e 7B68     		ldr	r3, [r7, #4]
 3605 0010 03F10103 		add	r3, r3, #1
 3606 0014 7B60     		str	r3, [r7, #4]
2307:FreeRTOS/Source/tasks.c **** 			usCount++;
 3607              		.loc 1 2307 0
 3608 0016 04F10103 		add	r3, r4, #1
 3609 001a 9CB2     		uxth	r4, r3
 3610              	.L153:
2304:FreeRTOS/Source/tasks.c **** 		while( *pucStackByte == tskSTACK_FILL_BYTE )
 3611              		.loc 1 2304 0 discriminator 1
 3612 001c 7B68     		ldr	r3, [r7, #4]
 3613 001e 1B78     		ldrb	r3, [r3, #0]	@ zero_extendqisi2
 3614 0020 A52B     		cmp	r3, #165
 3615 0022 F4D0     		beq	.L154
2308:FreeRTOS/Source/tasks.c **** 		}
2309:FreeRTOS/Source/tasks.c **** 
2310:FreeRTOS/Source/tasks.c **** 		usCount /= sizeof( portSTACK_TYPE );
 3616              		.loc 1 2310 0
 3617 0024 4FEA9403 		lsr	r3, r4, #2
 3618 0028 9CB2     		uxth	r4, r3
2311:FreeRTOS/Source/tasks.c **** 
2312:FreeRTOS/Source/tasks.c **** 		return usCount;
 3619              		.loc 1 2312 0
 3620 002a 2346     		mov	r3, r4
2313:FreeRTOS/Source/tasks.c **** 	}
 3621              		.loc 1 2313 0
 3622 002c 1846     		mov	r0, r3
 3623 002e 07F10807 		add	r7, r7, #8
 3624 0032 BD46     		mov	sp, r7
 3625 0034 90BC     		pop	{r4, r7}
 3626 0036 7047     		bx	lr
 3627              		.cfi_endproc
 3628              	.LFE146:
 3630              		.section	.text.uxTaskGetStackHighWaterMark,"ax",%progbits
 3631              		.align	2
 3632              		.global	uxTaskGetStackHighWaterMark
 3633              		.thumb
 3634              		.thumb_func
 3636              	uxTaskGetStackHighWaterMark:
 3637              	.LFB147:
2314:FreeRTOS/Source/tasks.c **** 
2315:FreeRTOS/Source/tasks.c **** #endif
2316:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
2317:FreeRTOS/Source/tasks.c **** 
2318:FreeRTOS/Source/tasks.c **** #if ( INCLUDE_uxTaskGetStackHighWaterMark == 1 )
2319:FreeRTOS/Source/tasks.c **** 
2320:FreeRTOS/Source/tasks.c **** 	unsigned portBASE_TYPE uxTaskGetStackHighWaterMark( xTaskHandle xTask )
2321:FreeRTOS/Source/tasks.c **** 	{
 3638              		.loc 1 2321 0
 3639              		.cfi_startproc
 3640              		@ args = 0, pretend = 0, frame = 24
 3641              		@ frame_needed = 1, uses_anonymous_args = 0
 3642 0000 80B5     		push	{r7, lr}
 3643              	.LCFI106:
 3644              		.cfi_def_cfa_offset 8
 3645              		.cfi_offset 14, -4
 3646              		.cfi_offset 7, -8
 3647 0002 86B0     		sub	sp, sp, #24
 3648              	.LCFI107:
 3649              		.cfi_def_cfa_offset 32
 3650 0004 00AF     		add	r7, sp, #0
 3651              	.LCFI108:
 3652              		.cfi_def_cfa_register 7
 3653 0006 7860     		str	r0, [r7, #4]
2322:FreeRTOS/Source/tasks.c **** 	tskTCB *pxTCB;
2323:FreeRTOS/Source/tasks.c **** 	unsigned char *pcEndOfStack;
2324:FreeRTOS/Source/tasks.c **** 	unsigned portBASE_TYPE uxReturn;
2325:FreeRTOS/Source/tasks.c **** 
2326:FreeRTOS/Source/tasks.c **** 		pxTCB = prvGetTCBFromHandle( xTask );
 3654              		.loc 1 2326 0
 3655 0008 7B68     		ldr	r3, [r7, #4]
 3656 000a 002B     		cmp	r3, #0
 3657 000c 05D1     		bne	.L156
 3658              		.loc 1 2326 0 is_stmt 0 discriminator 1
 3659 000e 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 3660 0012 C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 3661 0016 1B68     		ldr	r3, [r3, #0]
 3662 0018 00E0     		b	.L157
 3663              	.L156:
 3664              		.loc 1 2326 0 discriminator 2
 3665 001a 7B68     		ldr	r3, [r7, #4]
 3666              	.L157:
 3667              		.loc 1 2326 0 discriminator 3
 3668 001c 7B61     		str	r3, [r7, #20]
2327:FreeRTOS/Source/tasks.c **** 
2328:FreeRTOS/Source/tasks.c **** 		#if portSTACK_GROWTH < 0
2329:FreeRTOS/Source/tasks.c **** 		{
2330:FreeRTOS/Source/tasks.c **** 			pcEndOfStack = ( unsigned char * ) pxTCB->pxStack;
 3669              		.loc 1 2330 0 is_stmt 1 discriminator 3
 3670 001e 7B69     		ldr	r3, [r7, #20]
 3671 0020 1B6B     		ldr	r3, [r3, #48]
 3672 0022 3B61     		str	r3, [r7, #16]
2331:FreeRTOS/Source/tasks.c **** 		}
2332:FreeRTOS/Source/tasks.c **** 		#else
2333:FreeRTOS/Source/tasks.c **** 		{
2334:FreeRTOS/Source/tasks.c **** 			pcEndOfStack = ( unsigned char * ) pxTCB->pxEndOfStack;
2335:FreeRTOS/Source/tasks.c **** 		}
2336:FreeRTOS/Source/tasks.c **** 		#endif
2337:FreeRTOS/Source/tasks.c **** 
2338:FreeRTOS/Source/tasks.c **** 		uxReturn = ( unsigned portBASE_TYPE ) usTaskCheckFreeStackSpace( pcEndOfStack );
 3673              		.loc 1 2338 0 discriminator 3
 3674 0024 3869     		ldr	r0, [r7, #16]
 3675 0026 FFF7FEFF 		bl	usTaskCheckFreeStackSpace
 3676 002a 0346     		mov	r3, r0
 3677 002c FB60     		str	r3, [r7, #12]
2339:FreeRTOS/Source/tasks.c **** 
2340:FreeRTOS/Source/tasks.c **** 		return uxReturn;
 3678              		.loc 1 2340 0 discriminator 3
 3679 002e FB68     		ldr	r3, [r7, #12]
2341:FreeRTOS/Source/tasks.c **** 	}
 3680              		.loc 1 2341 0 discriminator 3
 3681 0030 1846     		mov	r0, r3
 3682 0032 07F11807 		add	r7, r7, #24
 3683 0036 BD46     		mov	sp, r7
 3684 0038 80BD     		pop	{r7, pc}
 3685              		.cfi_endproc
 3686              	.LFE147:
 3688 003a 00BF     		.section	.text.prvDeleteTCB,"ax",%progbits
 3689              		.align	2
 3690              		.thumb
 3691              		.thumb_func
 3693              	prvDeleteTCB:
 3694              	.LFB148:
2342:FreeRTOS/Source/tasks.c **** 
2343:FreeRTOS/Source/tasks.c **** #endif
2344:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
2345:FreeRTOS/Source/tasks.c **** 
2346:FreeRTOS/Source/tasks.c **** #if ( INCLUDE_vTaskDelete == 1 )
2347:FreeRTOS/Source/tasks.c **** 
2348:FreeRTOS/Source/tasks.c **** 	static void prvDeleteTCB( tskTCB *pxTCB )
2349:FreeRTOS/Source/tasks.c **** 	{
 3695              		.loc 1 2349 0
 3696              		.cfi_startproc
 3697              		@ args = 0, pretend = 0, frame = 8
 3698              		@ frame_needed = 1, uses_anonymous_args = 0
 3699 0000 80B5     		push	{r7, lr}
 3700              	.LCFI109:
 3701              		.cfi_def_cfa_offset 8
 3702              		.cfi_offset 14, -4
 3703              		.cfi_offset 7, -8
 3704 0002 82B0     		sub	sp, sp, #8
 3705              	.LCFI110:
 3706              		.cfi_def_cfa_offset 16
 3707 0004 00AF     		add	r7, sp, #0
 3708              	.LCFI111:
 3709              		.cfi_def_cfa_register 7
 3710 0006 7860     		str	r0, [r7, #4]
2350:FreeRTOS/Source/tasks.c **** 		/* Free up the memory allocated by the scheduler for the task.  It is up to
2351:FreeRTOS/Source/tasks.c **** 		the task to free any memory allocated at the application level. */
2352:FreeRTOS/Source/tasks.c **** 		vPortFreeAligned( pxTCB->pxStack );
 3711              		.loc 1 2352 0
 3712 0008 7B68     		ldr	r3, [r7, #4]
 3713 000a 1B6B     		ldr	r3, [r3, #48]
 3714 000c 1846     		mov	r0, r3
 3715 000e FFF7FEFF 		bl	free
2353:FreeRTOS/Source/tasks.c **** 		vPortFree( pxTCB );
 3716              		.loc 1 2353 0
 3717 0012 7868     		ldr	r0, [r7, #4]
 3718 0014 FFF7FEFF 		bl	free
2354:FreeRTOS/Source/tasks.c **** 	}
 3719              		.loc 1 2354 0
 3720 0018 07F10807 		add	r7, r7, #8
 3721 001c BD46     		mov	sp, r7
 3722 001e 80BD     		pop	{r7, pc}
 3723              		.cfi_endproc
 3724              	.LFE148:
 3726              		.section	.text.xTaskGetCurrentTaskHandle,"ax",%progbits
 3727              		.align	2
 3728              		.global	xTaskGetCurrentTaskHandle
 3729              		.thumb
 3730              		.thumb_func
 3732              	xTaskGetCurrentTaskHandle:
 3733              	.LFB149:
2355:FreeRTOS/Source/tasks.c **** 
2356:FreeRTOS/Source/tasks.c **** #endif
2357:FreeRTOS/Source/tasks.c **** 
2358:FreeRTOS/Source/tasks.c **** 
2359:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
2360:FreeRTOS/Source/tasks.c **** 
2361:FreeRTOS/Source/tasks.c **** #if ( ( INCLUDE_xTaskGetCurrentTaskHandle == 1 ) || ( configUSE_MUTEXES == 1 ) )
2362:FreeRTOS/Source/tasks.c **** 
2363:FreeRTOS/Source/tasks.c **** 	xTaskHandle xTaskGetCurrentTaskHandle( void )
2364:FreeRTOS/Source/tasks.c **** 	{
 3734              		.loc 1 2364 0
 3735              		.cfi_startproc
 3736              		@ args = 0, pretend = 0, frame = 8
 3737              		@ frame_needed = 1, uses_anonymous_args = 0
 3738              		@ link register save eliminated.
 3739 0000 80B4     		push	{r7}
 3740              	.LCFI112:
 3741              		.cfi_def_cfa_offset 4
 3742              		.cfi_offset 7, -4
 3743 0002 83B0     		sub	sp, sp, #12
 3744              	.LCFI113:
 3745              		.cfi_def_cfa_offset 16
 3746 0004 00AF     		add	r7, sp, #0
 3747              	.LCFI114:
 3748              		.cfi_def_cfa_register 7
2365:FreeRTOS/Source/tasks.c **** 	xTaskHandle xReturn;
2366:FreeRTOS/Source/tasks.c **** 
2367:FreeRTOS/Source/tasks.c **** 		/* A critical section is not required as this is not called from
2368:FreeRTOS/Source/tasks.c **** 		an interrupt and the current TCB will always be the same for any
2369:FreeRTOS/Source/tasks.c **** 		individual execution thread. */
2370:FreeRTOS/Source/tasks.c **** 		xReturn = pxCurrentTCB;
 3749              		.loc 1 2370 0
 3750 0006 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 3751 000a C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 3752 000e 1B68     		ldr	r3, [r3, #0]
 3753 0010 7B60     		str	r3, [r7, #4]
2371:FreeRTOS/Source/tasks.c **** 
2372:FreeRTOS/Source/tasks.c **** 		return xReturn;
 3754              		.loc 1 2372 0
 3755 0012 7B68     		ldr	r3, [r7, #4]
2373:FreeRTOS/Source/tasks.c **** 	}
 3756              		.loc 1 2373 0
 3757 0014 1846     		mov	r0, r3
 3758 0016 07F10C07 		add	r7, r7, #12
 3759 001a BD46     		mov	sp, r7
 3760 001c 80BC     		pop	{r7}
 3761 001e 7047     		bx	lr
 3762              		.cfi_endproc
 3763              	.LFE149:
 3765              		.section	.text.vTaskPriorityInherit,"ax",%progbits
 3766              		.align	2
 3767              		.global	vTaskPriorityInherit
 3768              		.thumb
 3769              		.thumb_func
 3771              	vTaskPriorityInherit:
 3772              	.LFB150:
2374:FreeRTOS/Source/tasks.c **** 
2375:FreeRTOS/Source/tasks.c **** #endif
2376:FreeRTOS/Source/tasks.c **** 
2377:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
2378:FreeRTOS/Source/tasks.c **** 
2379:FreeRTOS/Source/tasks.c **** #if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
2380:FreeRTOS/Source/tasks.c **** 
2381:FreeRTOS/Source/tasks.c **** 	portBASE_TYPE xTaskGetSchedulerState( void )
2382:FreeRTOS/Source/tasks.c **** 	{
2383:FreeRTOS/Source/tasks.c **** 	portBASE_TYPE xReturn;
2384:FreeRTOS/Source/tasks.c **** 
2385:FreeRTOS/Source/tasks.c **** 		if( xSchedulerRunning == pdFALSE )
2386:FreeRTOS/Source/tasks.c **** 		{
2387:FreeRTOS/Source/tasks.c **** 			xReturn = taskSCHEDULER_NOT_STARTED;
2388:FreeRTOS/Source/tasks.c **** 		}
2389:FreeRTOS/Source/tasks.c **** 		else
2390:FreeRTOS/Source/tasks.c **** 		{
2391:FreeRTOS/Source/tasks.c **** 			if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
2392:FreeRTOS/Source/tasks.c **** 			{
2393:FreeRTOS/Source/tasks.c **** 				xReturn = taskSCHEDULER_RUNNING;
2394:FreeRTOS/Source/tasks.c **** 			}
2395:FreeRTOS/Source/tasks.c **** 			else
2396:FreeRTOS/Source/tasks.c **** 			{
2397:FreeRTOS/Source/tasks.c **** 				xReturn = taskSCHEDULER_SUSPENDED;
2398:FreeRTOS/Source/tasks.c **** 			}
2399:FreeRTOS/Source/tasks.c **** 		}
2400:FreeRTOS/Source/tasks.c **** 
2401:FreeRTOS/Source/tasks.c **** 		return xReturn;
2402:FreeRTOS/Source/tasks.c **** 	}
2403:FreeRTOS/Source/tasks.c **** 
2404:FreeRTOS/Source/tasks.c **** #endif
2405:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
2406:FreeRTOS/Source/tasks.c **** 
2407:FreeRTOS/Source/tasks.c **** #if ( configUSE_MUTEXES == 1 )
2408:FreeRTOS/Source/tasks.c **** 
2409:FreeRTOS/Source/tasks.c **** 	void vTaskPriorityInherit( xTaskHandle * const pxMutexHolder )
2410:FreeRTOS/Source/tasks.c **** 	{
 3773              		.loc 1 2410 0
 3774              		.cfi_startproc
 3775              		@ args = 0, pretend = 0, frame = 16
 3776              		@ frame_needed = 1, uses_anonymous_args = 0
 3777 0000 80B5     		push	{r7, lr}
 3778              	.LCFI115:
 3779              		.cfi_def_cfa_offset 8
 3780              		.cfi_offset 14, -4
 3781              		.cfi_offset 7, -8
 3782 0002 84B0     		sub	sp, sp, #16
 3783              	.LCFI116:
 3784              		.cfi_def_cfa_offset 24
 3785 0004 00AF     		add	r7, sp, #0
 3786              	.LCFI117:
 3787              		.cfi_def_cfa_register 7
 3788 0006 7860     		str	r0, [r7, #4]
2411:FreeRTOS/Source/tasks.c **** 	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;
 3789              		.loc 1 2411 0
 3790 0008 7B68     		ldr	r3, [r7, #4]
 3791 000a FB60     		str	r3, [r7, #12]
2412:FreeRTOS/Source/tasks.c **** 
2413:FreeRTOS/Source/tasks.c **** 		configASSERT( pxMutexHolder );
2414:FreeRTOS/Source/tasks.c **** 
2415:FreeRTOS/Source/tasks.c **** 		if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
 3792              		.loc 1 2415 0
 3793 000c FB68     		ldr	r3, [r7, #12]
 3794 000e DA6A     		ldr	r2, [r3, #44]
 3795 0010 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 3796 0014 C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 3797 0018 1B68     		ldr	r3, [r3, #0]
 3798 001a DB6A     		ldr	r3, [r3, #44]
 3799 001c 9A42     		cmp	r2, r3
 3800 001e 57D2     		bcs	.L160
2416:FreeRTOS/Source/tasks.c **** 		{
2417:FreeRTOS/Source/tasks.c **** 			/* Adjust the mutex holder state to account for its new priority. */
2418:FreeRTOS/Source/tasks.c **** 			listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxC
 3801              		.loc 1 2418 0
 3802 0020 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 3803 0024 C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 3804 0028 1B68     		ldr	r3, [r3, #0]
 3805 002a DB6A     		ldr	r3, [r3, #44]
 3806 002c C3F10502 		rsb	r2, r3, #5
 3807 0030 FB68     		ldr	r3, [r7, #12]
 3808 0032 9A61     		str	r2, [r3, #24]
2419:FreeRTOS/Source/tasks.c **** 
2420:FreeRTOS/Source/tasks.c **** 			/* If the task being modified is in the ready state it will need to
2421:FreeRTOS/Source/tasks.c **** 			be moved in to a new list. */
2422:FreeRTOS/Source/tasks.c **** 			if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericList
 3809              		.loc 1 2422 0
 3810 0034 FB68     		ldr	r3, [r7, #12]
 3811 0036 5969     		ldr	r1, [r3, #20]
 3812 0038 FB68     		ldr	r3, [r7, #12]
 3813 003a DA6A     		ldr	r2, [r3, #44]
 3814 003c 1346     		mov	r3, r2
 3815 003e 4FEA8303 		lsl	r3, r3, #2
 3816 0042 9B18     		adds	r3, r3, r2
 3817 0044 4FEA8303 		lsl	r3, r3, #2
 3818 0048 1A46     		mov	r2, r3
 3819 004a 40F20003 		movw	r3, #:lower16:pxReadyTasksLists
 3820 004e C0F20003 		movt	r3, #:upper16:pxReadyTasksLists
 3821 0052 D318     		adds	r3, r2, r3
 3822 0054 9942     		cmp	r1, r3
 3823 0056 33D1     		bne	.L162
2423:FreeRTOS/Source/tasks.c **** 			{
2424:FreeRTOS/Source/tasks.c **** 				vListRemove( &( pxTCB->xGenericListItem ) );
 3824              		.loc 1 2424 0
 3825 0058 FB68     		ldr	r3, [r7, #12]
 3826 005a 03F10403 		add	r3, r3, #4
 3827 005e 1846     		mov	r0, r3
 3828 0060 FFF7FEFF 		bl	vListRemove
2425:FreeRTOS/Source/tasks.c **** 
2426:FreeRTOS/Source/tasks.c **** 				/* Inherit the priority before being moved into the new list. */
2427:FreeRTOS/Source/tasks.c **** 				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
 3829              		.loc 1 2427 0
 3830 0064 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 3831 0068 C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 3832 006c 1B68     		ldr	r3, [r3, #0]
 3833 006e DA6A     		ldr	r2, [r3, #44]
 3834 0070 FB68     		ldr	r3, [r7, #12]
 3835 0072 DA62     		str	r2, [r3, #44]
2428:FreeRTOS/Source/tasks.c **** 				prvAddTaskToReadyQueue( pxTCB );
 3836              		.loc 1 2428 0
 3837 0074 FB68     		ldr	r3, [r7, #12]
 3838 0076 DA6A     		ldr	r2, [r3, #44]
 3839 0078 40F20003 		movw	r3, #:lower16:uxTopReadyPriority
 3840 007c C0F20003 		movt	r3, #:upper16:uxTopReadyPriority
 3841 0080 1B68     		ldr	r3, [r3, #0]
 3842 0082 9A42     		cmp	r2, r3
 3843 0084 06D9     		bls	.L163
 3844              		.loc 1 2428 0 is_stmt 0 discriminator 1
 3845 0086 FB68     		ldr	r3, [r7, #12]
 3846 0088 DA6A     		ldr	r2, [r3, #44]
 3847 008a 40F20003 		movw	r3, #:lower16:uxTopReadyPriority
 3848 008e C0F20003 		movt	r3, #:upper16:uxTopReadyPriority
 3849 0092 1A60     		str	r2, [r3, #0]
 3850              	.L163:
 3851              		.loc 1 2428 0 discriminator 2
 3852 0094 FB68     		ldr	r3, [r7, #12]
 3853 0096 DA6A     		ldr	r2, [r3, #44]
 3854 0098 1346     		mov	r3, r2
 3855 009a 4FEA8303 		lsl	r3, r3, #2
 3856 009e 9B18     		adds	r3, r3, r2
 3857 00a0 4FEA8303 		lsl	r3, r3, #2
 3858 00a4 1A46     		mov	r2, r3
 3859 00a6 40F20003 		movw	r3, #:lower16:pxReadyTasksLists
 3860 00aa C0F20003 		movt	r3, #:upper16:pxReadyTasksLists
 3861 00ae D218     		adds	r2, r2, r3
 3862 00b0 FB68     		ldr	r3, [r7, #12]
 3863 00b2 03F10403 		add	r3, r3, #4
 3864 00b6 1046     		mov	r0, r2
 3865 00b8 1946     		mov	r1, r3
 3866 00ba FFF7FEFF 		bl	vListInsertEnd
 3867 00be 07E0     		b	.L160
 3868              	.L162:
2429:FreeRTOS/Source/tasks.c **** 			}
2430:FreeRTOS/Source/tasks.c **** 			else
2431:FreeRTOS/Source/tasks.c **** 			{
2432:FreeRTOS/Source/tasks.c **** 				/* Just inherit the priority. */
2433:FreeRTOS/Source/tasks.c **** 				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
 3869              		.loc 1 2433 0 is_stmt 1
 3870 00c0 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 3871 00c4 C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 3872 00c8 1B68     		ldr	r3, [r3, #0]
 3873 00ca DA6A     		ldr	r2, [r3, #44]
 3874 00cc FB68     		ldr	r3, [r7, #12]
 3875 00ce DA62     		str	r2, [r3, #44]
 3876              	.L160:
2434:FreeRTOS/Source/tasks.c **** 			}
2435:FreeRTOS/Source/tasks.c **** 		}
2436:FreeRTOS/Source/tasks.c **** 	}
 3877              		.loc 1 2436 0
 3878 00d0 07F11007 		add	r7, r7, #16
 3879 00d4 BD46     		mov	sp, r7
 3880 00d6 80BD     		pop	{r7, pc}
 3881              		.cfi_endproc
 3882              	.LFE150:
 3884              		.section	.text.vTaskPriorityDisinherit,"ax",%progbits
 3885              		.align	2
 3886              		.global	vTaskPriorityDisinherit
 3887              		.thumb
 3888              		.thumb_func
 3890              	vTaskPriorityDisinherit:
 3891              	.LFB151:
2437:FreeRTOS/Source/tasks.c **** 
2438:FreeRTOS/Source/tasks.c **** #endif
2439:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
2440:FreeRTOS/Source/tasks.c **** 
2441:FreeRTOS/Source/tasks.c **** #if ( configUSE_MUTEXES == 1 )
2442:FreeRTOS/Source/tasks.c **** 
2443:FreeRTOS/Source/tasks.c **** 	void vTaskPriorityDisinherit( xTaskHandle * const pxMutexHolder )
2444:FreeRTOS/Source/tasks.c **** 	{
 3892              		.loc 1 2444 0
 3893              		.cfi_startproc
 3894              		@ args = 0, pretend = 0, frame = 16
 3895              		@ frame_needed = 1, uses_anonymous_args = 0
 3896 0000 80B5     		push	{r7, lr}
 3897              	.LCFI118:
 3898              		.cfi_def_cfa_offset 8
 3899              		.cfi_offset 14, -4
 3900              		.cfi_offset 7, -8
 3901 0002 84B0     		sub	sp, sp, #16
 3902              	.LCFI119:
 3903              		.cfi_def_cfa_offset 24
 3904 0004 00AF     		add	r7, sp, #0
 3905              	.LCFI120:
 3906              		.cfi_def_cfa_register 7
 3907 0006 7860     		str	r0, [r7, #4]
2445:FreeRTOS/Source/tasks.c **** 	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;
 3908              		.loc 1 2445 0
 3909 0008 7B68     		ldr	r3, [r7, #4]
 3910 000a FB60     		str	r3, [r7, #12]
2446:FreeRTOS/Source/tasks.c **** 
2447:FreeRTOS/Source/tasks.c **** 		if( pxMutexHolder != NULL )
 3911              		.loc 1 2447 0
 3912 000c 7B68     		ldr	r3, [r7, #4]
 3913 000e 002B     		cmp	r3, #0
 3914 0010 3AD0     		beq	.L164
2448:FreeRTOS/Source/tasks.c **** 		{
2449:FreeRTOS/Source/tasks.c **** 			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
 3915              		.loc 1 2449 0
 3916 0012 FB68     		ldr	r3, [r7, #12]
 3917 0014 DA6A     		ldr	r2, [r3, #44]
 3918 0016 FB68     		ldr	r3, [r7, #12]
 3919 0018 5B6C     		ldr	r3, [r3, #68]
 3920 001a 9A42     		cmp	r2, r3
 3921 001c 34D0     		beq	.L164
2450:FreeRTOS/Source/tasks.c **** 			{
2451:FreeRTOS/Source/tasks.c **** 				/* We must be the running task to be able to give the mutex back.
2452:FreeRTOS/Source/tasks.c **** 				Remove ourselves from the ready list we currently appear in. */
2453:FreeRTOS/Source/tasks.c **** 				vListRemove( &( pxTCB->xGenericListItem ) );
 3922              		.loc 1 2453 0
 3923 001e FB68     		ldr	r3, [r7, #12]
 3924 0020 03F10403 		add	r3, r3, #4
 3925 0024 1846     		mov	r0, r3
 3926 0026 FFF7FEFF 		bl	vListRemove
2454:FreeRTOS/Source/tasks.c **** 
2455:FreeRTOS/Source/tasks.c **** 				/* Disinherit the priority before adding ourselves into the new
2456:FreeRTOS/Source/tasks.c **** 				ready list. */
2457:FreeRTOS/Source/tasks.c **** 				pxTCB->uxPriority = pxTCB->uxBasePriority;
 3927              		.loc 1 2457 0
 3928 002a FB68     		ldr	r3, [r7, #12]
 3929 002c 5A6C     		ldr	r2, [r3, #68]
 3930 002e FB68     		ldr	r3, [r7, #12]
 3931 0030 DA62     		str	r2, [r3, #44]
2458:FreeRTOS/Source/tasks.c **** 				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) px
 3932              		.loc 1 2458 0
 3933 0032 FB68     		ldr	r3, [r7, #12]
 3934 0034 DB6A     		ldr	r3, [r3, #44]
 3935 0036 C3F10502 		rsb	r2, r3, #5
 3936 003a FB68     		ldr	r3, [r7, #12]
 3937 003c 9A61     		str	r2, [r3, #24]
2459:FreeRTOS/Source/tasks.c **** 				prvAddTaskToReadyQueue( pxTCB );
 3938              		.loc 1 2459 0
 3939 003e FB68     		ldr	r3, [r7, #12]
 3940 0040 DA6A     		ldr	r2, [r3, #44]
 3941 0042 40F20003 		movw	r3, #:lower16:uxTopReadyPriority
 3942 0046 C0F20003 		movt	r3, #:upper16:uxTopReadyPriority
 3943 004a 1B68     		ldr	r3, [r3, #0]
 3944 004c 9A42     		cmp	r2, r3
 3945 004e 06D9     		bls	.L166
 3946              		.loc 1 2459 0 is_stmt 0 discriminator 1
 3947 0050 FB68     		ldr	r3, [r7, #12]
 3948 0052 DA6A     		ldr	r2, [r3, #44]
 3949 0054 40F20003 		movw	r3, #:lower16:uxTopReadyPriority
 3950 0058 C0F20003 		movt	r3, #:upper16:uxTopReadyPriority
 3951 005c 1A60     		str	r2, [r3, #0]
 3952              	.L166:
 3953              		.loc 1 2459 0 discriminator 2
 3954 005e FB68     		ldr	r3, [r7, #12]
 3955 0060 DA6A     		ldr	r2, [r3, #44]
 3956 0062 1346     		mov	r3, r2
 3957 0064 4FEA8303 		lsl	r3, r3, #2
 3958 0068 9B18     		adds	r3, r3, r2
 3959 006a 4FEA8303 		lsl	r3, r3, #2
 3960 006e 1A46     		mov	r2, r3
 3961 0070 40F20003 		movw	r3, #:lower16:pxReadyTasksLists
 3962 0074 C0F20003 		movt	r3, #:upper16:pxReadyTasksLists
 3963 0078 D218     		adds	r2, r2, r3
 3964 007a FB68     		ldr	r3, [r7, #12]
 3965 007c 03F10403 		add	r3, r3, #4
 3966 0080 1046     		mov	r0, r2
 3967 0082 1946     		mov	r1, r3
 3968 0084 FFF7FEFF 		bl	vListInsertEnd
 3969              	.L164:
2460:FreeRTOS/Source/tasks.c **** 			}
2461:FreeRTOS/Source/tasks.c **** 		}
2462:FreeRTOS/Source/tasks.c **** 	}
 3970              		.loc 1 2462 0 is_stmt 1
 3971 0088 07F11007 		add	r7, r7, #16
 3972 008c BD46     		mov	sp, r7
 3973 008e 80BD     		pop	{r7, pc}
 3974              		.cfi_endproc
 3975              	.LFE151:
 3977              		.text
 3978              	.Letext0:
 3979              		.file 2 "/usr/local/csl/arm-2012.03/bin/../lib/gcc/arm-none-eabi/4.6.3/include/stddef.h"
 3980              		.file 3 "FreeRTOS/Source/include/projdefs.h"
 3981              		.file 4 "/usr/local/csl/arm-2012.03/bin/../lib/gcc/arm-none-eabi/4.6.3/../../../../arm-none-eabi/i
 3982              		.file 5 "libs/Device/STM32F4xx/Include/stm32f4xx.h"
 3983              		.file 6 "FreeRTOS/Source/include/../../Source/portable/GCC/ARM_CM4F/portmacro.h"
 3984              		.file 7 "FreeRTOS/Source/include/FreeRTOS.h"
 3985              		.file 8 "FreeRTOS/Source/include/list.h"
 3986              		.file 9 "FreeRTOS/Source/include/task.h"
 3987              		.file 10 "libs/CMSIS/Include/core_cm4.h"
DEFINED SYMBOLS
                            *ABS*:00000000 tasks.c
     /tmp/ccgE8nkV.s:24     .bss.pxCurrentTCB:00000000 pxCurrentTCB
     /tmp/ccgE8nkV.s:21     .bss.pxCurrentTCB:00000000 $d
     /tmp/ccgE8nkV.s:27     .bss.pxReadyTasksLists:00000000 $d
     /tmp/ccgE8nkV.s:30     .bss.pxReadyTasksLists:00000000 pxReadyTasksLists
     /tmp/ccgE8nkV.s:33     .bss.xDelayedTaskList1:00000000 $d
     /tmp/ccgE8nkV.s:36     .bss.xDelayedTaskList1:00000000 xDelayedTaskList1
     /tmp/ccgE8nkV.s:39     .bss.xDelayedTaskList2:00000000 $d
     /tmp/ccgE8nkV.s:42     .bss.xDelayedTaskList2:00000000 xDelayedTaskList2
     /tmp/ccgE8nkV.s:45     .bss.pxDelayedTaskList:00000000 $d
     /tmp/ccgE8nkV.s:48     .bss.pxDelayedTaskList:00000000 pxDelayedTaskList
     /tmp/ccgE8nkV.s:51     .bss.pxOverflowDelayedTaskList:00000000 $d
     /tmp/ccgE8nkV.s:54     .bss.pxOverflowDelayedTaskList:00000000 pxOverflowDelayedTaskList
     /tmp/ccgE8nkV.s:57     .bss.xPendingReadyList:00000000 $d
     /tmp/ccgE8nkV.s:60     .bss.xPendingReadyList:00000000 xPendingReadyList
     /tmp/ccgE8nkV.s:63     .bss.xTasksWaitingTermination:00000000 $d
     /tmp/ccgE8nkV.s:66     .bss.xTasksWaitingTermination:00000000 xTasksWaitingTermination
     /tmp/ccgE8nkV.s:69     .bss.uxTasksDeleted:00000000 $d
     /tmp/ccgE8nkV.s:72     .bss.uxTasksDeleted:00000000 uxTasksDeleted
     /tmp/ccgE8nkV.s:75     .bss.xSuspendedTaskList:00000000 $d
     /tmp/ccgE8nkV.s:78     .bss.xSuspendedTaskList:00000000 xSuspendedTaskList
     /tmp/ccgE8nkV.s:81     .bss.xIdleTaskHandle:00000000 $d
     /tmp/ccgE8nkV.s:84     .bss.xIdleTaskHandle:00000000 xIdleTaskHandle
     /tmp/ccgE8nkV.s:87     .bss.uxCurrentNumberOfTasks:00000000 $d
     /tmp/ccgE8nkV.s:90     .bss.uxCurrentNumberOfTasks:00000000 uxCurrentNumberOfTasks
     /tmp/ccgE8nkV.s:93     .bss.xTickCount:00000000 $d
     /tmp/ccgE8nkV.s:96     .bss.xTickCount:00000000 xTickCount
     /tmp/ccgE8nkV.s:99     .bss.uxTopUsedPriority:00000000 $d
     /tmp/ccgE8nkV.s:102    .bss.uxTopUsedPriority:00000000 uxTopUsedPriority
     /tmp/ccgE8nkV.s:105    .bss.uxTopReadyPriority:00000000 $d
     /tmp/ccgE8nkV.s:108    .bss.uxTopReadyPriority:00000000 uxTopReadyPriority
     /tmp/ccgE8nkV.s:111    .bss.xSchedulerRunning:00000000 $d
     /tmp/ccgE8nkV.s:114    .bss.xSchedulerRunning:00000000 xSchedulerRunning
     /tmp/ccgE8nkV.s:117    .bss.uxSchedulerSuspended:00000000 $d
     /tmp/ccgE8nkV.s:120    .bss.uxSchedulerSuspended:00000000 uxSchedulerSuspended
     /tmp/ccgE8nkV.s:123    .bss.uxMissedTicks:00000000 $d
     /tmp/ccgE8nkV.s:126    .bss.uxMissedTicks:00000000 uxMissedTicks
     /tmp/ccgE8nkV.s:129    .bss.xMissedYield:00000000 $d
     /tmp/ccgE8nkV.s:132    .bss.xMissedYield:00000000 xMissedYield
     /tmp/ccgE8nkV.s:135    .bss.xNumOfOverflows:00000000 $d
     /tmp/ccgE8nkV.s:138    .bss.xNumOfOverflows:00000000 xNumOfOverflows
     /tmp/ccgE8nkV.s:141    .bss.uxTaskNumber:00000000 $d
     /tmp/ccgE8nkV.s:144    .bss.uxTaskNumber:00000000 uxTaskNumber
     /tmp/ccgE8nkV.s:147    .data.xNextTaskUnblockTime:00000000 $d
     /tmp/ccgE8nkV.s:150    .data.xNextTaskUnblockTime:00000000 xNextTaskUnblockTime
     /tmp/ccgE8nkV.s:153    .bss.pcStatsString:00000000 $d
     /tmp/ccgE8nkV.s:156    .bss.pcStatsString:00000000 pcStatsString
     /tmp/ccgE8nkV.s:159    .bss.ulTaskSwitchedInTime:00000000 $d
     /tmp/ccgE8nkV.s:162    .bss.ulTaskSwitchedInTime:00000000 ulTaskSwitchedInTime
     /tmp/ccgE8nkV.s:165    .text.xTaskGenericCreate:00000000 $t
     /tmp/ccgE8nkV.s:170    .text.xTaskGenericCreate:00000000 xTaskGenericCreate
     /tmp/ccgE8nkV.s:3287   .text.prvAllocateTCBAndStack:00000000 prvAllocateTCBAndStack
     /tmp/ccgE8nkV.s:2938   .text.prvInitialiseTCBVariables:00000000 prvInitialiseTCBVariables
     /tmp/ccgE8nkV.s:3029   .text.prvInitialiseTaskLists:00000000 prvInitialiseTaskLists
     /tmp/ccgE8nkV.s:390    .text.vTaskDelete:00000000 $t
     /tmp/ccgE8nkV.s:395    .text.vTaskDelete:00000000 vTaskDelete
     /tmp/ccgE8nkV.s:503    .text.vTaskDelayUntil:00000000 $t
     /tmp/ccgE8nkV.s:508    .text.vTaskDelayUntil:00000000 vTaskDelayUntil
     /tmp/ccgE8nkV.s:1444   .text.vTaskSuspendAll:00000000 vTaskSuspendAll
     /tmp/ccgE8nkV.s:3207   .text.prvAddCurrentTaskToDelayedList:00000000 prvAddCurrentTaskToDelayedList
     /tmp/ccgE8nkV.s:1479   .text.xTaskResumeAll:00000000 xTaskResumeAll
     /tmp/ccgE8nkV.s:619    .text.vTaskDelay:00000000 $t
     /tmp/ccgE8nkV.s:624    .text.vTaskDelay:00000000 vTaskDelay
     /tmp/ccgE8nkV.s:687    .text.uxTaskPriorityGet:00000000 $t
     /tmp/ccgE8nkV.s:692    .text.uxTaskPriorityGet:00000000 uxTaskPriorityGet
     /tmp/ccgE8nkV.s:744    .text.vTaskPrioritySet:00000000 $t
     /tmp/ccgE8nkV.s:749    .text.vTaskPrioritySet:00000000 vTaskPrioritySet
     /tmp/ccgE8nkV.s:927    .text.vTaskSuspend:00000000 $t
     /tmp/ccgE8nkV.s:932    .text.vTaskSuspend:00000000 vTaskSuspend
     /tmp/ccgE8nkV.s:2384   .text.vTaskSwitchContext:00000000 vTaskSwitchContext
     /tmp/ccgE8nkV.s:1044   .text.xTaskIsTaskSuspended:00000000 $t
     /tmp/ccgE8nkV.s:1049   .text.xTaskIsTaskSuspended:00000000 xTaskIsTaskSuspended
     /tmp/ccgE8nkV.s:1108   .text.vTaskResume:00000000 $t
     /tmp/ccgE8nkV.s:1113   .text.vTaskResume:00000000 vTaskResume
     /tmp/ccgE8nkV.s:1212   .text.xTaskResumeFromISR:00000000 $t
     /tmp/ccgE8nkV.s:1217   .text.xTaskResumeFromISR:00000000 xTaskResumeFromISR
     /tmp/ccgE8nkV.s:1322   .rodata:00000000 $d
     /tmp/ccgE8nkV.s:1323   .rodata:00000000 .LC0
     /tmp/ccgE8nkV.s:1326   .text.vTaskStartScheduler:00000000 $t
     /tmp/ccgE8nkV.s:1331   .text.vTaskStartScheduler:00000000 vTaskStartScheduler
     /tmp/ccgE8nkV.s:2895   .text.prvIdleTask:00000000 prvIdleTask
     /tmp/ccgE8nkV.s:1400   .text.vTaskEndScheduler:00000000 $t
     /tmp/ccgE8nkV.s:1405   .text.vTaskEndScheduler:00000000 vTaskEndScheduler
     /tmp/ccgE8nkV.s:1439   .text.vTaskSuspendAll:00000000 $t
     /tmp/ccgE8nkV.s:1474   .text.xTaskResumeAll:00000000 $t
     /tmp/ccgE8nkV.s:1994   .text.vTaskIncrementTick:00000000 vTaskIncrementTick
     /tmp/ccgE8nkV.s:1653   .text.xTaskGetTickCount:00000000 $t
     /tmp/ccgE8nkV.s:1658   .text.xTaskGetTickCount:00000000 xTaskGetTickCount
     /tmp/ccgE8nkV.s:1695   .text.xTaskGetTickCountFromISR:00000000 $t
     /tmp/ccgE8nkV.s:1700   .text.xTaskGetTickCountFromISR:00000000 xTaskGetTickCountFromISR
     /tmp/ccgE8nkV.s:1750   .text.uxTaskGetNumberOfTasks:00000000 $t
     /tmp/ccgE8nkV.s:1755   .text.uxTaskGetNumberOfTasks:00000000 uxTaskGetNumberOfTasks
     /tmp/ccgE8nkV.s:1783   .rodata:00000008 .LC1
     /tmp/ccgE8nkV.s:1786   .text.vTaskGetRunTimeStats:00000000 $t
     /tmp/ccgE8nkV.s:1791   .text.vTaskGetRunTimeStats:00000000 vTaskGetRunTimeStats
     /tmp/ccgE8nkV.s:3382   .text.prvGenerateRunTimeStatsForTasksInList:00000000 prvGenerateRunTimeStatsForTasksInList
     /tmp/ccgE8nkV.s:1957   .text.xTaskGetIdleTaskHandle:00000000 $t
     /tmp/ccgE8nkV.s:1962   .text.xTaskGetIdleTaskHandle:00000000 xTaskGetIdleTaskHandle
     /tmp/ccgE8nkV.s:1989   .text.vTaskIncrementTick:00000000 $t
     /tmp/ccgE8nkV.s:2200   .text.vTaskSetApplicationTaskTag:00000000 $t
     /tmp/ccgE8nkV.s:2205   .text.vTaskSetApplicationTaskTag:00000000 vTaskSetApplicationTaskTag
     /tmp/ccgE8nkV.s:2255   .text.xTaskGetApplicationTaskTag:00000000 $t
     /tmp/ccgE8nkV.s:2260   .text.xTaskGetApplicationTaskTag:00000000 xTaskGetApplicationTaskTag
     /tmp/ccgE8nkV.s:2312   .text.xTaskCallApplicationTaskHook:00000000 $t
     /tmp/ccgE8nkV.s:2317   .text.xTaskCallApplicationTaskHook:00000000 xTaskCallApplicationTaskHook
     /tmp/ccgE8nkV.s:2379   .text.vTaskSwitchContext:00000000 $t
     /tmp/ccgE8nkV.s:2523   .text.vTaskPlaceOnEventList:00000000 $t
     /tmp/ccgE8nkV.s:2528   .text.vTaskPlaceOnEventList:00000000 vTaskPlaceOnEventList
     /tmp/ccgE8nkV.s:2596   .text.xTaskRemoveFromEventList:00000000 $t
     /tmp/ccgE8nkV.s:2601   .text.xTaskRemoveFromEventList:00000000 xTaskRemoveFromEventList
     /tmp/ccgE8nkV.s:2710   .text.vTaskSetTimeOutState:00000000 $t
     /tmp/ccgE8nkV.s:2715   .text.vTaskSetTimeOutState:00000000 vTaskSetTimeOutState
     /tmp/ccgE8nkV.s:2754   .text.xTaskCheckForTimeOut:00000000 $t
     /tmp/ccgE8nkV.s:2759   .text.xTaskCheckForTimeOut:00000000 xTaskCheckForTimeOut
     /tmp/ccgE8nkV.s:2859   .text.vTaskMissedYield:00000000 $t
     /tmp/ccgE8nkV.s:2864   .text.vTaskMissedYield:00000000 vTaskMissedYield
     /tmp/ccgE8nkV.s:2891   .text.prvIdleTask:00000000 $t
     /tmp/ccgE8nkV.s:3116   .text.prvCheckTasksWaitingTermination:00000000 prvCheckTasksWaitingTermination
     /tmp/ccgE8nkV.s:2934   .text.prvInitialiseTCBVariables:00000000 $t
     /tmp/ccgE8nkV.s:3025   .text.prvInitialiseTaskLists:00000000 $t
     /tmp/ccgE8nkV.s:3112   .text.prvCheckTasksWaitingTermination:00000000 $t
     /tmp/ccgE8nkV.s:3693   .text.prvDeleteTCB:00000000 prvDeleteTCB
     /tmp/ccgE8nkV.s:3203   .text.prvAddCurrentTaskToDelayedList:00000000 $t
     /tmp/ccgE8nkV.s:3283   .text.prvAllocateTCBAndStack:00000000 $t
     /tmp/ccgE8nkV.s:3369   .rodata:0000000c .LC2
     /tmp/ccgE8nkV.s:3372   .rodata:00000034 .LC3
     /tmp/ccgE8nkV.s:3375   .rodata:00000054 .LC4
     /tmp/ccgE8nkV.s:3378   .text.prvGenerateRunTimeStatsForTasksInList:00000000 $t
     /tmp/ccgE8nkV.s:3579   .text.usTaskCheckFreeStackSpace:00000000 usTaskCheckFreeStackSpace
     /tmp/ccgE8nkV.s:3575   .text.usTaskCheckFreeStackSpace:00000000 $t
     /tmp/ccgE8nkV.s:3631   .text.uxTaskGetStackHighWaterMark:00000000 $t
     /tmp/ccgE8nkV.s:3636   .text.uxTaskGetStackHighWaterMark:00000000 uxTaskGetStackHighWaterMark
     /tmp/ccgE8nkV.s:3689   .text.prvDeleteTCB:00000000 $t
     /tmp/ccgE8nkV.s:3727   .text.xTaskGetCurrentTaskHandle:00000000 $t
     /tmp/ccgE8nkV.s:3732   .text.xTaskGetCurrentTaskHandle:00000000 xTaskGetCurrentTaskHandle
     /tmp/ccgE8nkV.s:3766   .text.vTaskPriorityInherit:00000000 $t
     /tmp/ccgE8nkV.s:3771   .text.vTaskPriorityInherit:00000000 vTaskPriorityInherit
     /tmp/ccgE8nkV.s:3885   .text.vTaskPriorityDisinherit:00000000 $t
     /tmp/ccgE8nkV.s:3890   .text.vTaskPriorityDisinherit:00000000 vTaskPriorityDisinherit
                     .debug_frame:00000010 $d

UNDEFINED SYMBOLS
pxPortInitialiseStack
vPortEnterCritical
vListInsertEnd
vPortExitCritical
vPortYieldFromISR
vListRemove
init_us_timer
xPortStartScheduler
vPortEndScheduler
get_us_time
strlen
vListInsert
strncpy
vListInitialiseItem
vListInitialise
malloc
free
memset
sprintf
strcat
