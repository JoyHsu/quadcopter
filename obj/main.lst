   1              		.syntax unified
   2              		.cpu cortex-m4
   3              		.eabi_attribute 27, 3
   4              		.fpu fpv4-sp-d16
   5              		.eabi_attribute 20, 1
   6              		.eabi_attribute 21, 1
   7              		.eabi_attribute 23, 3
   8              		.eabi_attribute 24, 1
   9              		.eabi_attribute 25, 1
  10              		.eabi_attribute 26, 1
  11              		.eabi_attribute 30, 6
  12              		.eabi_attribute 34, 1
  13              		.eabi_attribute 18, 4
  14              		.thumb
  15              		.file	"main.c"
  16              		.text
  17              	.Ltext0:
  18              		.cfi_sections	.debug_frame
  19              		.section	.text.pwm,"ax",%progbits
  20              		.align	2
  21              		.global	pwm
  22              		.thumb
  23              		.thumb_func
  25              	pwm:
  26              	.LFB110:
  27              		.file 1 "src/main.c"
   1:src/main.c    **** /**
   2:src/main.c    ****   ******************************************************************************
   3:src/main.c    ****   * @file    STM32F4-Discovery FreeRTOS demo\main.c
   4:src/main.c    ****   * @author  T.O.M.A.S. Team
   5:src/main.c    ****   * @version V1.1.0
   6:src/main.c    ****   * @date    14-October-2011
   7:src/main.c    ****   * @brief   Main program body
   8:src/main.c    ****   ******************************************************************************
   9:src/main.c    ****   * @attention
  10:src/main.c    ****   *
  11:src/main.c    ****   * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
  12:src/main.c    ****   * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
  13:src/main.c    ****   * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
  14:src/main.c    ****   * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
  15:src/main.c    ****   * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
  16:src/main.c    ****   * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
  17:src/main.c    ****   *
  18:src/main.c    ****   * <h2><center>&copy; COPYRIGHT 2011 STMicroelectronics</center></h2>
  19:src/main.c    ****   ******************************************************************************
  20:src/main.c    ****   */ 
  21:src/main.c    **** 
  22:src/main.c    **** /* Includes ------------------------------------------------------------------*/
  23:src/main.c    **** #include "stm32f4xx.h"
  24:src/main.c    **** 
  25:src/main.c    **** 
  26:src/main.c    **** /* FreeRTOS includes */
  27:src/main.c    **** #include "FreeRTOS.h"
  28:src/main.c    **** #include "task.h"
  29:src/main.c    **** #include "semphr.h"
  30:src/main.c    **** 
  31:src/main.c    **** #include <math.h>
  32:src/main.c    **** #include <stdio.h>
  33:src/main.c    **** #include <stdlib.h>
  34:src/main.c    **** 
  35:src/main.c    **** #include "hw_config.h"
  36:src/main.c    **** #include "main.h"
  37:src/main.c    **** 
  38:src/main.c    **** /** @addtogroup STM32F4-Discovery_Demo
  39:src/main.c    ****   * @{
  40:src/main.c    ****   */
  41:src/main.c    **** 
  42:src/main.c    **** /* Private typedef -----------------------------------------------------------*/
  43:src/main.c    **** /* Private define ------------------------------------------------------------*/
  44:src/main.c    **** #define DELAY 125     /* msec */
  45:src/main.c    **** #define queueSIZE	6
  46:src/main.c    **** 
  47:src/main.c    **** /* angle */
  48:src/main.c    **** #define G 2
  49:src/main.c    **** /* Private macro -------------------------------------------------------------*/
  50:src/main.c    **** /**************************************************************************************************
  51:src/main.c    **** 
  52:src/main.c    **** 
  53:src/main.c    **** #define PWM_MOTOR_MIN 100
  54:src/main.c    **** #define PWM_MOTOR_MAX 1000
  55:src/main.c    **** #define TEST 200
  56:src/main.c    **** 
  57:src/main.c    **** #define PWM_Motor1 TIM4->CCR1   // 無刷 PWM
  58:src/main.c    **** #define PWM_Motor2 TIM4->CCR2   // 無刷 PWM
  59:src/main.c    **** #define PWM_Motor3 TIM4->CCR3   // 無刷 PWM
  60:src/main.c    **** #define PWM_Motor4 TIM4->CCR4   // 無刷 PWM
  61:src/main.c    **** 
  62:src/main.c    **** /* Private macro -------------------------------------------------------------*/
  63:src/main.c    **** /* Private variables ---------------------------------------------------------*/
  64:src/main.c    **** 
  65:src/main.c    **** 
  66:src/main.c    **** /* Private function prototypes -----------------------------------------------*/
  67:src/main.c    **** 
  68:src/main.c    **** /* Private define ------------------------------------------------------------*/
  69:src/main.c    **** /* Private macro -------------------------------------------------------------*/
  70:src/main.c    **** /* Private variables ---------------------------------------------------------*/
  71:src/main.c    **** 
  72:src/main.c    **** 
  73:src/main.c    **** 
  74:src/main.c    **** /* Private functions ---------------------------------------------------------*/
  75:src/main.c    **** 
  76:src/main.c    **** void pwm(void)
  77:src/main.c    **** {
  28              		.loc 1 77 0
  29              		.cfi_startproc
  30              		@ args = 0, pretend = 0, frame = 16
  31              		@ frame_needed = 1, uses_anonymous_args = 0
  32 0000 90B5     		push	{r4, r7, lr}
  33              	.LCFI0:
  34              		.cfi_def_cfa_offset 12
  35              		.cfi_offset 14, -4
  36              		.cfi_offset 7, -8
  37              		.cfi_offset 4, -12
  38 0002 85B0     		sub	sp, sp, #20
  39              	.LCFI1:
  40              		.cfi_def_cfa_offset 32
  41 0004 00AF     		add	r7, sp, #0
  42              	.LCFI2:
  43              		.cfi_def_cfa_register 7
  78:src/main.c    ****   volatile int i;
  79:src/main.c    ****   int n = 1;
  44              		.loc 1 79 0
  45 0006 4FF00103 		mov	r3, #1
  46 000a FB60     		str	r3, [r7, #12]
  80:src/main.c    ****   uint16_t brightness = 0;      
  47              		.loc 1 80 0
  48 000c 4FF00003 		mov	r3, #0
  49 0010 7B81     		strh	r3, [r7, #10]	@ movhi
  81:src/main.c    ****   uint16_t who_run = 1;
  50              		.loc 1 81 0
  51 0012 4FF00103 		mov	r3, #1
  52 0016 3B81     		strh	r3, [r7, #8]	@ movhi
  82:src/main.c    **** 
  83:src/main.c    ****  //Delay_1ms(50);
  84:src/main.c    **** 
  85:src/main.c    ****   Motor_Control(PWM_MOTOR_MAX, PWM_MOTOR_MAX, PWM_MOTOR_MAX, PWM_MOTOR_MAX);
  53              		.loc 1 85 0
  54 0018 40F20004 		movw	r4, #:lower16:Motor_Control
  55 001c C0F20004 		movt	r4, #:upper16:Motor_Control
  56 0020 4FF47A70 		mov	r0, #1000
  57 0024 4FF47A71 		mov	r1, #1000
  58 0028 4FF47A72 		mov	r2, #1000
  59 002c 4FF47A73 		mov	r3, #1000
  60 0030 A047     		blx	r4
  86:src/main.c    **** 
  87:src/main.c    ****  Delay_1ms(100);
  61              		.loc 1 87 0
  62 0032 40F20003 		movw	r3, #:lower16:Delay_1ms
  63 0036 C0F20003 		movt	r3, #:upper16:Delay_1ms
  64 003a 4FF06400 		mov	r0, #100
  65 003e 9847     		blx	r3
  88:src/main.c    **** 
  89:src/main.c    ****   Motor_Control(PWM_MOTOR_MIN, PWM_MOTOR_MIN, PWM_MOTOR_MIN, PWM_MOTOR_MIN);
  66              		.loc 1 89 0
  67 0040 40F20004 		movw	r4, #:lower16:Motor_Control
  68 0044 C0F20004 		movt	r4, #:upper16:Motor_Control
  69 0048 4FF06400 		mov	r0, #100
  70 004c 4FF06401 		mov	r1, #100
  71 0050 4FF06402 		mov	r2, #100
  72 0054 4FF06403 		mov	r3, #100
  73 0058 A047     		blx	r4
  90:src/main.c    ****   
  91:src/main.c    ****  Delay_1ms(100);
  74              		.loc 1 91 0
  75 005a 40F20003 		movw	r3, #:lower16:Delay_1ms
  76 005e C0F20003 		movt	r3, #:upper16:Delay_1ms
  77 0062 4FF06400 		mov	r0, #100
  78 0066 9847     		blx	r3
  79              	.L2:
  92:src/main.c    **** 
  93:src/main.c    ****   while(1)  // Do not exit
  94:src/main.c    ****   {
  95:src/main.c    ****    Motor_Control(TEST, TEST, TEST, TEST);
  80              		.loc 1 95 0 discriminator 1
  81 0068 40F20004 		movw	r4, #:lower16:Motor_Control
  82 006c C0F20004 		movt	r4, #:upper16:Motor_Control
  83 0070 4FF0C800 		mov	r0, #200
  84 0074 4FF0C801 		mov	r1, #200
  85 0078 4FF0C802 		mov	r2, #200
  86 007c 4FF0C803 		mov	r3, #200
  87 0080 A047     		blx	r4
  96:src/main.c    ****    
  97:src/main.c    ****    Delay_1ms(100);
  88              		.loc 1 97 0 discriminator 1
  89 0082 40F20003 		movw	r3, #:lower16:Delay_1ms
  90 0086 C0F20003 		movt	r3, #:upper16:Delay_1ms
  91 008a 4FF06400 		mov	r0, #100
  92 008e 9847     		blx	r3
  98:src/main.c    **** 
  99:src/main.c    ****    Motor_Control(TEST+50, TEST+50, TEST+50, TEST+50);
  93              		.loc 1 99 0 discriminator 1
  94 0090 40F20004 		movw	r4, #:lower16:Motor_Control
  95 0094 C0F20004 		movt	r4, #:upper16:Motor_Control
  96 0098 4FF0FA00 		mov	r0, #250
  97 009c 4FF0FA01 		mov	r1, #250
  98 00a0 4FF0FA02 		mov	r2, #250
  99 00a4 4FF0FA03 		mov	r3, #250
 100 00a8 A047     		blx	r4
 100:src/main.c    **** 
 101:src/main.c    ****    Delay_1ms(100);
 101              		.loc 1 101 0 discriminator 1
 102 00aa 40F20003 		movw	r3, #:lower16:Delay_1ms
 103 00ae C0F20003 		movt	r3, #:upper16:Delay_1ms
 104 00b2 4FF06400 		mov	r0, #100
 105 00b6 9847     		blx	r3
 102:src/main.c    **** 
 103:src/main.c    **** 
 104:src/main.c    **** 
 105:src/main.c    ****     //Light LEDs in turn
 106:src/main.c    ****     // switch(who_run){
 107:src/main.c    ****     //     case 0:
 108:src/main.c    ****     //         TIM4->CCR1 = brightness - 1; // set brightness
 109:src/main.c    ****     //         break;
 110:src/main.c    ****     //     case 1:
 111:src/main.c    ****     //         TIM4->CCR2 = brightness - 1; // set brightness
 112:src/main.c    ****     //         break;
 113:src/main.c    ****     //     case 2:
 114:src/main.c    ****     //         TIM4->CCR3 = brightness - 1; // set brightness
 115:src/main.c    ****     //         break;
 116:src/main.c    ****     //     case 3:
 117:src/main.c    ****     //         TIM4->CCR4 = brightness - 1; // set brightness
 118:src/main.c    ****     //         break;
 119:src/main.c    ****     // }
 120:src/main.c    **** 
 121:src/main.c    ****   }
 106              		.loc 1 121 0 discriminator 1
 107 00b8 D6E7     		b	.L2
 108              		.cfi_endproc
 109              	.LFE110:
 111 00ba 00BF     		.section	.text.Delay_1ms,"ax",%progbits
 112              		.align	2
 113              		.global	Delay_1ms
 114              		.thumb
 115              		.thumb_func
 117              	Delay_1ms:
 118              	.LFB111:
 122:src/main.c    ****  
 123:src/main.c    ****   return(0); // System will implode
 124:src/main.c    **** } 
 125:src/main.c    **** 
 126:src/main.c    **** 
 127:src/main.c    **** void Delay_1ms( vu32 nCnt_1ms )
 128:src/main.c    **** {
 119              		.loc 1 128 0
 120              		.cfi_startproc
 121              		@ args = 0, pretend = 0, frame = 16
 122              		@ frame_needed = 1, uses_anonymous_args = 0
 123              		@ link register save eliminated.
 124 0000 80B4     		push	{r7}
 125              	.LCFI3:
 126              		.cfi_def_cfa_offset 4
 127              		.cfi_offset 7, -4
 128 0002 85B0     		sub	sp, sp, #20
 129              	.LCFI4:
 130              		.cfi_def_cfa_offset 24
 131 0004 00AF     		add	r7, sp, #0
 132              	.LCFI5:
 133              		.cfi_def_cfa_register 7
 134 0006 7860     		str	r0, [r7, #4]
 129:src/main.c    ****     u32 nCnt;
 130:src/main.c    **** 	  for(; nCnt_1ms != 0; nCnt_1ms--)
 135              		.loc 1 130 0
 136 0008 0EE0     		b	.L4
 137              	.L7:
 131:src/main.c    **** 		    for(nCnt = 56580; nCnt != 0; nCnt--);
 138              		.loc 1 131 0
 139 000a 4DF60453 		movw	r3, #56580
 140 000e FB60     		str	r3, [r7, #12]
 141 0010 03E0     		b	.L5
 142              	.L6:
 143              		.loc 1 131 0 is_stmt 0 discriminator 2
 144 0012 FB68     		ldr	r3, [r7, #12]
 145 0014 03F1FF33 		add	r3, r3, #-1
 146 0018 FB60     		str	r3, [r7, #12]
 147              	.L5:
 148              		.loc 1 131 0 discriminator 1
 149 001a FB68     		ldr	r3, [r7, #12]
 150 001c 002B     		cmp	r3, #0
 151 001e F8D1     		bne	.L6
 130:src/main.c    **** 	  for(; nCnt_1ms != 0; nCnt_1ms--)
 152              		.loc 1 130 0 is_stmt 1
 153 0020 7B68     		ldr	r3, [r7, #4]
 154 0022 03F1FF33 		add	r3, r3, #-1
 155 0026 7B60     		str	r3, [r7, #4]
 156              	.L4:
 130:src/main.c    **** 	  for(; nCnt_1ms != 0; nCnt_1ms--)
 157              		.loc 1 130 0 is_stmt 0 discriminator 1
 158 0028 7B68     		ldr	r3, [r7, #4]
 159 002a 002B     		cmp	r3, #0
 160 002c EDD1     		bne	.L7
 132:src/main.c    **** }
 161              		.loc 1 132 0 is_stmt 1
 162 002e 07F11407 		add	r7, r7, #20
 163 0032 BD46     		mov	sp, r7
 164 0034 80BC     		pop	{r7}
 165 0036 7047     		bx	lr
 166              		.cfi_endproc
 167              	.LFE111:
 169              		.section	.text.Motor_Control,"ax",%progbits
 170              		.align	2
 171              		.global	Motor_Control
 172              		.thumb
 173              		.thumb_func
 175              	Motor_Control:
 176              	.LFB112:
 133:src/main.c    ****   
 134:src/main.c    **** void Motor_Control(u16 Motor1, u16 Motor2, u16 Motor3, u16 Motor4)
 135:src/main.c    **** {
 177              		.loc 1 135 0
 178              		.cfi_startproc
 179              		@ args = 0, pretend = 0, frame = 8
 180              		@ frame_needed = 1, uses_anonymous_args = 0
 181              		@ link register save eliminated.
 182 0000 80B4     		push	{r7}
 183              	.LCFI6:
 184              		.cfi_def_cfa_offset 4
 185              		.cfi_offset 7, -4
 186 0002 83B0     		sub	sp, sp, #12
 187              	.LCFI7:
 188              		.cfi_def_cfa_offset 16
 189 0004 00AF     		add	r7, sp, #0
 190              	.LCFI8:
 191              		.cfi_def_cfa_register 7
 192 0006 F880     		strh	r0, [r7, #6]	@ movhi
 193 0008 B980     		strh	r1, [r7, #4]	@ movhi
 194 000a 7A80     		strh	r2, [r7, #2]	@ movhi
 195 000c 3B80     		strh	r3, [r7, #0]	@ movhi
 136:src/main.c    **** 	if(Motor1>PWM_MOTOR_MAX)      Motor1 = PWM_MOTOR_MAX;
 196              		.loc 1 136 0
 197 000e FB88     		ldrh	r3, [r7, #6]
 198 0010 B3F57A7F 		cmp	r3, #1000
 199 0014 03D9     		bls	.L9
 200              		.loc 1 136 0 is_stmt 0 discriminator 1
 201 0016 4FF47A73 		mov	r3, #1000
 202 001a FB80     		strh	r3, [r7, #6]	@ movhi
 203 001c 05E0     		b	.L10
 204              	.L9:
 137:src/main.c    **** 	else if(Motor1<PWM_MOTOR_MIN) Motor1 = PWM_MOTOR_MIN;
 205              		.loc 1 137 0 is_stmt 1
 206 001e FB88     		ldrh	r3, [r7, #6]
 207 0020 632B     		cmp	r3, #99
 208 0022 02D8     		bhi	.L10
 209              		.loc 1 137 0 is_stmt 0 discriminator 1
 210 0024 4FF06403 		mov	r3, #100
 211 0028 FB80     		strh	r3, [r7, #6]	@ movhi
 212              	.L10:
 138:src/main.c    **** 		
 139:src/main.c    **** 	if(Motor2>PWM_MOTOR_MAX)      Motor2 = PWM_MOTOR_MAX;
 213              		.loc 1 139 0 is_stmt 1
 214 002a BB88     		ldrh	r3, [r7, #4]
 215 002c B3F57A7F 		cmp	r3, #1000
 216 0030 03D9     		bls	.L11
 217              		.loc 1 139 0 is_stmt 0 discriminator 1
 218 0032 4FF47A73 		mov	r3, #1000
 219 0036 BB80     		strh	r3, [r7, #4]	@ movhi
 220 0038 05E0     		b	.L12
 221              	.L11:
 140:src/main.c    **** 	else if(Motor2<PWM_MOTOR_MIN) Motor2 = PWM_MOTOR_MIN;
 222              		.loc 1 140 0 is_stmt 1
 223 003a BB88     		ldrh	r3, [r7, #4]
 224 003c 632B     		cmp	r3, #99
 225 003e 02D8     		bhi	.L12
 226              		.loc 1 140 0 is_stmt 0 discriminator 1
 227 0040 4FF06403 		mov	r3, #100
 228 0044 BB80     		strh	r3, [r7, #4]	@ movhi
 229              	.L12:
 141:src/main.c    **** 				
 142:src/main.c    **** 	if(Motor3>PWM_MOTOR_MAX)      Motor3 = PWM_MOTOR_MAX;
 230              		.loc 1 142 0 is_stmt 1
 231 0046 7B88     		ldrh	r3, [r7, #2]
 232 0048 B3F57A7F 		cmp	r3, #1000
 233 004c 03D9     		bls	.L13
 234              		.loc 1 142 0 is_stmt 0 discriminator 1
 235 004e 4FF47A73 		mov	r3, #1000
 236 0052 7B80     		strh	r3, [r7, #2]	@ movhi
 237 0054 05E0     		b	.L14
 238              	.L13:
 143:src/main.c    **** 	else if(Motor3<PWM_MOTOR_MIN) Motor3 = PWM_MOTOR_MIN;
 239              		.loc 1 143 0 is_stmt 1
 240 0056 7B88     		ldrh	r3, [r7, #2]
 241 0058 632B     		cmp	r3, #99
 242 005a 02D8     		bhi	.L14
 243              		.loc 1 143 0 is_stmt 0 discriminator 1
 244 005c 4FF06403 		mov	r3, #100
 245 0060 7B80     		strh	r3, [r7, #2]	@ movhi
 246              	.L14:
 144:src/main.c    **** 						
 145:src/main.c    **** 	if(Motor4>PWM_MOTOR_MAX)      Motor4 = PWM_MOTOR_MAX;
 247              		.loc 1 145 0 is_stmt 1
 248 0062 3B88     		ldrh	r3, [r7, #0]
 249 0064 B3F57A7F 		cmp	r3, #1000
 250 0068 03D9     		bls	.L15
 251              		.loc 1 145 0 is_stmt 0 discriminator 1
 252 006a 4FF47A73 		mov	r3, #1000
 253 006e 3B80     		strh	r3, [r7, #0]	@ movhi
 254 0070 05E0     		b	.L16
 255              	.L15:
 146:src/main.c    **** 	else if(Motor4<PWM_MOTOR_MIN) Motor4 = PWM_MOTOR_MIN;
 256              		.loc 1 146 0 is_stmt 1
 257 0072 3B88     		ldrh	r3, [r7, #0]
 258 0074 632B     		cmp	r3, #99
 259 0076 02D8     		bhi	.L16
 260              		.loc 1 146 0 is_stmt 0 discriminator 1
 261 0078 4FF06403 		mov	r3, #100
 262 007c 3B80     		strh	r3, [r7, #0]	@ movhi
 263              	.L16:
 147:src/main.c    **** 								
 148:src/main.c    **** 	PWM_Motor1 = Motor1;
 264              		.loc 1 148 0 is_stmt 1
 265 007e 4FF40063 		mov	r3, #2048
 266 0082 C4F20003 		movt	r3, 16384
 267 0086 FA88     		ldrh	r2, [r7, #6]
 268 0088 5A63     		str	r2, [r3, #52]
 149:src/main.c    **** 	PWM_Motor2 = Motor2;
 269              		.loc 1 149 0
 270 008a 4FF40063 		mov	r3, #2048
 271 008e C4F20003 		movt	r3, 16384
 272 0092 BA88     		ldrh	r2, [r7, #4]
 273 0094 9A63     		str	r2, [r3, #56]
 150:src/main.c    **** 	PWM_Motor3 = Motor3;
 274              		.loc 1 150 0
 275 0096 4FF40063 		mov	r3, #2048
 276 009a C4F20003 		movt	r3, 16384
 277 009e 7A88     		ldrh	r2, [r7, #2]
 278 00a0 DA63     		str	r2, [r3, #60]
 151:src/main.c    **** 	PWM_Motor4 = Motor4;
 279              		.loc 1 151 0
 280 00a2 4FF40063 		mov	r3, #2048
 281 00a6 C4F20003 		movt	r3, 16384
 282 00aa 3A88     		ldrh	r2, [r7, #0]
 283 00ac 1A64     		str	r2, [r3, #64]
 152:src/main.c    **** }
 284              		.loc 1 152 0
 285 00ae 07F10C07 		add	r7, r7, #12
 286 00b2 BD46     		mov	sp, r7
 287 00b4 80BC     		pop	{r7}
 288 00b6 7047     		bx	lr
 289              		.cfi_endproc
 290              	.LFE112:
 292              		.section	.text.RCC_Configuration,"ax",%progbits
 293              		.align	2
 294              		.global	RCC_Configuration
 295              		.thumb
 296              		.thumb_func
 298              	RCC_Configuration:
 299              	.LFB113:
 153:src/main.c    **** 
 154:src/main.c    **** /**
 155:src/main.c    ****   * @brief  Configures the different system clocks.
 156:src/main.c    ****   * @param  None
 157:src/main.c    ****   * @retval None
 158:src/main.c    ****   */
 159:src/main.c    **** void RCC_Configuration(void)
 160:src/main.c    **** {
 300              		.loc 1 160 0
 301              		.cfi_startproc
 302              		@ args = 0, pretend = 0, frame = 0
 303              		@ frame_needed = 1, uses_anonymous_args = 0
 304 0000 80B5     		push	{r7, lr}
 305              	.LCFI9:
 306              		.cfi_def_cfa_offset 8
 307              		.cfi_offset 14, -4
 308              		.cfi_offset 7, -8
 309 0002 00AF     		add	r7, sp, #0
 310              	.LCFI10:
 311              		.cfi_def_cfa_register 7
 161:src/main.c    ****    RCC_AHB1PeriphClockCmd(  RCC_AHB1Periph_GPIOD , ENABLE );
 312              		.loc 1 161 0
 313 0004 4FF00800 		mov	r0, #8
 314 0008 4FF00101 		mov	r1, #1
 315 000c FFF7FEFF 		bl	RCC_AHB1PeriphClockCmd
 162:src/main.c    ****    RCC_APB1PeriphClockCmd( RCC_APB1Periph_TIM4, ENABLE );
 316              		.loc 1 162 0
 317 0010 4FF00400 		mov	r0, #4
 318 0014 4FF00101 		mov	r1, #1
 319 0018 FFF7FEFF 		bl	RCC_APB1PeriphClockCmd
 163:src/main.c    **** }
 320              		.loc 1 163 0
 321 001c 80BD     		pop	{r7, pc}
 322              		.cfi_endproc
 323              	.LFE113:
 325 001e 00BF     		.section	.text.GPIO_Configuration,"ax",%progbits
 326              		.align	2
 327              		.global	GPIO_Configuration
 328              		.thumb
 329              		.thumb_func
 331              	GPIO_Configuration:
 332              	.LFB114:
 164:src/main.c    **** 
 165:src/main.c    **** /**
 166:src/main.c    ****   * @brief  configure the PD12~15 to Timers
 167:src/main.c    ****   * @param  None
 168:src/main.c    ****   * @retval None
 169:src/main.c    ****   */
 170:src/main.c    **** void GPIO_Configuration(void)
 171:src/main.c    **** {
 333              		.loc 1 171 0
 334              		.cfi_startproc
 335              		@ args = 0, pretend = 0, frame = 8
 336              		@ frame_needed = 1, uses_anonymous_args = 0
 337 0000 80B5     		push	{r7, lr}
 338              	.LCFI11:
 339              		.cfi_def_cfa_offset 8
 340              		.cfi_offset 14, -4
 341              		.cfi_offset 7, -8
 342 0002 82B0     		sub	sp, sp, #8
 343              	.LCFI12:
 344              		.cfi_def_cfa_offset 16
 345 0004 00AF     		add	r7, sp, #0
 346              	.LCFI13:
 347              		.cfi_def_cfa_register 7
 172:src/main.c    ****     GPIO_InitTypeDef GPIO_InitStructure;
 173:src/main.c    ****     GPIO_StructInit(&GPIO_InitStructure); // Reset init structure
 348              		.loc 1 173 0
 349 0006 3B46     		mov	r3, r7
 350 0008 1846     		mov	r0, r3
 351 000a FFF7FEFF 		bl	GPIO_StructInit
 174:src/main.c    ****  
 175:src/main.c    ****     GPIO_PinAFConfig(GPIOD, GPIO_PinSource12, GPIO_AF_TIM4);
 352              		.loc 1 175 0
 353 000e 4FF44060 		mov	r0, #3072
 354 0012 C4F20200 		movt	r0, 16386
 355 0016 4FF00C01 		mov	r1, #12
 356 001a 4FF00202 		mov	r2, #2
 357 001e FFF7FEFF 		bl	GPIO_PinAFConfig
 176:src/main.c    ****     GPIO_PinAFConfig(GPIOD, GPIO_PinSource13, GPIO_AF_TIM4);
 358              		.loc 1 176 0
 359 0022 4FF44060 		mov	r0, #3072
 360 0026 C4F20200 		movt	r0, 16386
 361 002a 4FF00D01 		mov	r1, #13
 362 002e 4FF00202 		mov	r2, #2
 363 0032 FFF7FEFF 		bl	GPIO_PinAFConfig
 177:src/main.c    ****     GPIO_PinAFConfig(GPIOD, GPIO_PinSource14, GPIO_AF_TIM4);
 364              		.loc 1 177 0
 365 0036 4FF44060 		mov	r0, #3072
 366 003a C4F20200 		movt	r0, 16386
 367 003e 4FF00E01 		mov	r1, #14
 368 0042 4FF00202 		mov	r2, #2
 369 0046 FFF7FEFF 		bl	GPIO_PinAFConfig
 178:src/main.c    ****     GPIO_PinAFConfig(GPIOD, GPIO_PinSource15, GPIO_AF_TIM4);
 370              		.loc 1 178 0
 371 004a 4FF44060 		mov	r0, #3072
 372 004e C4F20200 		movt	r0, 16386
 373 0052 4FF00F01 		mov	r1, #15
 374 0056 4FF00202 		mov	r2, #2
 375 005a FFF7FEFF 		bl	GPIO_PinAFConfig
 179:src/main.c    ****       
 180:src/main.c    **** 
 181:src/main.c    ****     // Setup Blue & Green LED on STM32-Discovery Board to use PWM.
 182:src/main.c    ****     GPIO_InitStructure.GPIO_Pin =  GPIO_Pin_12 | GPIO_Pin_13| GPIO_Pin_14| GPIO_Pin_15; 
 376              		.loc 1 182 0
 377 005e 4FF47043 		mov	r3, #61440
 378 0062 3B60     		str	r3, [r7, #0]
 183:src/main.c    **** 	//PD12->LED3 PD13->LED4 PD14->LED5 PD15->LED6
 184:src/main.c    **** 	//GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;            // Alt Function - Push Pull
 185:src/main.c    **** 	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF; 
 379              		.loc 1 185 0
 380 0064 4FF00203 		mov	r3, #2
 381 0068 3B71     		strb	r3, [r7, #4]
 186:src/main.c    ****     GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
 382              		.loc 1 186 0
 383 006a 4FF00003 		mov	r3, #0
 384 006e BB71     		strb	r3, [r7, #6]
 187:src/main.c    ****     GPIO_InitStructure.GPIO_Speed = GPIO_Speed_100MHz;
 385              		.loc 1 187 0
 386 0070 4FF00303 		mov	r3, #3
 387 0074 7B71     		strb	r3, [r7, #5]
 188:src/main.c    ****     GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;
 388              		.loc 1 188 0
 389 0076 4FF00003 		mov	r3, #0
 390 007a FB71     		strb	r3, [r7, #7]
 189:src/main.c    ****     GPIO_Init( GPIOD, &GPIO_InitStructure );  
 391              		.loc 1 189 0
 392 007c 4FF44060 		mov	r0, #3072
 393 0080 C4F20200 		movt	r0, 16386
 394 0084 3B46     		mov	r3, r7
 395 0086 1946     		mov	r1, r3
 396 0088 FFF7FEFF 		bl	GPIO_Init
 190:src/main.c    **** }
 397              		.loc 1 190 0
 398 008c 07F10807 		add	r7, r7, #8
 399 0090 BD46     		mov	sp, r7
 400 0092 80BD     		pop	{r7, pc}
 401              		.cfi_endproc
 402              	.LFE114:
 404              		.section	.text.TIM_Configuration,"ax",%progbits
 405              		.align	2
 406              		.global	TIM_Configuration
 407              		.thumb
 408              		.thumb_func
 410              	TIM_Configuration:
 411              	.LFB115:
 191:src/main.c    **** 
 192:src/main.c    **** /**
 193:src/main.c    ****   * @brief  configure the TIM4 for PWM mode
 194:src/main.c    ****   * @param  None
 195:src/main.c    ****   * @retval None
 196:src/main.c    ****   */
 197:src/main.c    **** void TIM_Configuration(void)
 198:src/main.c    **** {
 412              		.loc 1 198 0
 413              		.cfi_startproc
 414              		@ args = 0, pretend = 0, frame = 32
 415              		@ frame_needed = 1, uses_anonymous_args = 0
 416 0000 80B5     		push	{r7, lr}
 417              	.LCFI14:
 418              		.cfi_def_cfa_offset 8
 419              		.cfi_offset 14, -4
 420              		.cfi_offset 7, -8
 421 0002 88B0     		sub	sp, sp, #32
 422              	.LCFI15:
 423              		.cfi_def_cfa_offset 40
 424 0004 00AF     		add	r7, sp, #0
 425              	.LCFI16:
 426              		.cfi_def_cfa_register 7
 199:src/main.c    ****     TIM_TimeBaseInitTypeDef TIM_TimeBaseInitStruct;
 200:src/main.c    ****     TIM_OCInitTypeDef TIM_OCInitStruct;
 201:src/main.c    **** 
 202:src/main.c    ****     // Let PWM frequency equal 100Hz.
 203:src/main.c    ****     // Let period equal 1000. Therefore, timer runs from zero to 1000. Gives 0.1Hz resolution.
 204:src/main.c    ****     // Solving for prescaler gives 240.
 205:src/main.c    ****     TIM_TimeBaseStructInit( &TIM_TimeBaseInitStruct );
 427              		.loc 1 205 0
 428 0006 07F11403 		add	r3, r7, #20
 429 000a 1846     		mov	r0, r3
 430 000c FFF7FEFF 		bl	TIM_TimeBaseStructInit
 206:src/main.c    ****     TIM_TimeBaseInitStruct.TIM_ClockDivision = TIM_CKD_DIV4;
 431              		.loc 1 206 0
 432 0010 4FF40073 		mov	r3, #512
 433 0014 BB83     		strh	r3, [r7, #28]	@ movhi
 207:src/main.c    ****     TIM_TimeBaseInitStruct.TIM_Period = 3360 - 1;   
 434              		.loc 1 207 0
 435 0016 40F61F53 		movw	r3, #3359
 436 001a BB61     		str	r3, [r7, #24]
 208:src/main.c    ****     TIM_TimeBaseInitStruct.TIM_Prescaler = 500 - 1; 
 437              		.loc 1 208 0
 438 001c 40F2F313 		movw	r3, #499
 439 0020 BB82     		strh	r3, [r7, #20]	@ movhi
 209:src/main.c    ****     TIM_TimeBaseInitStruct.TIM_CounterMode = TIM_CounterMode_Up;    
 440              		.loc 1 209 0
 441 0022 4FF00003 		mov	r3, #0
 442 0026 FB82     		strh	r3, [r7, #22]	@ movhi
 210:src/main.c    ****     TIM_TimeBaseInit( TIM4, &TIM_TimeBaseInitStruct );
 443              		.loc 1 210 0
 444 0028 4FF40060 		mov	r0, #2048
 445 002c C4F20000 		movt	r0, 16384
 446 0030 07F11403 		add	r3, r7, #20
 447 0034 1946     		mov	r1, r3
 448 0036 FFF7FEFF 		bl	TIM_TimeBaseInit
 211:src/main.c    ****     
 212:src/main.c    ****     TIM_OCStructInit( &TIM_OCInitStruct );
 449              		.loc 1 212 0
 450 003a 3B46     		mov	r3, r7
 451 003c 1846     		mov	r0, r3
 452 003e FFF7FEFF 		bl	TIM_OCStructInit
 213:src/main.c    ****     TIM_OCInitStruct.TIM_OutputState = TIM_OutputState_Enable;
 453              		.loc 1 213 0
 454 0042 4FF00103 		mov	r3, #1
 455 0046 7B80     		strh	r3, [r7, #2]	@ movhi
 214:src/main.c    ****     TIM_OCInitStruct.TIM_OCMode = TIM_OCMode_PWM1;
 456              		.loc 1 214 0
 457 0048 4FF06003 		mov	r3, #96
 458 004c 3B80     		strh	r3, [r7, #0]	@ movhi
 215:src/main.c    ****     
 216:src/main.c    ****     // Initial duty cycle equals 0%. Value can range from zero to 65535.
 217:src/main.c    ****     //TIM_Pulse = TIM4_CCR1 register (16 bits)
 218:src/main.c    ****     TIM_OCInitStruct.TIM_Pulse = 0; //(0=Always Off, 65535=Always On)
 459              		.loc 1 218 0
 460 004e 4FF00003 		mov	r3, #0
 461 0052 BB60     		str	r3, [r7, #8]
 219:src/main.c    ****  
 220:src/main.c    ****     TIM_OC1Init( TIM4, &TIM_OCInitStruct ); // Channel 1  LED
 462              		.loc 1 220 0
 463 0054 4FF40060 		mov	r0, #2048
 464 0058 C4F20000 		movt	r0, 16384
 465 005c 3B46     		mov	r3, r7
 466 005e 1946     		mov	r1, r3
 467 0060 FFF7FEFF 		bl	TIM_OC1Init
 221:src/main.c    ****     TIM_OC2Init( TIM4, &TIM_OCInitStruct ); // Channel 2  LED
 468              		.loc 1 221 0
 469 0064 4FF40060 		mov	r0, #2048
 470 0068 C4F20000 		movt	r0, 16384
 471 006c 3B46     		mov	r3, r7
 472 006e 1946     		mov	r1, r3
 473 0070 FFF7FEFF 		bl	TIM_OC2Init
 222:src/main.c    ****     TIM_OC3Init( TIM4, &TIM_OCInitStruct ); // Channel 3  LED
 474              		.loc 1 222 0
 475 0074 4FF40060 		mov	r0, #2048
 476 0078 C4F20000 		movt	r0, 16384
 477 007c 3B46     		mov	r3, r7
 478 007e 1946     		mov	r1, r3
 479 0080 FFF7FEFF 		bl	TIM_OC3Init
 223:src/main.c    ****     TIM_OC4Init( TIM4, &TIM_OCInitStruct ); // Channel 4  LED
 480              		.loc 1 223 0
 481 0084 4FF40060 		mov	r0, #2048
 482 0088 C4F20000 		movt	r0, 16384
 483 008c 3B46     		mov	r3, r7
 484 008e 1946     		mov	r1, r3
 485 0090 FFF7FEFF 		bl	TIM_OC4Init
 224:src/main.c    ****  
 225:src/main.c    ****     TIM_Cmd( TIM4, ENABLE );
 486              		.loc 1 225 0
 487 0094 4FF40060 		mov	r0, #2048
 488 0098 C4F20000 		movt	r0, 16384
 489 009c 4FF00101 		mov	r1, #1
 490 00a0 FFF7FEFF 		bl	TIM_Cmd
 226:src/main.c    **** }
 491              		.loc 1 226 0
 492 00a4 07F12007 		add	r7, r7, #32
 493 00a8 BD46     		mov	sp, r7
 494 00aa 80BD     		pop	{r7, pc}
 495              		.cfi_endproc
 496              	.LFE115:
 498              		.comm	xLED_Tasks,16,4
 499              		.comm	xMEMS_Task,4,4
 500              		.comm	xBALANCE_Task,4,4
 501              		.comm	ITM_RxBuffer,4,4
 502              		.section	.rodata.LEDS,"a",%progbits
 503              		.align	2
 506              	LEDS:
 507 0000 01000000 		.word	1
 508 0004 7D000000 		.word	125
 509 0008 00000000 		.word	0
 510 000c FA000000 		.word	250
 511 0010 02000000 		.word	2
 512 0014 77010000 		.word	375
 513 0018 03000000 		.word	3
 514 001c F4010000 		.word	500
 515              		.global	xSemaphoreSW
 516              		.section	.bss.xSemaphoreSW,"aw",%nobits
 517              		.align	2
 520              	xSemaphoreSW:
 521 0000 00000000 		.space	4
 522              		.comm	xQueue,4,4
 523              		.section	.rodata
 524              		.align	2
 525              	.LC0:
 526 0000 4D454D53 		.ascii	"MEMS\000"
 526      00
 527 0005 000000   		.section	.text.main,"ax",%progbits
 528              		.align	2
 529              		.global	main
 530              		.thumb
 531              		.thumb_func
 533              	main:
 534              	.LFB116:
 227:src/main.c    **** /**************************************************************************************************
 228:src/main.c    **** /* Private functions ---------------------------------------------------------*/
 229:src/main.c    **** 
 230:src/main.c    **** /* Task functions declarations */
 231:src/main.c    **** static void vLEDTask( void *pvParameters );
 232:src/main.c    **** static void vSWITCHTask( void *pvParameters );
 233:src/main.c    **** static void vMEMSTask(void *pvParameters);
 234:src/main.c    **** static void vBALANCETask(void *pvParameters);
 235:src/main.c    **** 
 236:src/main.c    **** /* handlers to tasks to better control them */
 237:src/main.c    **** xTaskHandle xLED_Tasks[4];
 238:src/main.c    **** xTaskHandle xMEMS_Task, xBALANCE_Task;
 239:src/main.c    **** 
 240:src/main.c    **** /* variables used by tasks */
 241:src/main.c    **** volatile int32_t ITM_RxBuffer;
 242:src/main.c    **** /* initial arguments for vLEDTask task (which LED and what is the delay) */
 243:src/main.c    **** static const int LEDS[4][2] = {{LED3,DELAY*1},
 244:src/main.c    **** 							   {LED4,DELAY*2},
 245:src/main.c    **** 							   {LED5,DELAY*3},
 246:src/main.c    **** 							   {LED6,DELAY*4}};
 247:src/main.c    **** 
 248:src/main.c    **** /* semaphores, queues declarations */
 249:src/main.c    **** xSemaphoreHandle xSemaphoreSW  = NULL;
 250:src/main.c    **** xQueueHandle xQueue;
 251:src/main.c    **** 
 252:src/main.c    **** /**
 253:src/main.c    ****   * @brief  Main program.
 254:src/main.c    ****   * @param  None
 255:src/main.c    ****   * @retval None
 256:src/main.c    ****   */
 257:src/main.c    **** int main(void)
 258:src/main.c    **** { 
 535              		.loc 1 258 0
 536              		.cfi_startproc
 537              		@ args = 0, pretend = 0, frame = 0
 538              		@ frame_needed = 1, uses_anonymous_args = 0
 539 0000 80B5     		push	{r7, lr}
 540              	.LCFI17:
 541              		.cfi_def_cfa_offset 8
 542              		.cfi_offset 14, -4
 543              		.cfi_offset 7, -8
 544 0002 84B0     		sub	sp, sp, #16
 545              	.LCFI18:
 546              		.cfi_def_cfa_offset 24
 547 0004 04AF     		add	r7, sp, #16
 548              	.LCFI19:
 549              		.cfi_def_cfa 7, 8
 259:src/main.c    **** 	/* create a pipe for MEMS->TIM4 data exchange */
 260:src/main.c    **** 	xQueue=xQueueCreate(1,queueSIZE*sizeof(uint8_t));
 550              		.loc 1 260 0
 551 0006 4FF00100 		mov	r0, #1
 552 000a 4FF00601 		mov	r1, #6
 553 000e FFF7FEFF 		bl	xQueueCreate
 554 0012 0246     		mov	r2, r0
 555 0014 40F20003 		movw	r3, #:lower16:xQueue
 556 0018 C0F20003 		movt	r3, #:upper16:xQueue
 557 001c 1A60     		str	r2, [r3, #0]
 261:src/main.c    **** 
 262:src/main.c    **** 	/* create semaphores... */
 263:src/main.c    **** 	vSemaphoreCreateBinary( xSemaphoreSW );
 558              		.loc 1 263 0
 559 001e 4FF00100 		mov	r0, #1
 560 0022 4FF00001 		mov	r1, #0
 561 0026 FFF7FEFF 		bl	xQueueCreate
 562 002a 0246     		mov	r2, r0
 563 002c 40F20003 		movw	r3, #:lower16:xSemaphoreSW
 564 0030 C0F20003 		movt	r3, #:upper16:xSemaphoreSW
 565 0034 1A60     		str	r2, [r3, #0]
 566 0036 40F20003 		movw	r3, #:lower16:xSemaphoreSW
 567 003a C0F20003 		movt	r3, #:upper16:xSemaphoreSW
 568 003e 1B68     		ldr	r3, [r3, #0]
 569 0040 002B     		cmp	r3, #0
 570 0042 0DD0     		beq	.L21
 571              		.loc 1 263 0 is_stmt 0 discriminator 1
 572 0044 40F20003 		movw	r3, #:lower16:xSemaphoreSW
 573 0048 C0F20003 		movt	r3, #:upper16:xSemaphoreSW
 574 004c 1B68     		ldr	r3, [r3, #0]
 575 004e 1846     		mov	r0, r3
 576 0050 4FF00001 		mov	r1, #0
 577 0054 4FF00002 		mov	r2, #0
 578 0058 4FF00003 		mov	r3, #0
 579 005c FFF7FEFF 		bl	xQueueGenericSend
 580              	.L21:
 264:src/main.c    **** 
 265:src/main.c    **** 	/* ...and clean them up */
 266:src/main.c    **** 	if(xSemaphoreTake(xSemaphoreSW, ( portTickType ) 0) == pdTRUE);
 581              		.loc 1 266 0 is_stmt 1
 582 0060 40F20003 		movw	r3, #:lower16:xSemaphoreSW
 583 0064 C0F20003 		movt	r3, #:upper16:xSemaphoreSW
 584 0068 1B68     		ldr	r3, [r3, #0]
 585 006a 1846     		mov	r0, r3
 586 006c 4FF00001 		mov	r1, #0
 587 0070 4FF00002 		mov	r2, #0
 588 0074 4FF00003 		mov	r3, #0
 589 0078 FFF7FEFF 		bl	xQueueGenericReceive
 267:src/main.c    **** 	
 268:src/main.c    **** 	/* initialize hardware... */
 269:src/main.c    **** 	prvSetupHardware();
 590              		.loc 1 269 0
 591 007c FFF7FEFF 		bl	prvSetupHardware
 270:src/main.c    **** 	RCC_Configuration();
 592              		.loc 1 270 0
 593 0080 FFF7FEFF 		bl	RCC_Configuration
 271:src/main.c    **** 	TIM_Configuration();
 594              		.loc 1 271 0
 595 0084 FFF7FEFF 		bl	TIM_Configuration
 272:src/main.c    **** 	GPIO_Configuration();
 596              		.loc 1 272 0
 597 0088 FFF7FEFF 		bl	GPIO_Configuration
 273:src/main.c    **** 
 274:src/main.c    **** 	/* Start the tasks defined within this file/specific to this demo. */
 275:src/main.c    **** 	//xTaskCreate( vLEDTask, ( signed portCHAR * ) "LED3", configMINIMAL_STACK_SIZE, (void *)LEDS[0],t
 276:src/main.c    **** 	//xTaskCreate( vLEDTask, ( signed portCHAR * ) "LED4", configMINIMAL_STACK_SIZE, (void *)LEDS[1],t
 277:src/main.c    **** 	//xTaskCreate( vLEDTask, ( signed portCHAR * ) "LED5", configMINIMAL_STACK_SIZE, (void *)LEDS[2],t
 278:src/main.c    **** 	//xTaskCreate( vLEDTask, ( signed portCHAR * ) "LED6", configMINIMAL_STACK_SIZE, (void *)LEDS[3],t
 279:src/main.c    **** 	//xTaskCreate( vSWITCHTask, ( signed portCHAR * ) "SWITCH", configMINIMAL_STACK_SIZE, NULL,tskIDLE
 280:src/main.c    **** 	xTaskCreate( vMEMSTask, ( signed portCHAR * ) "MEMS", configMINIMAL_STACK_SIZE, NULL,tskIDLE_PRIOR
 598              		.loc 1 280 0
 599 008c 4FF00003 		mov	r3, #0
 600 0090 0093     		str	r3, [sp, #0]
 601 0092 40F20003 		movw	r3, #:lower16:xMEMS_Task
 602 0096 C0F20003 		movt	r3, #:upper16:xMEMS_Task
 603 009a 0193     		str	r3, [sp, #4]
 604 009c 4FF00003 		mov	r3, #0
 605 00a0 0293     		str	r3, [sp, #8]
 606 00a2 4FF00003 		mov	r3, #0
 607 00a6 0393     		str	r3, [sp, #12]
 608 00a8 40F20000 		movw	r0, #:lower16:vMEMSTask
 609 00ac C0F20000 		movt	r0, #:upper16:vMEMSTask
 610 00b0 40F20001 		movw	r1, #:lower16:.LC0
 611 00b4 C0F20001 		movt	r1, #:upper16:.LC0
 612 00b8 4FF48072 		mov	r2, #256
 613 00bc 4FF00003 		mov	r3, #0
 614 00c0 FFF7FEFF 		bl	xTaskGenericCreate
 281:src/main.c    **** 	//xTaskCreate( vBALANCETask, ( signed portCHAR * ) "BALANCE", configMINIMAL_STACK_SIZE, NULL,tskID
 282:src/main.c    **** 
 283:src/main.c    **** 	/* Start the scheduler. */
 284:src/main.c    **** 	vTaskStartScheduler();
 615              		.loc 1 284 0
 616 00c4 FFF7FEFF 		bl	vTaskStartScheduler
 285:src/main.c    **** 
 286:src/main.c    **** 	/* Will only get here if there was not enough heap space to create the idle task. */
 287:src/main.c    **** 	return 0;  
 617              		.loc 1 287 0
 618 00c8 4FF00003 		mov	r3, #0
 288:src/main.c    **** }
 619              		.loc 1 288 0
 620 00cc 1846     		mov	r0, r3
 621 00ce BD46     		mov	sp, r7
 622 00d0 80BD     		pop	{r7, pc}
 623              		.cfi_endproc
 624              	.LFE116:
 626 00d2 00BF     		.section	.text.vMEMSTask,"ax",%progbits
 627              		.align	2
 628              		.thumb
 629              		.thumb_func
 631              	vMEMSTask:
 632              	.LFB117:
 289:src/main.c    **** 
 290:src/main.c    **** /*-----------------------------------------------------------*/
 291:src/main.c    **** 
 292:src/main.c    **** void vMEMSTask(void *pvParameters)
 293:src/main.c    **** {
 633              		.loc 1 293 0
 634              		.cfi_startproc
 635              		@ args = 0, pretend = 0, frame = 32
 636              		@ frame_needed = 1, uses_anonymous_args = 0
 637 0000 80B5     		push	{r7, lr}
 638              	.LCFI20:
 639              		.cfi_def_cfa_offset 8
 640              		.cfi_offset 14, -4
 641              		.cfi_offset 7, -8
 642 0002 88B0     		sub	sp, sp, #32
 643              	.LCFI21:
 644              		.cfi_def_cfa_offset 40
 645 0004 00AF     		add	r7, sp, #0
 646              	.LCFI22:
 647              		.cfi_def_cfa_register 7
 648 0006 7860     		str	r0, [r7, #4]
 294:src/main.c    **** 	/* queue for MEMS data length */
 295:src/main.c    ****     volatile int *LED;
 296:src/main.c    ****     LED = (int *) pvParameters;
 649              		.loc 1 296 0
 650 0008 7B68     		ldr	r3, [r7, #4]
 651 000a BB61     		str	r3, [r7, #24]
 297:src/main.c    **** 
 298:src/main.c    **** 
 299:src/main.c    **** 	uint8_t Buffer_x[1];
 300:src/main.c    **** 	uint8_t Buffer_y[1];
 301:src/main.c    **** 	uint8_t counter  = 0;
 652              		.loc 1 301 0
 653 000c 4FF00003 		mov	r3, #0
 654 0010 FB77     		strb	r3, [r7, #31]
 302:src/main.c    **** 	__IO uint32_t TimingDelay = 0;
 655              		.loc 1 302 0
 656 0012 4FF00003 		mov	r3, #0
 657 0016 FB60     		str	r3, [r7, #12]
 303:src/main.c    **** 	__IO int8_t XOffset;
 304:src/main.c    **** 	__IO int8_t YOffset;
 305:src/main.c    **** 
 306:src/main.c    **** 
 307:src/main.c    **** 	int8_t temp1 = 0;
 658              		.loc 1 307 0
 659 0018 4FF00003 		mov	r3, #0
 660 001c FB75     		strb	r3, [r7, #23]
 308:src/main.c    **** 	int8_t temp2 = 0;
 661              		.loc 1 308 0
 662 001e 4FF00003 		mov	r3, #0
 663 0022 BB75     		strb	r3, [r7, #22]
 309:src/main.c    **** 
 310:src/main.c    ****   	uint8_t TempAcceleration = 0;   
 664              		.loc 1 310 0
 665 0024 4FF00003 		mov	r3, #0
 666 0028 7B75     		strb	r3, [r7, #21]
 311:src/main.c    **** 
 312:src/main.c    **** 	/* reset offset */
 313:src/main.c    **** 
 314:src/main.c    **** 
 315:src/main.c    ****   	LIS302DL_Read(Buffer_x, LIS302DL_OUT_X_ADDR, 1);
 667              		.loc 1 315 0
 668 002a 07F11403 		add	r3, r7, #20
 669 002e 1846     		mov	r0, r3
 670 0030 4FF02901 		mov	r1, #41
 671 0034 4FF00102 		mov	r2, #1
 672 0038 FFF7FEFF 		bl	LIS302DL_Read
 316:src/main.c    **** 	LIS302DL_Read(Buffer_y, LIS302DL_OUT_Y_ADDR, 1);
 673              		.loc 1 316 0
 674 003c 07F11003 		add	r3, r7, #16
 675 0040 1846     		mov	r0, r3
 676 0042 4FF02B01 		mov	r1, #43
 677 0046 4FF00102 		mov	r2, #1
 678 004a FFF7FEFF 		bl	LIS302DL_Read
 317:src/main.c    ****             
 318:src/main.c    ****   	XOffset = Buffer_x[0];
 679              		.loc 1 318 0
 680 004e 3B7D     		ldrb	r3, [r7, #20]	@ zero_extendqisi2
 681 0050 DBB2     		uxtb	r3, r3
 682 0052 FB72     		strb	r3, [r7, #11]
 319:src/main.c    ****   	YOffset = Buffer_y[0];
 683              		.loc 1 319 0
 684 0054 3B7C     		ldrb	r3, [r7, #16]	@ zero_extendqisi2
 685 0056 DBB2     		uxtb	r3, r3
 686 0058 BB72     		strb	r3, [r7, #10]
 687 005a 00E0     		b	.L25
 688              	.L26:
 320:src/main.c    **** 	/* reset */
 321:src/main.c    **** 	
 322:src/main.c    **** 
 323:src/main.c    **** 
 324:src/main.c    **** for( ;; )
 325:src/main.c    **** {
 326:src/main.c    **** 	counter++;
 327:src/main.c    **** 	if (counter == 10)
 328:src/main.c    **** 	{
 329:src/main.c    **** 
 330:src/main.c    ****   	LIS302DL_Read(Buffer_x, LIS302DL_OUT_X_ADDR, 1);
 331:src/main.c    **** 	LIS302DL_Read(Buffer_y, LIS302DL_OUT_Y_ADDR, 1);
 332:src/main.c    **** 
 333:src/main.c    ****       /* Remove the offsets values from data */
 334:src/main.c    ****       Buffer_x[0] -= XOffset;
 335:src/main.c    ****       Buffer_y[0] -= YOffset;
 336:src/main.c    **** 		if ((int8_t)Buffer_x[0] > 2 && (int8_t)Buffer_y[0] > 2)
 337:src/main.c    **** 		{
 338:src/main.c    **** 		PWM_Motor1 = 0*(int8_t)Buffer_x[0];//left
 339:src/main.c    **** 		PWM_Motor2 = 10*(int8_t)Buffer_y[0];//up
 340:src/main.c    **** 		PWM_Motor3 = 10*(int8_t)Buffer_x[0];//right
 341:src/main.c    **** 		PWM_Motor4 = 0*(int8_t)Buffer_y[0];//dowm
 342:src/main.c    **** 		}
 343:src/main.c    **** 		else if((int8_t)Buffer_x[0] < -2 && (int8_t)Buffer_y[0] < -2)
 344:src/main.c    **** 		{
 345:src/main.c    **** 		PWM_Motor1 = -10*(int8_t)Buffer_x[0];//left
 346:src/main.c    **** 		PWM_Motor2 = 0;//up
 347:src/main.c    **** 		PWM_Motor3 = 0;//right
 348:src/main.c    **** 		PWM_Motor4 = -10*(int8_t)Buffer_y[0];//dowm		
 349:src/main.c    **** 		}
 350:src/main.c    **** 	}
 351:src/main.c    **** }
 689              		.loc 1 351 0
 690 005c 00BF     		nop
 691              	.L25:
 326:src/main.c    **** 	counter++;
 692              		.loc 1 326 0
 693 005e FB7F     		ldrb	r3, [r7, #31]
 694 0060 03F10103 		add	r3, r3, #1
 695 0064 FB77     		strb	r3, [r7, #31]
 327:src/main.c    **** 	if (counter == 10)
 696              		.loc 1 327 0
 697 0066 FB7F     		ldrb	r3, [r7, #31]	@ zero_extendqisi2
 698 0068 0A2B     		cmp	r3, #10
 699 006a F7D1     		bne	.L26
 330:src/main.c    ****   	LIS302DL_Read(Buffer_x, LIS302DL_OUT_X_ADDR, 1);
 700              		.loc 1 330 0
 701 006c 07F11403 		add	r3, r7, #20
 702 0070 1846     		mov	r0, r3
 703 0072 4FF02901 		mov	r1, #41
 704 0076 4FF00102 		mov	r2, #1
 705 007a FFF7FEFF 		bl	LIS302DL_Read
 331:src/main.c    **** 	LIS302DL_Read(Buffer_y, LIS302DL_OUT_Y_ADDR, 1);
 706              		.loc 1 331 0
 707 007e 07F11003 		add	r3, r7, #16
 708 0082 1846     		mov	r0, r3
 709 0084 4FF02B01 		mov	r1, #43
 710 0088 4FF00102 		mov	r2, #1
 711 008c FFF7FEFF 		bl	LIS302DL_Read
 334:src/main.c    ****       Buffer_x[0] -= XOffset;
 712              		.loc 1 334 0
 713 0090 3A7D     		ldrb	r2, [r7, #20]	@ zero_extendqisi2
 714 0092 FB7A     		ldrb	r3, [r7, #11]
 715 0094 DBB2     		uxtb	r3, r3
 716 0096 DBB2     		uxtb	r3, r3
 717 0098 D31A     		subs	r3, r2, r3
 718 009a DBB2     		uxtb	r3, r3
 719 009c 3B75     		strb	r3, [r7, #20]
 335:src/main.c    ****       Buffer_y[0] -= YOffset;
 720              		.loc 1 335 0
 721 009e 3A7C     		ldrb	r2, [r7, #16]	@ zero_extendqisi2
 722 00a0 BB7A     		ldrb	r3, [r7, #10]
 723 00a2 DBB2     		uxtb	r3, r3
 724 00a4 DBB2     		uxtb	r3, r3
 725 00a6 D31A     		subs	r3, r2, r3
 726 00a8 DBB2     		uxtb	r3, r3
 727 00aa 3B74     		strb	r3, [r7, #16]
 336:src/main.c    **** 		if ((int8_t)Buffer_x[0] > 2 && (int8_t)Buffer_y[0] > 2)
 728              		.loc 1 336 0
 729 00ac 3B7D     		ldrb	r3, [r7, #20]	@ zero_extendqisi2
 730 00ae DBB2     		uxtb	r3, r3
 731 00b0 5BB2     		sxtb	r3, r3
 732 00b2 022B     		cmp	r3, #2
 733 00b4 2FDD     		ble	.L24
 336:src/main.c    **** 		if ((int8_t)Buffer_x[0] > 2 && (int8_t)Buffer_y[0] > 2)
 734              		.loc 1 336 0 is_stmt 0 discriminator 1
 735 00b6 3B7C     		ldrb	r3, [r7, #16]	@ zero_extendqisi2
 736 00b8 DBB2     		uxtb	r3, r3
 737 00ba 5BB2     		sxtb	r3, r3
 738 00bc 022B     		cmp	r3, #2
 739 00be 2ADD     		ble	.L24
 338:src/main.c    **** 		PWM_Motor1 = 0*(int8_t)Buffer_x[0];//left
 740              		.loc 1 338 0 is_stmt 1
 741 00c0 4FF40063 		mov	r3, #2048
 742 00c4 C4F20003 		movt	r3, 16384
 743 00c8 4FF00002 		mov	r2, #0
 744 00cc 5A63     		str	r2, [r3, #52]
 339:src/main.c    **** 		PWM_Motor2 = 10*(int8_t)Buffer_y[0];//up
 745              		.loc 1 339 0
 746 00ce 4FF40062 		mov	r2, #2048
 747 00d2 C4F20002 		movt	r2, 16384
 748 00d6 3B7C     		ldrb	r3, [r7, #16]	@ zero_extendqisi2
 749 00d8 DBB2     		uxtb	r3, r3
 750 00da 59B2     		sxtb	r1, r3
 751 00dc 0B46     		mov	r3, r1
 752 00de 4FEA8303 		lsl	r3, r3, #2
 753 00e2 5B18     		adds	r3, r3, r1
 754 00e4 4FEA4303 		lsl	r3, r3, #1
 755 00e8 9363     		str	r3, [r2, #56]
 340:src/main.c    **** 		PWM_Motor3 = 10*(int8_t)Buffer_x[0];//right
 756              		.loc 1 340 0
 757 00ea 4FF40062 		mov	r2, #2048
 758 00ee C4F20002 		movt	r2, 16384
 759 00f2 3B7D     		ldrb	r3, [r7, #20]	@ zero_extendqisi2
 760 00f4 DBB2     		uxtb	r3, r3
 761 00f6 59B2     		sxtb	r1, r3
 762 00f8 0B46     		mov	r3, r1
 763 00fa 4FEA8303 		lsl	r3, r3, #2
 764 00fe 5B18     		adds	r3, r3, r1
 765 0100 4FEA4303 		lsl	r3, r3, #1
 766 0104 D363     		str	r3, [r2, #60]
 341:src/main.c    **** 		PWM_Motor4 = 0*(int8_t)Buffer_y[0];//dowm
 767              		.loc 1 341 0
 768 0106 4FF40063 		mov	r3, #2048
 769 010a C4F20003 		movt	r3, 16384
 770 010e 4FF00002 		mov	r2, #0
 771 0112 1A64     		str	r2, [r3, #64]
 772              		.loc 1 351 0
 773 0114 A2E7     		b	.L26
 774              	.L24:
 343:src/main.c    **** 		else if((int8_t)Buffer_x[0] < -2 && (int8_t)Buffer_y[0] < -2)
 775              		.loc 1 343 0
 776 0116 3B7D     		ldrb	r3, [r7, #20]	@ zero_extendqisi2
 777 0118 DBB2     		uxtb	r3, r3
 778 011a 5BB2     		sxtb	r3, r3
 779 011c 13F1020F 		cmn	r3, #2
 780 0120 9CDA     		bge	.L26
 343:src/main.c    **** 		else if((int8_t)Buffer_x[0] < -2 && (int8_t)Buffer_y[0] < -2)
 781              		.loc 1 343 0 is_stmt 0 discriminator 1
 782 0122 3B7C     		ldrb	r3, [r7, #16]	@ zero_extendqisi2
 783 0124 DBB2     		uxtb	r3, r3
 784 0126 5BB2     		sxtb	r3, r3
 785 0128 13F1020F 		cmn	r3, #2
 786 012c 96DA     		bge	.L26
 345:src/main.c    **** 		PWM_Motor1 = -10*(int8_t)Buffer_x[0];//left
 787              		.loc 1 345 0 is_stmt 1
 788 012e 4FF40063 		mov	r3, #2048
 789 0132 C4F20003 		movt	r3, 16384
 790 0136 3A7D     		ldrb	r2, [r7, #20]	@ zero_extendqisi2
 791 0138 D2B2     		uxtb	r2, r2
 792 013a 52B2     		sxtb	r2, r2
 793 013c 6FF00901 		mvn	r1, #9
 794 0140 01FB02F2 		mul	r2, r1, r2
 795 0144 5A63     		str	r2, [r3, #52]
 346:src/main.c    **** 		PWM_Motor2 = 0;//up
 796              		.loc 1 346 0
 797 0146 4FF40063 		mov	r3, #2048
 798 014a C4F20003 		movt	r3, 16384
 799 014e 4FF00002 		mov	r2, #0
 800 0152 9A63     		str	r2, [r3, #56]
 347:src/main.c    **** 		PWM_Motor3 = 0;//right
 801              		.loc 1 347 0
 802 0154 4FF40063 		mov	r3, #2048
 803 0158 C4F20003 		movt	r3, 16384
 804 015c 4FF00002 		mov	r2, #0
 805 0160 DA63     		str	r2, [r3, #60]
 348:src/main.c    **** 		PWM_Motor4 = -10*(int8_t)Buffer_y[0];//dowm		
 806              		.loc 1 348 0
 807 0162 4FF40063 		mov	r3, #2048
 808 0166 C4F20003 		movt	r3, 16384
 809 016a 3A7C     		ldrb	r2, [r7, #16]	@ zero_extendqisi2
 810 016c D2B2     		uxtb	r2, r2
 811 016e 52B2     		sxtb	r2, r2
 812 0170 6FF00901 		mvn	r1, #9
 813 0174 01FB02F2 		mul	r2, r1, r2
 814 0178 1A64     		str	r2, [r3, #64]
 815              		.loc 1 351 0
 816 017a 6FE7     		b	.L26
 817              		.cfi_endproc
 818              	.LFE117:
 820              		.section	.text.vBALANCETask,"ax",%progbits
 821              		.align	2
 822              		.thumb
 823              		.thumb_func
 825              	vBALANCETask:
 826              	.LFB118:
 352:src/main.c    **** }
 353:src/main.c    **** 
 354:src/main.c    **** /*-----------------------------------------------------------*/
 355:src/main.c    **** 
 356:src/main.c    **** void vBALANCETask(void *pvParameters)
 357:src/main.c    **** {
 827              		.loc 1 357 0
 828              		.cfi_startproc
 829              		@ args = 0, pretend = 0, frame = 24
 830              		@ frame_needed = 1, uses_anonymous_args = 0
 831 0000 80B5     		push	{r7, lr}
 832              	.LCFI23:
 833              		.cfi_def_cfa_offset 8
 834              		.cfi_offset 14, -4
 835              		.cfi_offset 7, -8
 836 0002 86B0     		sub	sp, sp, #24
 837              	.LCFI24:
 838              		.cfi_def_cfa_offset 32
 839 0004 00AF     		add	r7, sp, #0
 840              	.LCFI25:
 841              		.cfi_def_cfa_register 7
 842 0006 7860     		str	r0, [r7, #4]
 358:src/main.c    **** 	uint8_t temp1, temp2 = 0;
 843              		.loc 1 358 0
 844 0008 4FF00003 		mov	r3, #0
 845 000c FB75     		strb	r3, [r7, #23]
 359:src/main.c    **** 	__IO uint8_t TempAcceleration = 0;
 846              		.loc 1 359 0
 847 000e 4FF00003 		mov	r3, #0
 848 0012 7B75     		strb	r3, [r7, #21]
 849              	.L33:
 360:src/main.c    **** 	uint8_t xBuffer_receive[queueSIZE];
 361:src/main.c    **** 	for( ;; )
 362:src/main.c    **** 	{
 363:src/main.c    **** 	 if(xQueueReceive(xQueue,xBuffer_receive,0)==pdPASS)
 850              		.loc 1 363 0
 851 0014 40F20003 		movw	r3, #:lower16:xQueue
 852 0018 C0F20003 		movt	r3, #:upper16:xQueue
 853 001c 1B68     		ldr	r3, [r3, #0]
 854 001e 1846     		mov	r0, r3
 855 0020 07F10C03 		add	r3, r7, #12
 856 0024 1946     		mov	r1, r3
 857 0026 4FF00002 		mov	r2, #0
 858 002a 4FF00003 		mov	r3, #0
 859 002e FFF7FEFF 		bl	xQueueGenericReceive
 860 0032 0346     		mov	r3, r0
 861 0034 012B     		cmp	r3, #1
 862 0036 40F0C080 		bne	.L28
 364:src/main.c    **** 		{
 365:src/main.c    **** 		/* Disable All TIM4 Capture Compare Channels */
 366:src/main.c    **** 		TIM_CCxCmd(TIM4, TIM_Channel_1, DISABLE);
 863              		.loc 1 366 0
 864 003a 4FF40060 		mov	r0, #2048
 865 003e C4F20000 		movt	r0, 16384
 866 0042 4FF00001 		mov	r1, #0
 867 0046 4FF00002 		mov	r2, #0
 868 004a FFF7FEFF 		bl	TIM_CCxCmd
 367:src/main.c    **** 		TIM_CCxCmd(TIM4, TIM_Channel_2, DISABLE);
 869              		.loc 1 367 0
 870 004e 4FF40060 		mov	r0, #2048
 871 0052 C4F20000 		movt	r0, 16384
 872 0056 4FF00401 		mov	r1, #4
 873 005a 4FF00002 		mov	r2, #0
 874 005e FFF7FEFF 		bl	TIM_CCxCmd
 368:src/main.c    **** 		TIM_CCxCmd(TIM4, TIM_Channel_3, DISABLE);
 875              		.loc 1 368 0
 876 0062 4FF40060 		mov	r0, #2048
 877 0066 C4F20000 		movt	r0, 16384
 878 006a 4FF00801 		mov	r1, #8
 879 006e 4FF00002 		mov	r2, #0
 880 0072 FFF7FEFF 		bl	TIM_CCxCmd
 369:src/main.c    **** 		TIM_CCxCmd(TIM4, TIM_Channel_4, DISABLE);
 881              		.loc 1 369 0
 882 0076 4FF40060 		mov	r0, #2048
 883 007a C4F20000 		movt	r0, 16384
 884 007e 4FF00C01 		mov	r1, #12
 885 0082 4FF00002 		mov	r2, #0
 886 0086 FFF7FEFF 		bl	TIM_CCxCmd
 370:src/main.c    **** 
 371:src/main.c    **** 		/* Update autoreload and capture compare registers value*/
 372:src/main.c    **** 		temp1=((int8_t)(xBuffer_receive[0])<0)?(int8_t)(xBuffer_receive[0])*(-1):(int8_t)(xBuffer_receive
 887              		.loc 1 372 0
 888 008a 3B7B     		ldrb	r3, [r7, #12]	@ zero_extendqisi2
 889 008c DBB2     		uxtb	r3, r3
 890 008e 5BB2     		sxtb	r3, r3
 891 0090 002B     		cmp	r3, #0
 892 0092 B8BF     		it	lt
 893 0094 5B42     		rsblt	r3, r3, #0
 894 0096 BB75     		strb	r3, [r7, #22]
 373:src/main.c    **** 		temp2=((int8_t)(xBuffer_receive[2])<0)?(int8_t)(xBuffer_receive[2])*(-1):(int8_t)(xBuffer_receive
 895              		.loc 1 373 0
 896 0098 BB7B     		ldrb	r3, [r7, #14]	@ zero_extendqisi2
 897 009a DBB2     		uxtb	r3, r3
 898 009c 5BB2     		sxtb	r3, r3
 899 009e 002B     		cmp	r3, #0
 900 00a0 B8BF     		it	lt
 901 00a2 5B42     		rsblt	r3, r3, #0
 902 00a4 FB75     		strb	r3, [r7, #23]
 374:src/main.c    **** 		TempAcceleration = (temp1<temp2)?temp2:temp1; //MAX(temp1,temp2)
 903              		.loc 1 374 0
 904 00a6 BA7D     		ldrb	r2, [r7, #22]	@ zero_extendqisi2
 905 00a8 FB7D     		ldrb	r3, [r7, #23]	@ zero_extendqisi2
 906 00aa 9A42     		cmp	r2, r3
 907 00ac 28BF     		it	cs
 908 00ae 1346     		movcs	r3, r2
 909 00b0 DBB2     		uxtb	r3, r3
 910 00b2 7B75     		strb	r3, [r7, #21]
 375:src/main.c    **** 
 376:src/main.c    **** 		if(TempAcceleration != 0)
 911              		.loc 1 376 0
 912 00b4 7B7D     		ldrb	r3, [r7, #21]
 913 00b6 DBB2     		uxtb	r3, r3
 914 00b8 002B     		cmp	r3, #0
 915 00ba 7ED0     		beq	.L28
 377:src/main.c    **** 		{
 378:src/main.c    **** 			if ((int8_t)xBuffer_receive[0] < -2)
 916              		.loc 1 378 0
 917 00bc 3B7B     		ldrb	r3, [r7, #12]	@ zero_extendqisi2
 918 00be DBB2     		uxtb	r3, r3
 919 00c0 5BB2     		sxtb	r3, r3
 920 00c2 13F1020F 		cmn	r3, #2
 921 00c6 16DA     		bge	.L29
 379:src/main.c    **** 			{
 380:src/main.c    **** 				/* Enable TIM4 Capture Compare Channel 4 */
 381:src/main.c    **** 				TIM_CCxCmd(TIM4, TIM_Channel_4, ENABLE);
 922              		.loc 1 381 0
 923 00c8 4FF40060 		mov	r0, #2048
 924 00cc C4F20000 		movt	r0, 16384
 925 00d0 4FF00C01 		mov	r1, #12
 926 00d4 4FF00102 		mov	r2, #1
 927 00d8 FFF7FEFF 		bl	TIM_CCxCmd
 382:src/main.c    **** 				/* Sets the TIM4 Capture Compare4 Register value */
 383:src/main.c    **** 				TIM_SetCompare4(TIM4, TIM_CCR/TempAcceleration);
 928              		.loc 1 383 0
 929 00dc 7B7D     		ldrb	r3, [r7, #21]
 930 00de DBB2     		uxtb	r3, r3
 931 00e0 4FF47A72 		mov	r2, #1000
 932 00e4 92FBF3F3 		sdiv	r3, r2, r3
 933 00e8 4FF40060 		mov	r0, #2048
 934 00ec C4F20000 		movt	r0, 16384
 935 00f0 1946     		mov	r1, r3
 936 00f2 FFF7FEFF 		bl	TIM_SetCompare4
 937              	.L29:
 384:src/main.c    **** 			}
 385:src/main.c    **** 			if ((int8_t)xBuffer_receive[0] > 2)
 938              		.loc 1 385 0
 939 00f6 3B7B     		ldrb	r3, [r7, #12]	@ zero_extendqisi2
 940 00f8 DBB2     		uxtb	r3, r3
 941 00fa 5BB2     		sxtb	r3, r3
 942 00fc 022B     		cmp	r3, #2
 943 00fe 16DD     		ble	.L30
 386:src/main.c    **** 			{
 387:src/main.c    **** 				/* Enable TIM4 Capture Compare Channel 2 */
 388:src/main.c    **** 				TIM_CCxCmd(TIM4, TIM_Channel_2, ENABLE);
 944              		.loc 1 388 0
 945 0100 4FF40060 		mov	r0, #2048
 946 0104 C4F20000 		movt	r0, 16384
 947 0108 4FF00401 		mov	r1, #4
 948 010c 4FF00102 		mov	r2, #1
 949 0110 FFF7FEFF 		bl	TIM_CCxCmd
 389:src/main.c    **** 				/* Sets the TIM4 Capture Compare2 Register value */
 390:src/main.c    **** 				TIM_SetCompare2(TIM4, TIM_CCR/TempAcceleration);
 950              		.loc 1 390 0
 951 0114 7B7D     		ldrb	r3, [r7, #21]
 952 0116 DBB2     		uxtb	r3, r3
 953 0118 4FF47A72 		mov	r2, #1000
 954 011c 92FBF3F3 		sdiv	r3, r2, r3
 955 0120 4FF40060 		mov	r0, #2048
 956 0124 C4F20000 		movt	r0, 16384
 957 0128 1946     		mov	r1, r3
 958 012a FFF7FEFF 		bl	TIM_SetCompare2
 959              	.L30:
 391:src/main.c    **** 			}
 392:src/main.c    **** 			if ((int8_t)xBuffer_receive[2] > 2)
 960              		.loc 1 392 0
 961 012e BB7B     		ldrb	r3, [r7, #14]	@ zero_extendqisi2
 962 0130 DBB2     		uxtb	r3, r3
 963 0132 5BB2     		sxtb	r3, r3
 964 0134 022B     		cmp	r3, #2
 965 0136 16DD     		ble	.L31
 393:src/main.c    **** 			{
 394:src/main.c    **** 				/* Enable TIM4 Capture Compare Channel 1 */
 395:src/main.c    **** 				TIM_CCxCmd(TIM4, TIM_Channel_1, ENABLE);
 966              		.loc 1 395 0
 967 0138 4FF40060 		mov	r0, #2048
 968 013c C4F20000 		movt	r0, 16384
 969 0140 4FF00001 		mov	r1, #0
 970 0144 4FF00102 		mov	r2, #1
 971 0148 FFF7FEFF 		bl	TIM_CCxCmd
 396:src/main.c    **** 				/* Sets the TIM4 Capture Compare1 Register value */
 397:src/main.c    **** 				TIM_SetCompare1(TIM4, TIM_CCR/TempAcceleration);
 972              		.loc 1 397 0
 973 014c 7B7D     		ldrb	r3, [r7, #21]
 974 014e DBB2     		uxtb	r3, r3
 975 0150 4FF47A72 		mov	r2, #1000
 976 0154 92FBF3F3 		sdiv	r3, r2, r3
 977 0158 4FF40060 		mov	r0, #2048
 978 015c C4F20000 		movt	r0, 16384
 979 0160 1946     		mov	r1, r3
 980 0162 FFF7FEFF 		bl	TIM_SetCompare1
 981              	.L31:
 398:src/main.c    **** 			}
 399:src/main.c    **** 			if ((int8_t)xBuffer_receive[2] < -2)
 982              		.loc 1 399 0
 983 0166 BB7B     		ldrb	r3, [r7, #14]	@ zero_extendqisi2
 984 0168 DBB2     		uxtb	r3, r3
 985 016a 5BB2     		sxtb	r3, r3
 986 016c 13F1020F 		cmn	r3, #2
 987 0170 16DA     		bge	.L32
 400:src/main.c    **** 			{
 401:src/main.c    **** 				/* Enable TIM4 Capture Compare Channel 3 */
 402:src/main.c    **** 				TIM_CCxCmd(TIM4, TIM_Channel_3, ENABLE);
 988              		.loc 1 402 0
 989 0172 4FF40060 		mov	r0, #2048
 990 0176 C4F20000 		movt	r0, 16384
 991 017a 4FF00801 		mov	r1, #8
 992 017e 4FF00102 		mov	r2, #1
 993 0182 FFF7FEFF 		bl	TIM_CCxCmd
 403:src/main.c    **** 				/* Sets the TIM4 Capture Compare3 Register value */
 404:src/main.c    **** 				TIM_SetCompare3(TIM4, TIM_CCR/TempAcceleration);
 994              		.loc 1 404 0
 995 0186 7B7D     		ldrb	r3, [r7, #21]
 996 0188 DBB2     		uxtb	r3, r3
 997 018a 4FF47A72 		mov	r2, #1000
 998 018e 92FBF3F3 		sdiv	r3, r2, r3
 999 0192 4FF40060 		mov	r0, #2048
 1000 0196 C4F20000 		movt	r0, 16384
 1001 019a 1946     		mov	r1, r3
 1002 019c FFF7FEFF 		bl	TIM_SetCompare3
 1003              	.L32:
 405:src/main.c    **** 			}
 406:src/main.c    **** 
 407:src/main.c    **** 			/* Time base configuration */
 408:src/main.c    **** 			TIM_SetAutoreload(TIM4,  TIM_ARR/TempAcceleration);
 1004              		.loc 1 408 0
 1005 01a0 7B7D     		ldrb	r3, [r7, #21]
 1006 01a2 DBB2     		uxtb	r3, r3
 1007 01a4 40F26C72 		movw	r2, #1900
 1008 01a8 92FBF3F3 		sdiv	r3, r2, r3
 1009 01ac 4FF40060 		mov	r0, #2048
 1010 01b0 C4F20000 		movt	r0, 16384
 1011 01b4 1946     		mov	r1, r3
 1012 01b6 FFF7FEFF 		bl	TIM_SetAutoreload
 1013              	.L28:
 409:src/main.c    **** 		}
 410:src/main.c    **** 	 }
 411:src/main.c    **** 	taskYIELD(); 	//task is going to ready state to allow next one to run
 1014              		.loc 1 411 0
 1015 01ba FFF7FEFF 		bl	vPortYieldFromISR
 412:src/main.c    **** 	}
 1016              		.loc 1 412 0
 1017 01be 29E7     		b	.L33
 1018              		.cfi_endproc
 1019              	.LFE118:
 1021              		.section	.text.vLEDTask,"ax",%progbits
 1022              		.align	2
 1023              		.thumb
 1024              		.thumb_func
 1026              	vLEDTask:
 1027              	.LFB119:
 413:src/main.c    **** }
 414:src/main.c    **** 
 415:src/main.c    **** /*-----------------------------------------------------------*/
 416:src/main.c    **** 
 417:src/main.c    **** void vLEDTask( void *pvParameters )
 418:src/main.c    **** {
 1028              		.loc 1 418 0
 1029              		.cfi_startproc
 1030              		@ args = 0, pretend = 0, frame = 16
 1031              		@ frame_needed = 1, uses_anonymous_args = 0
 1032 0000 80B5     		push	{r7, lr}
 1033              	.LCFI26:
 1034              		.cfi_def_cfa_offset 8
 1035              		.cfi_offset 14, -4
 1036              		.cfi_offset 7, -8
 1037 0002 84B0     		sub	sp, sp, #16
 1038              	.LCFI27:
 1039              		.cfi_def_cfa_offset 24
 1040 0004 00AF     		add	r7, sp, #0
 1041              	.LCFI28:
 1042              		.cfi_def_cfa_register 7
 1043 0006 7860     		str	r0, [r7, #4]
 419:src/main.c    ****     volatile int *LED;
 420:src/main.c    ****     LED = (int *) pvParameters;
 1044              		.loc 1 420 0
 1045 0008 7B68     		ldr	r3, [r7, #4]
 1046 000a FB60     		str	r3, [r7, #12]
 1047              	.L35:
 421:src/main.c    **** 
 422:src/main.c    **** 	for( ;; )
 423:src/main.c    **** 	{
 424:src/main.c    **** 		STM_EVAL_LEDToggle((Led_TypeDef)LED[0]);
 1048              		.loc 1 424 0 discriminator 1
 1049 000c FB68     		ldr	r3, [r7, #12]
 1050 000e 1B68     		ldr	r3, [r3, #0]
 1051 0010 DBB2     		uxtb	r3, r3
 1052 0012 1846     		mov	r0, r3
 1053 0014 FFF7FEFF 		bl	STM_EVAL_LEDToggle
 425:src/main.c    **** 	    vTaskDelay(LED[1]/portTICK_RATE_MS);
 1054              		.loc 1 425 0 discriminator 1
 1055 0018 FB68     		ldr	r3, [r7, #12]
 1056 001a 03F10403 		add	r3, r3, #4
 1057 001e 1B68     		ldr	r3, [r3, #0]
 1058 0020 1846     		mov	r0, r3
 1059 0022 FFF7FEFF 		bl	vTaskDelay
 426:src/main.c    **** 	}
 1060              		.loc 1 426 0 discriminator 1
 1061 0026 F1E7     		b	.L35
 1062              		.cfi_endproc
 1063              	.LFE119:
 1065              		.section	.text.vSWITCHTask,"ax",%progbits
 1066              		.align	2
 1067              		.thumb
 1068              		.thumb_func
 1070              	vSWITCHTask:
 1071              	.LFB120:
 427:src/main.c    **** }
 428:src/main.c    **** 
 429:src/main.c    **** /*-----------------------------------------------------------*/
 430:src/main.c    **** 
 431:src/main.c    **** void vSWITCHTask( void *pvParameters )
 432:src/main.c    **** {
 1072              		.loc 1 432 0
 1073              		.cfi_startproc
 1074              		@ args = 0, pretend = 0, frame = 8
 1075              		@ frame_needed = 1, uses_anonymous_args = 0
 1076 0000 80B5     		push	{r7, lr}
 1077              	.LCFI29:
 1078              		.cfi_def_cfa_offset 8
 1079              		.cfi_offset 14, -4
 1080              		.cfi_offset 7, -8
 1081 0002 82B0     		sub	sp, sp, #8
 1082              	.LCFI30:
 1083              		.cfi_def_cfa_offset 16
 1084 0004 00AF     		add	r7, sp, #0
 1085              	.LCFI31:
 1086              		.cfi_def_cfa_register 7
 1087 0006 7860     		str	r0, [r7, #4]
 1088              	.L39:
 433:src/main.c    **** 	static int i=0;
 434:src/main.c    **** 	for( ;; )
 435:src/main.c    **** 	{
 436:src/main.c    **** 		if(xSemaphoreTake(xSemaphoreSW,( portTickType ) 0) == pdTRUE)
 1089              		.loc 1 436 0
 1090 0008 40F20003 		movw	r3, #:lower16:xSemaphoreSW
 1091 000c C0F20003 		movt	r3, #:upper16:xSemaphoreSW
 1092 0010 1B68     		ldr	r3, [r3, #0]
 1093 0012 1846     		mov	r0, r3
 1094 0014 4FF00001 		mov	r1, #0
 1095 0018 4FF00002 		mov	r2, #0
 1096 001c 4FF00003 		mov	r3, #0
 1097 0020 FFF7FEFF 		bl	xQueueGenericReceive
 1098 0024 0346     		mov	r3, r0
 1099 0026 012B     		cmp	r3, #1
 1100 0028 40F08C80 		bne	.L37
 437:src/main.c    **** 		{
 438:src/main.c    **** 			i^=1;		//just switch the state if semaphore was given
 1101              		.loc 1 438 0
 1102 002c 40F20003 		movw	r3, #:lower16:i.9401
 1103 0030 C0F20003 		movt	r3, #:upper16:i.9401
 1104 0034 1B68     		ldr	r3, [r3, #0]
 1105 0036 83F00102 		eor	r2, r3, #1
 1106 003a 40F20003 		movw	r3, #:lower16:i.9401
 1107 003e C0F20003 		movt	r3, #:upper16:i.9401
 1108 0042 1A60     		str	r2, [r3, #0]
 439:src/main.c    **** 
 440:src/main.c    **** 			if(i==0)	//LED3..LD6 tasks ready, BALANCE, MEMS suspended
 1109              		.loc 1 440 0
 1110 0044 40F20003 		movw	r3, #:lower16:i.9401
 1111 0048 C0F20003 		movt	r3, #:upper16:i.9401
 1112 004c 1B68     		ldr	r3, [r3, #0]
 1113 004e 002B     		cmp	r3, #0
 1114 0050 3CD1     		bne	.L38
 441:src/main.c    **** 			{
 442:src/main.c    **** 				vTaskSuspend(xBALANCE_Task);
 1115              		.loc 1 442 0
 1116 0052 40F20003 		movw	r3, #:lower16:xBALANCE_Task
 1117 0056 C0F20003 		movt	r3, #:upper16:xBALANCE_Task
 1118 005a 1B68     		ldr	r3, [r3, #0]
 1119 005c 1846     		mov	r0, r3
 1120 005e FFF7FEFF 		bl	vTaskSuspend
 443:src/main.c    **** 				TIM_Cmd(TIM4, DISABLE);
 1121              		.loc 1 443 0
 1122 0062 4FF40060 		mov	r0, #2048
 1123 0066 C4F20000 		movt	r0, 16384
 1124 006a 4FF00001 		mov	r1, #0
 1125 006e FFF7FEFF 		bl	TIM_Cmd
 444:src/main.c    **** 				vTaskSuspend(xMEMS_Task);
 1126              		.loc 1 444 0
 1127 0072 40F20003 		movw	r3, #:lower16:xMEMS_Task
 1128 0076 C0F20003 		movt	r3, #:upper16:xMEMS_Task
 1129 007a 1B68     		ldr	r3, [r3, #0]
 1130 007c 1846     		mov	r0, r3
 1131 007e FFF7FEFF 		bl	vTaskSuspend
 445:src/main.c    **** 				prvLED_Config(GPIO);
 1132              		.loc 1 445 0
 1133 0082 4FF00000 		mov	r0, #0
 1134 0086 FFF7FEFF 		bl	prvLED_Config
 446:src/main.c    **** 				vTaskResume(xLED_Tasks[0]);
 1135              		.loc 1 446 0
 1136 008a 40F20003 		movw	r3, #:lower16:xLED_Tasks
 1137 008e C0F20003 		movt	r3, #:upper16:xLED_Tasks
 1138 0092 1B68     		ldr	r3, [r3, #0]
 1139 0094 1846     		mov	r0, r3
 1140 0096 FFF7FEFF 		bl	vTaskResume
 447:src/main.c    **** 				vTaskResume(xLED_Tasks[1]);
 1141              		.loc 1 447 0
 1142 009a 40F20003 		movw	r3, #:lower16:xLED_Tasks
 1143 009e C0F20003 		movt	r3, #:upper16:xLED_Tasks
 1144 00a2 5B68     		ldr	r3, [r3, #4]
 1145 00a4 1846     		mov	r0, r3
 1146 00a6 FFF7FEFF 		bl	vTaskResume
 448:src/main.c    **** 				vTaskResume(xLED_Tasks[2]);
 1147              		.loc 1 448 0
 1148 00aa 40F20003 		movw	r3, #:lower16:xLED_Tasks
 1149 00ae C0F20003 		movt	r3, #:upper16:xLED_Tasks
 1150 00b2 9B68     		ldr	r3, [r3, #8]
 1151 00b4 1846     		mov	r0, r3
 1152 00b6 FFF7FEFF 		bl	vTaskResume
 449:src/main.c    **** 				vTaskResume(xLED_Tasks[3]);
 1153              		.loc 1 449 0
 1154 00ba 40F20003 		movw	r3, #:lower16:xLED_Tasks
 1155 00be C0F20003 		movt	r3, #:upper16:xLED_Tasks
 1156 00c2 DB68     		ldr	r3, [r3, #12]
 1157 00c4 1846     		mov	r0, r3
 1158 00c6 FFF7FEFF 		bl	vTaskResume
 1159 00ca 3BE0     		b	.L37
 1160              	.L38:
 450:src/main.c    **** 			}
 451:src/main.c    **** 			else		//MEMS and BALANCE ready, LED tasks suspended
 452:src/main.c    **** 			{
 453:src/main.c    **** 				vTaskSuspend(xLED_Tasks[0]);
 1161              		.loc 1 453 0
 1162 00cc 40F20003 		movw	r3, #:lower16:xLED_Tasks
 1163 00d0 C0F20003 		movt	r3, #:upper16:xLED_Tasks
 1164 00d4 1B68     		ldr	r3, [r3, #0]
 1165 00d6 1846     		mov	r0, r3
 1166 00d8 FFF7FEFF 		bl	vTaskSuspend
 454:src/main.c    **** 				vTaskSuspend(xLED_Tasks[1]);
 1167              		.loc 1 454 0
 1168 00dc 40F20003 		movw	r3, #:lower16:xLED_Tasks
 1169 00e0 C0F20003 		movt	r3, #:upper16:xLED_Tasks
 1170 00e4 5B68     		ldr	r3, [r3, #4]
 1171 00e6 1846     		mov	r0, r3
 1172 00e8 FFF7FEFF 		bl	vTaskSuspend
 455:src/main.c    **** 				vTaskSuspend(xLED_Tasks[2]);
 1173              		.loc 1 455 0
 1174 00ec 40F20003 		movw	r3, #:lower16:xLED_Tasks
 1175 00f0 C0F20003 		movt	r3, #:upper16:xLED_Tasks
 1176 00f4 9B68     		ldr	r3, [r3, #8]
 1177 00f6 1846     		mov	r0, r3
 1178 00f8 FFF7FEFF 		bl	vTaskSuspend
 456:src/main.c    **** 				vTaskSuspend(xLED_Tasks[3]);
 1179              		.loc 1 456 0
 1180 00fc 40F20003 		movw	r3, #:lower16:xLED_Tasks
 1181 0100 C0F20003 		movt	r3, #:upper16:xLED_Tasks
 1182 0104 DB68     		ldr	r3, [r3, #12]
 1183 0106 1846     		mov	r0, r3
 1184 0108 FFF7FEFF 		bl	vTaskSuspend
 457:src/main.c    **** 				prvLED_Config(TIMER);
 1185              		.loc 1 457 0
 1186 010c 4FF00100 		mov	r0, #1
 1187 0110 FFF7FEFF 		bl	prvLED_Config
 458:src/main.c    **** 				TIM_Cmd(TIM4, ENABLE);
 1188              		.loc 1 458 0
 1189 0114 4FF40060 		mov	r0, #2048
 1190 0118 C4F20000 		movt	r0, 16384
 1191 011c 4FF00101 		mov	r1, #1
 1192 0120 FFF7FEFF 		bl	TIM_Cmd
 459:src/main.c    **** 				vTaskResume(xBALANCE_Task);
 1193              		.loc 1 459 0
 1194 0124 40F20003 		movw	r3, #:lower16:xBALANCE_Task
 1195 0128 C0F20003 		movt	r3, #:upper16:xBALANCE_Task
 1196 012c 1B68     		ldr	r3, [r3, #0]
 1197 012e 1846     		mov	r0, r3
 1198 0130 FFF7FEFF 		bl	vTaskResume
 460:src/main.c    **** 				vTaskResume(xMEMS_Task);
 1199              		.loc 1 460 0
 1200 0134 40F20003 		movw	r3, #:lower16:xMEMS_Task
 1201 0138 C0F20003 		movt	r3, #:upper16:xMEMS_Task
 1202 013c 1B68     		ldr	r3, [r3, #0]
 1203 013e 1846     		mov	r0, r3
 1204 0140 FFF7FEFF 		bl	vTaskResume
 1205              	.L37:
 461:src/main.c    **** 			}
 462:src/main.c    **** 		}
 463:src/main.c    **** 		taskYIELD(); 	//task is going to ready state to allow next one to run
 1206              		.loc 1 463 0
 1207 0144 FFF7FEFF 		bl	vPortYieldFromISR
 464:src/main.c    **** 	}
 1208              		.loc 1 464 0
 1209 0148 5EE7     		b	.L39
 1210              		.cfi_endproc
 1211              	.LFE120:
 1213 014a 00BF     		.section	.text.vApplicationIdleHook,"ax",%progbits
 1214              		.align	2
 1215              		.global	vApplicationIdleHook
 1216              		.thumb
 1217              		.thumb_func
 1219              	vApplicationIdleHook:
 1220              	.LFB121:
 465:src/main.c    **** }
 466:src/main.c    **** 
 467:src/main.c    **** /*-----------------------------------------------------------*/
 468:src/main.c    **** 
 469:src/main.c    **** void vApplicationIdleHook( void )
 470:src/main.c    **** {
 1221              		.loc 1 470 0
 1222              		.cfi_startproc
 1223              		@ args = 0, pretend = 0, frame = 8
 1224              		@ frame_needed = 1, uses_anonymous_args = 0
 1225 0000 80B5     		push	{r7, lr}
 1226              	.LCFI32:
 1227              		.cfi_def_cfa_offset 8
 1228              		.cfi_offset 14, -4
 1229              		.cfi_offset 7, -8
 1230 0002 82B0     		sub	sp, sp, #8
 1231              	.LCFI33:
 1232              		.cfi_def_cfa_offset 16
 1233 0004 00AF     		add	r7, sp, #0
 1234              	.LCFI34:
 1235              		.cfi_def_cfa_register 7
 471:src/main.c    **** volatile size_t xFreeStackSpace;
 472:src/main.c    **** 
 473:src/main.c    **** 	/* This function is called on each cycle of the idle task.  In this case it
 474:src/main.c    **** 	does nothing useful, other than report the amout of FreeRTOS heap that 
 475:src/main.c    **** 	remains unallocated. */
 476:src/main.c    **** 	xFreeStackSpace = xPortGetFreeHeapSize();
 1236              		.loc 1 476 0
 1237 0006 FFF7FEFF 		bl	xPortGetFreeHeapSize
 1238 000a 0346     		mov	r3, r0
 1239 000c 7B60     		str	r3, [r7, #4]
 477:src/main.c    **** 
 478:src/main.c    **** 	if( xFreeStackSpace > 100 )
 1240              		.loc 1 478 0
 1241 000e 7B68     		ldr	r3, [r7, #4]
 479:src/main.c    **** 	{
 480:src/main.c    **** 		/* By now, the kernel has allocated everything it is going to, so
 481:src/main.c    **** 		if there is a lot of heap remaining unallocated then
 482:src/main.c    **** 		the value of configTOTAL_HEAP_SIZE in FreeRTOSConfig.h can be
 483:src/main.c    **** 		reduced accordingly. */
 484:src/main.c    **** 	}
 485:src/main.c    **** }
 1242              		.loc 1 485 0
 1243 0010 07F10807 		add	r7, r7, #8
 1244 0014 BD46     		mov	sp, r7
 1245 0016 80BD     		pop	{r7, pc}
 1246              		.cfi_endproc
 1247              	.LFE121:
 1249              		.section	.text.vApplicationMallocFailedHook,"ax",%progbits
 1250              		.align	2
 1251              		.global	vApplicationMallocFailedHook
 1252              		.thumb
 1253              		.thumb_func
 1255              	vApplicationMallocFailedHook:
 1256              	.LFB122:
 486:src/main.c    **** 
 487:src/main.c    **** /*-----------------------------------------------------------*/
 488:src/main.c    **** 
 489:src/main.c    **** void vApplicationMallocFailedHook( void )
 490:src/main.c    **** {
 1257              		.loc 1 490 0
 1258              		.cfi_startproc
 1259              		@ args = 0, pretend = 0, frame = 0
 1260              		@ frame_needed = 1, uses_anonymous_args = 0
 1261              		@ link register save eliminated.
 1262 0000 80B4     		push	{r7}
 1263              	.LCFI35:
 1264              		.cfi_def_cfa_offset 4
 1265              		.cfi_offset 7, -4
 1266 0002 00AF     		add	r7, sp, #0
 1267              	.LCFI36:
 1268              		.cfi_def_cfa_register 7
 1269              	.L42:
 491:src/main.c    **** 	/* Called if a call to pvPortMalloc() fails because there is insufficient
 492:src/main.c    **** 	free memory available in the FreeRTOS heap.  pvPortMalloc() is called
 493:src/main.c    **** 	internally by FreeRTOS API functions that create tasks, queues, software 
 494:src/main.c    **** 	timers, and semaphores.  The size of the FreeRTOS heap is set by the
 495:src/main.c    **** 	configTOTAL_HEAP_SIZE configuration constant in FreeRTOSConfig.h. */
 496:src/main.c    **** 	for( ;; );
 1270              		.loc 1 496 0 discriminator 1
 1271 0004 FEE7     		b	.L42
 1272              		.cfi_endproc
 1273              	.LFE122:
 1275 0006 00BF     		.section	.text.vApplicationStackOverflowHook,"ax",%progbits
 1276              		.align	2
 1277              		.global	vApplicationStackOverflowHook
 1278              		.thumb
 1279              		.thumb_func
 1281              	vApplicationStackOverflowHook:
 1282              	.LFB123:
 497:src/main.c    **** }
 498:src/main.c    **** /*-----------------------------------------------------------*/
 499:src/main.c    **** 
 500:src/main.c    **** void vApplicationStackOverflowHook( xTaskHandle *pxTask, signed char *pcTaskName )
 501:src/main.c    **** {
 1283              		.loc 1 501 0
 1284              		.cfi_startproc
 1285              		@ args = 0, pretend = 0, frame = 8
 1286              		@ frame_needed = 1, uses_anonymous_args = 0
 1287              		@ link register save eliminated.
 1288 0000 80B4     		push	{r7}
 1289              	.LCFI37:
 1290              		.cfi_def_cfa_offset 4
 1291              		.cfi_offset 7, -4
 1292 0002 83B0     		sub	sp, sp, #12
 1293              	.LCFI38:
 1294              		.cfi_def_cfa_offset 16
 1295 0004 00AF     		add	r7, sp, #0
 1296              	.LCFI39:
 1297              		.cfi_def_cfa_register 7
 1298 0006 7860     		str	r0, [r7, #4]
 1299 0008 3960     		str	r1, [r7, #0]
 1300              	.L44:
 502:src/main.c    **** 	( void ) pcTaskName;
 503:src/main.c    **** 	( void ) pxTask;
 504:src/main.c    **** 
 505:src/main.c    **** 	/* Run time stack overflow checking is performed if
 506:src/main.c    **** 	configconfigCHECK_FOR_STACK_OVERFLOW is defined to 1 or 2.  This hook
 507:src/main.c    **** 	function is called if a stack overflow is detected. */
 508:src/main.c    **** 	for( ;; );
 1301              		.loc 1 508 0 discriminator 1
 1302 000a FEE7     		b	.L44
 1303              		.cfi_endproc
 1304              	.LFE123:
 1306              		.section	.bss.i.9401,"aw",%nobits
 1307              		.align	2
 1310              	i.9401:
 1311 0000 00000000 		.space	4
 1312              		.text
 1313              	.Letext0:
 1314              		.file 2 "/home/joyshu/tmp/usr/local/csl/arm-2012.03/bin/../lib/gcc/arm-none-eabi/4.6.3/../../../..
 1315              		.file 3 "libs/Device/STM32F4xx/Include/stm32f4xx.h"
 1316              		.file 4 "libs/STM32F4xx_StdPeriph_Driver/inc/stm32f4xx_gpio.h"
 1317              		.file 5 "libs/STM32F4xx_StdPeriph_Driver/inc/stm32f4xx_tim.h"
 1318              		.file 6 "/home/joyshu/tmp/usr/local/csl/arm-2012.03/bin/../lib/gcc/arm-none-eabi/4.6.3/include/std
 1319              		.file 7 "FreeRTOS/Source/include/../../Source/portable/GCC/ARM_CM4F/portmacro.h"
 1320              		.file 8 "FreeRTOS/Source/include/task.h"
 1321              		.file 9 "FreeRTOS/Source/include/queue.h"
 1322              		.file 10 "FreeRTOS/Source/include/semphr.h"
 1323              		.file 11 "src/stm32f4_discovery.h"
DEFINED SYMBOLS
                            *ABS*:00000000 main.c
     /tmp/ccJLMkf4.s:20     .text.pwm:00000000 $t
     /tmp/ccJLMkf4.s:25     .text.pwm:00000000 pwm
     /tmp/ccJLMkf4.s:175    .text.Motor_Control:00000000 Motor_Control
     /tmp/ccJLMkf4.s:117    .text.Delay_1ms:00000000 Delay_1ms
     /tmp/ccJLMkf4.s:112    .text.Delay_1ms:00000000 $t
     /tmp/ccJLMkf4.s:170    .text.Motor_Control:00000000 $t
     /tmp/ccJLMkf4.s:293    .text.RCC_Configuration:00000000 $t
     /tmp/ccJLMkf4.s:298    .text.RCC_Configuration:00000000 RCC_Configuration
     /tmp/ccJLMkf4.s:326    .text.GPIO_Configuration:00000000 $t
     /tmp/ccJLMkf4.s:331    .text.GPIO_Configuration:00000000 GPIO_Configuration
     /tmp/ccJLMkf4.s:405    .text.TIM_Configuration:00000000 $t
     /tmp/ccJLMkf4.s:410    .text.TIM_Configuration:00000000 TIM_Configuration
                            *COM*:00000010 xLED_Tasks
                            *COM*:00000004 xMEMS_Task
                            *COM*:00000004 xBALANCE_Task
                            *COM*:00000004 ITM_RxBuffer
     /tmp/ccJLMkf4.s:503    .rodata.LEDS:00000000 $d
     /tmp/ccJLMkf4.s:506    .rodata.LEDS:00000000 LEDS
     /tmp/ccJLMkf4.s:520    .bss.xSemaphoreSW:00000000 xSemaphoreSW
     /tmp/ccJLMkf4.s:517    .bss.xSemaphoreSW:00000000 $d
                            *COM*:00000004 xQueue
     /tmp/ccJLMkf4.s:524    .rodata:00000000 $d
     /tmp/ccJLMkf4.s:525    .rodata:00000000 .LC0
     /tmp/ccJLMkf4.s:528    .text.main:00000000 $t
     /tmp/ccJLMkf4.s:533    .text.main:00000000 main
     /tmp/ccJLMkf4.s:631    .text.vMEMSTask:00000000 vMEMSTask
     /tmp/ccJLMkf4.s:627    .text.vMEMSTask:00000000 $t
     /tmp/ccJLMkf4.s:821    .text.vBALANCETask:00000000 $t
     /tmp/ccJLMkf4.s:825    .text.vBALANCETask:00000000 vBALANCETask
     /tmp/ccJLMkf4.s:1022   .text.vLEDTask:00000000 $t
     /tmp/ccJLMkf4.s:1026   .text.vLEDTask:00000000 vLEDTask
     /tmp/ccJLMkf4.s:1066   .text.vSWITCHTask:00000000 $t
     /tmp/ccJLMkf4.s:1070   .text.vSWITCHTask:00000000 vSWITCHTask
     /tmp/ccJLMkf4.s:1310   .bss.i.9401:00000000 i.9401
     /tmp/ccJLMkf4.s:1214   .text.vApplicationIdleHook:00000000 $t
     /tmp/ccJLMkf4.s:1219   .text.vApplicationIdleHook:00000000 vApplicationIdleHook
     /tmp/ccJLMkf4.s:1250   .text.vApplicationMallocFailedHook:00000000 $t
     /tmp/ccJLMkf4.s:1255   .text.vApplicationMallocFailedHook:00000000 vApplicationMallocFailedHook
     /tmp/ccJLMkf4.s:1276   .text.vApplicationStackOverflowHook:00000000 $t
     /tmp/ccJLMkf4.s:1281   .text.vApplicationStackOverflowHook:00000000 vApplicationStackOverflowHook
     /tmp/ccJLMkf4.s:1307   .bss.i.9401:00000000 $d
                     .debug_frame:00000010 $d

UNDEFINED SYMBOLS
RCC_AHB1PeriphClockCmd
RCC_APB1PeriphClockCmd
GPIO_StructInit
GPIO_PinAFConfig
GPIO_Init
TIM_TimeBaseStructInit
TIM_TimeBaseInit
TIM_OCStructInit
TIM_OC1Init
TIM_OC2Init
TIM_OC3Init
TIM_OC4Init
TIM_Cmd
xQueueCreate
xQueueGenericSend
xQueueGenericReceive
prvSetupHardware
xTaskGenericCreate
vTaskStartScheduler
LIS302DL_Read
TIM_CCxCmd
TIM_SetCompare4
TIM_SetCompare2
TIM_SetCompare1
TIM_SetCompare3
TIM_SetAutoreload
vPortYieldFromISR
STM_EVAL_LEDToggle
vTaskDelay
vTaskSuspend
prvLED_Config
vTaskResume
xPortGetFreeHeapSize
